[
   {
      "author_association" : "MEMBER",
      "body" : "Initial light Concept ACK based on first reading of the code, the documentation in `txrequest.h`, and thinking about the differences with respect to the current tx request logic. Debug build clean and local tests green at each commit. The new `txrequest` fuzzer is running so far without issues.",
      "created_at" : "2020-09-21T11:00:49Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#issuecomment-696044101",
      "id" : 696044101,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19988",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY5NjA0NDEwMQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-09-21T11:00:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/696044101",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* #19753 (p2p: don't add AlreadyHave transactions to recentRejects by troygiorshev)\n* #18985 (bloom: use Span instead of std::vector for `insert` and `contains` [ZAP3] by jb55)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.",
      "created_at" : "2020-09-21T11:34:35Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#issuecomment-696058761",
      "id" : 696058761,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19988",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY5NjA1ODc2MQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-09-22T00:51:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/696058761",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "committing to review soon(TM)",
      "created_at" : "2020-09-21T14:59:43Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#issuecomment-696171592",
      "id" : 696171592,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19988",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY5NjE3MTU5Mg==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-09-21T14:59:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/696171592",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Reviewed the first commit, \"Add txrequest module\". Overall looks good. Various minor suggestions in https://github.com/jonatack/bitcoin/commits/pr-19988-review-suggestions to not add noise here; feel free to pick and choose.",
      "created_at" : "2020-09-21T18:11:54Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#issuecomment-696281970",
      "id" : 696281970,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19988",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY5NjI4MTk3MA==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-09-21T18:11:54Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/696281970",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Pushed an update, incorporating @jonatack's nits above, and addressing a number of @ariard's comments on #19184. I also moved the entire implementation to txrequest.cpp, hidden using a `TxRequestTracker::Impl` object. I hope this makes it easier to distinguish the comments in the .h (now entirely about the observable behavior without implementation details) vs the .cpp (which works quite differently). This also fixed an AppVeyer issue with MSVC failing to compile.",
      "created_at" : "2020-09-22T00:58:59Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#issuecomment-696458038",
      "id" : 696458038,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19988",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY5NjQ1ODAzOA==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-09-22T00:58:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/696458038",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r492832470"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/492832470"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```suggestion\r\n * - Whether it's from a \"preferred\" peer or not (outbound and noban peers are preferred).\r\n```\r\n\r\nstyle-nit: Would be good to mention the exact permission flag, because legacy whitelisted is discouraged, has been deprecated, and might be removed some time in the future.\r\n\r\n(Same below)",
      "commit_id" : "4508a6e58d28eb5436031861aca1a43b76156097",
      "created_at" : "2020-09-22T15:30:39Z",
      "diff_hunk" : "@@ -0,0 +1,226 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not (outbound and whitelisted peers are preferred).",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r492832470",
      "id" : 492832470,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjgzMjQ3MA==",
      "original_commit_id" : "2cac00639e5eb22eb6b076bcc001196d958a4f2e",
      "original_line" : 28,
      "original_position" : 28,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 493590059,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-24T17:33:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/492832470",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493158786"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493158786"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "`exptime` is slightly ambiguous with \"expected time\" to me, maybe replace with \"timeout\" or \"expiry_time\" or just \"expiry\" ?",
      "commit_id" : "4508a6e58d28eb5436031861aca1a43b76156097",
      "created_at" : "2020-09-23T02:23:39Z",
      "diff_hunk" : "@@ -0,0 +1,220 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not (outbound and whitelisted peers are preferred).\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see further for details).\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"exptime\").",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493158786",
      "id" : 493158786,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE1ODc4Ng==",
      "original_commit_id" : "1b23bedf579aa615fa27a114da7cefbee756af6d",
      "original_line" : 30,
      "original_position" : 30,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 493984643,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-24T17:33:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493158786",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493160848"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493160848"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "\"(see further for details)\" is true of all these points, I think.",
      "commit_id" : "4508a6e58d28eb5436031861aca1a43b76156097",
      "created_at" : "2020-09-23T02:30:44Z",
      "diff_hunk" : "@@ -0,0 +1,220 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not (outbound and whitelisted peers are preferred).\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see further for details).",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493160848",
      "id" : 493160848,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE2MDg0OA==",
      "original_commit_id" : "1b23bedf579aa615fa27a114da7cefbee756af6d",
      "original_line" : 29,
      "original_position" : 29,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 493984643,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-24T17:33:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493160848",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493161600"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493161600"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "This was confusing -- I read it as \"the first of many markers\" rather than \"a marker indicating it was first\" and wondered what these \"markers\" were. Adding quotes around \"first\" consistently might be better?",
      "commit_id" : "4508a6e58d28eb5436031861aca1a43b76156097",
      "created_at" : "2020-09-23T02:33:34Z",
      "diff_hunk" : "@@ -0,0 +1,220 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not (outbound and whitelisted peers are preferred).\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see further for details).\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"exptime\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing exptime, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the transaction was forgotten in\n+ *   between (see next point), and re-announced.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening invblock attacks. The flip side is that as long as an attacker manages to prevent\n+ *              us from receiving a transaction, failed announcements (including those from honest peers) will\n+ *              linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on\n+ *              the number of tracked announcements per peer.\n+ *\n+ * - Announcements are only forgotten about when the peer that announced them went offline, when the transaction\n+ *   was received successfully, or when no candidates for a transaction remain that haven't been tried already.\n+ *\n+ *   Rationale: we need to eventually forget announcements to keep memory bounded, but as long as viable\n+ *              candidate peers remain, we prefer to avoid fetching from failed ones. As every request has a finite\n+ *              timeout and we schedule new request as soon a previous one expired, there is always progress being\n+ *              made towards forgetting a transaction - either successfully or unsuccessfully.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable net_processing code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers (outbound, whitelisted) are chosen by us, so are less likely to be under attacker\n+ *                control.\n+ *\n+ *   - Among the remaining candidates, choose the one with the first marker if one exists (there can be at most",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493161600",
      "id" : 493161600,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE2MTYwMA==",
      "original_commit_id" : "1b23bedf579aa615fa27a114da7cefbee756af6d",
      "original_line" : 69,
      "original_position" : 69,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 493984643,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-24T17:33:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493161600",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493162248"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493162248"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Incomplete sentence?",
      "commit_id" : "4508a6e58d28eb5436031861aca1a43b76156097",
      "created_at" : "2020-09-23T02:35:50Z",
      "diff_hunk" : "@@ -0,0 +1,220 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not (outbound and whitelisted peers are preferred).\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see further for details).\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"exptime\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing exptime, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the transaction was forgotten in\n+ *   between (see next point), and re-announced.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening invblock attacks. The flip side is that as long as an attacker manages to prevent\n+ *              us from receiving a transaction, failed announcements (including those from honest peers) will\n+ *              linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on\n+ *              the number of tracked announcements per peer.\n+ *\n+ * - Announcements are only forgotten about when the peer that announced them went offline, when the transaction\n+ *   was received successfully, or when no candidates for a transaction remain that haven't been tried already.\n+ *\n+ *   Rationale: we need to eventually forget announcements to keep memory bounded, but as long as viable\n+ *              candidate peers remain, we prefer to avoid fetching from failed ones. As every request has a finite\n+ *              timeout and we schedule new request as soon a previous one expired, there is always progress being\n+ *              made towards forgetting a transaction - either successfully or unsuccessfully.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable net_processing code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers (outbound, whitelisted) are chosen by us, so are less likely to be under attacker\n+ *                control.\n+ *\n+ *   - Among the remaining candidates, choose the one with the first marker if one exists (there can be at most\n+ *     one such peer, see further).\n+ *\n+ *     Rationale: in non-attack scenarios we want to give one chance to request from the fastest peer to reduce\n+ *                latency, and reduce risk of breaking chains of dependent transactions. An attacker who races the\n+ *                network can exploit this to delay us learning about a transaction, but it is available only once\n+ *                per txhash.\n+ *\n+ *   - If no remaining candidates have the first marker, pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: if the first mechanism failed, random assignments are hard to influence for attackers.\n+ *\n+ *   The overall effect of these rules is that an attacker that races announcements to us can delay",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493162248",
      "id" : 493162248,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE2MjI0OA==",
      "original_commit_id" : "1b23bedf579aa615fa27a114da7cefbee756af6d",
      "original_line" : 81,
      "original_position" : 81,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 493984643,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-24T17:33:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493162248",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493163586"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493163586"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Add a reference to https://allquantor.at/blockchainbib/pdf/miller2015topology.pdf to document/explain the invblock terminology? \"What does this have to do with an INV message about a block?\"",
      "commit_id" : "4508a6e58d28eb5436031861aca1a43b76156097",
      "created_at" : "2020-09-23T02:41:13Z",
      "diff_hunk" : "@@ -0,0 +1,220 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not (outbound and whitelisted peers are preferred).\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see further for details).\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"exptime\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing exptime, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the transaction was forgotten in\n+ *   between (see next point), and re-announced.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening invblock attacks. The flip side is that as long as an attacker manages to prevent\n+ *              us from receiving a transaction, failed announcements (including those from honest peers) will\n+ *              linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on\n+ *              the number of tracked announcements per peer.\n+ *\n+ * - Announcements are only forgotten about when the peer that announced them went offline, when the transaction\n+ *   was received successfully, or when no candidates for a transaction remain that haven't been tried already.\n+ *\n+ *   Rationale: we need to eventually forget announcements to keep memory bounded, but as long as viable\n+ *              candidate peers remain, we prefer to avoid fetching from failed ones. As every request has a finite\n+ *              timeout and we schedule new request as soon a previous one expired, there is always progress being\n+ *              made towards forgetting a transaction - either successfully or unsuccessfully.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable net_processing code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers (outbound, whitelisted) are chosen by us, so are less likely to be under attacker\n+ *                control.\n+ *\n+ *   - Among the remaining candidates, choose the one with the first marker if one exists (there can be at most\n+ *     one such peer, see further).\n+ *\n+ *     Rationale: in non-attack scenarios we want to give one chance to request from the fastest peer to reduce\n+ *                latency, and reduce risk of breaking chains of dependent transactions. An attacker who races the\n+ *                network can exploit this to delay us learning about a transaction, but it is available only once\n+ *                per txhash.\n+ *\n+ *   - If no remaining candidates have the first marker, pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: if the first mechanism failed, random assignments are hard to influence for attackers.\n+ *\n+ *   The overall effect of these rules is that an attacker that races announcements to us can delay\n+ *\n+ * \"First\" marker rules: the first marker is given to announcements for which at the time of announcement:\n+ * - No requests for its txhash have been attempted (ever, or since it was forgotten about).\n+ * - The peer that announced them was not overloaded.\n+ * - No announcement for the same txhash from another peer within the same preferred/nonpreferred class already has\n+ *   the first marker already.\n+ *\n+ *   Rationale: these restrictions avoid giving the speed benefit to honest but overloaded peers, and also\n+ *              reduce the impact an attacker who races the network for many transaction can have.\n+ *\n+ * Together these rules strike a balance between being fast in non-adverserial conditions and being influenceable by\n+ * attackers. An invblocking attacker that races the network:\n+ * - Will be unsuccessful if all preferred connections are honest (and there is at least one).\n+ * - If there are P preferred connections of which Ph>=1 are honest, the attacker can delay us from learning\n+ *   about a transaction by k expiration periods, where k ~ 1 + NHG(N=P-1,K=P-Ph-1,r=1), which has mean\n+ *   P/(Ph+1) (where NHG stands for Negative Hypergeometric distribution).\n+ * - If all P preferred connections are to the attacker, and there are NP non-preferred connections of which NPh are\n+ *   honest, k ~ P + 1 + NHG(N=NP-1,K=NP-NPh-1,r=1), with mean P + NP/(NPh+1).\n+ *\n+ * Complexity:\n+ * - Memory usage is proportional to the total number of tracked announcements (Size()) plus the number of\n+ *   peers with a nonzero number of tracked announcements.\n+ * - CPU usage is generally logarithmic in the total number of tracked announcements, plus the number of\n+ *   announcements affected by an operation (amortized O(1) per announcement).\n+ */",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493163586",
      "id" : 493163586,
      "line" : 107,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE2MzU4Ng==",
      "original_commit_id" : "1b23bedf579aa615fa27a114da7cefbee756af6d",
      "original_line" : 107,
      "original_position" : 106,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 107,
      "pull_request_review_id" : 493984643,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-24T17:33:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493163586",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493163901"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493163901"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "\"and **not** being influencable by attackers\"",
      "commit_id" : "4508a6e58d28eb5436031861aca1a43b76156097",
      "created_at" : "2020-09-23T02:42:25Z",
      "diff_hunk" : "@@ -0,0 +1,220 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not (outbound and whitelisted peers are preferred).\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see further for details).\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"exptime\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing exptime, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the transaction was forgotten in\n+ *   between (see next point), and re-announced.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening invblock attacks. The flip side is that as long as an attacker manages to prevent\n+ *              us from receiving a transaction, failed announcements (including those from honest peers) will\n+ *              linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on\n+ *              the number of tracked announcements per peer.\n+ *\n+ * - Announcements are only forgotten about when the peer that announced them went offline, when the transaction\n+ *   was received successfully, or when no candidates for a transaction remain that haven't been tried already.\n+ *\n+ *   Rationale: we need to eventually forget announcements to keep memory bounded, but as long as viable\n+ *              candidate peers remain, we prefer to avoid fetching from failed ones. As every request has a finite\n+ *              timeout and we schedule new request as soon a previous one expired, there is always progress being\n+ *              made towards forgetting a transaction - either successfully or unsuccessfully.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable net_processing code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers (outbound, whitelisted) are chosen by us, so are less likely to be under attacker\n+ *                control.\n+ *\n+ *   - Among the remaining candidates, choose the one with the first marker if one exists (there can be at most\n+ *     one such peer, see further).\n+ *\n+ *     Rationale: in non-attack scenarios we want to give one chance to request from the fastest peer to reduce\n+ *                latency, and reduce risk of breaking chains of dependent transactions. An attacker who races the\n+ *                network can exploit this to delay us learning about a transaction, but it is available only once\n+ *                per txhash.\n+ *\n+ *   - If no remaining candidates have the first marker, pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: if the first mechanism failed, random assignments are hard to influence for attackers.\n+ *\n+ *   The overall effect of these rules is that an attacker that races announcements to us can delay\n+ *\n+ * \"First\" marker rules: the first marker is given to announcements for which at the time of announcement:\n+ * - No requests for its txhash have been attempted (ever, or since it was forgotten about).\n+ * - The peer that announced them was not overloaded.\n+ * - No announcement for the same txhash from another peer within the same preferred/nonpreferred class already has\n+ *   the first marker already.\n+ *\n+ *   Rationale: these restrictions avoid giving the speed benefit to honest but overloaded peers, and also\n+ *              reduce the impact an attacker who races the network for many transaction can have.\n+ *\n+ * Together these rules strike a balance between being fast in non-adverserial conditions and being influenceable by",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493163901",
      "id" : 493163901,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE2MzkwMQ==",
      "original_commit_id" : "1b23bedf579aa615fa27a114da7cefbee756af6d",
      "original_line" : 92,
      "original_position" : 92,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 493984643,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-24T17:33:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493163901",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493166644"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493166644"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "\"uint64_t\" as a parameter name?",
      "commit_id" : "4508a6e58d28eb5436031861aca1a43b76156097",
      "created_at" : "2020-09-23T02:53:21Z",
      "diff_hunk" : "@@ -0,0 +1,220 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not (outbound and whitelisted peers are preferred).\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see further for details).\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"exptime\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing exptime, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the transaction was forgotten in\n+ *   between (see next point), and re-announced.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening invblock attacks. The flip side is that as long as an attacker manages to prevent\n+ *              us from receiving a transaction, failed announcements (including those from honest peers) will\n+ *              linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on\n+ *              the number of tracked announcements per peer.\n+ *\n+ * - Announcements are only forgotten about when the peer that announced them went offline, when the transaction\n+ *   was received successfully, or when no candidates for a transaction remain that haven't been tried already.\n+ *\n+ *   Rationale: we need to eventually forget announcements to keep memory bounded, but as long as viable\n+ *              candidate peers remain, we prefer to avoid fetching from failed ones. As every request has a finite\n+ *              timeout and we schedule new request as soon a previous one expired, there is always progress being\n+ *              made towards forgetting a transaction - either successfully or unsuccessfully.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable net_processing code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers (outbound, whitelisted) are chosen by us, so are less likely to be under attacker\n+ *                control.\n+ *\n+ *   - Among the remaining candidates, choose the one with the first marker if one exists (there can be at most\n+ *     one such peer, see further).\n+ *\n+ *     Rationale: in non-attack scenarios we want to give one chance to request from the fastest peer to reduce\n+ *                latency, and reduce risk of breaking chains of dependent transactions. An attacker who races the\n+ *                network can exploit this to delay us learning about a transaction, but it is available only once\n+ *                per txhash.\n+ *\n+ *   - If no remaining candidates have the first marker, pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: if the first mechanism failed, random assignments are hard to influence for attackers.\n+ *\n+ *   The overall effect of these rules is that an attacker that races announcements to us can delay\n+ *\n+ * \"First\" marker rules: the first marker is given to announcements for which at the time of announcement:\n+ * - No requests for its txhash have been attempted (ever, or since it was forgotten about).\n+ * - The peer that announced them was not overloaded.\n+ * - No announcement for the same txhash from another peer within the same preferred/nonpreferred class already has\n+ *   the first marker already.\n+ *\n+ *   Rationale: these restrictions avoid giving the speed benefit to honest but overloaded peers, and also\n+ *              reduce the impact an attacker who races the network for many transaction can have.\n+ *\n+ * Together these rules strike a balance between being fast in non-adverserial conditions and being influenceable by\n+ * attackers. An invblocking attacker that races the network:\n+ * - Will be unsuccessful if all preferred connections are honest (and there is at least one).\n+ * - If there are P preferred connections of which Ph>=1 are honest, the attacker can delay us from learning\n+ *   about a transaction by k expiration periods, where k ~ 1 + NHG(N=P-1,K=P-Ph-1,r=1), which has mean\n+ *   P/(Ph+1) (where NHG stands for Negative Hypergeometric distribution).\n+ * - If all P preferred connections are to the attacker, and there are NP non-preferred connections of which NPh are\n+ *   honest, k ~ P + 1 + NHG(N=NP-1,K=NP-NPh-1,r=1), with mean P + NP/(NPh+1).\n+ *\n+ * Complexity:\n+ * - Memory usage is proportional to the total number of tracked announcements (Size()) plus the number of\n+ *   peers with a nonzero number of tracked announcements.\n+ * - CPU usage is generally logarithmic in the total number of tracked announcements, plus the number of\n+ *   announcements affected by an operation (amortized O(1) per announcement).\n+ */\n+class TxRequestTracker {\n+public:\n+    /** A functor with embedded salt that computes priority of a txhash/peer combination. Lower priorities are\n+     *  selected first. */\n+    class PriorityComputer {\n+        const uint64_t m_k0, m_k1;\n+    public:\n+        explicit PriorityComputer(bool deterministic);\n+        uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred, bool first) const;\n+    };\n+\n+private:\n+    // Avoid littering this header file with implementation details.\n+    class Impl;\n+    std::unique_ptr<Impl> m_impl;\n+\n+public:\n+    //! Construct a TxRequestTracker.\n+    TxRequestTracker(bool deterministic = false);\n+    ~TxRequestTracker();\n+\n+    // No copy constructors.\n+    TxRequestTracker(const TxRequestTracker&) = delete;\n+    TxRequestTracker& operator=(const TxRequestTracker&) = delete;\n+\n+    // Move constructors.\n+    TxRequestTracker(TxRequestTracker&&) = default;\n+    TxRequestTracker& operator=(TxRequestTracker&&) = default;\n+\n+    // Conceptually, the data structure consists of a collection of entries, one for each peer/txhash combination\n+    // (an \"announcement\"):\n+    //\n+    // - CANDIDATE entries represent transactions that were announced by a peer, and that become available for\n+    //   download after their reqtime has passed.\n+    //\n+    // - REQUESTED entries represent transactions that have been requested, and which we're awaiting a response for\n+    //   from that peer. Their exptime value determines when the request times out.\n+    //\n+    // - COMPLETED entries represent transactions that have been requested from a peer, but they timed out, a\n+    //   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to\n+    //   prevent requesting them again. If only COMPLETED entries for a given txhash remain (so no CANDIDATE or\n+    //   REQUESTED ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+    //\n+    // The operations below manipulate the data structure.\n+\n+    /** Deletes all entries for a given peer.\n+     *\n+     * It should be called when a peer goes offline.\n+     */\n+    void DeletedPeer(uint64_t uint64_t);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493166644",
      "id" : 493166644,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE2NjY0NA==",
      "original_commit_id" : "1b23bedf579aa615fa27a114da7cefbee756af6d",
      "original_line" : 156,
      "original_position" : 156,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 493984643,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-24T17:33:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493166644",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493168472"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493168472"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Isn't this exactly the same performance as having a subclass and making the methods virtual, except with all the dispatching written out explicitly? ie, could instead write something like:\r\n\r\n```c++\r\nclass TxRequestTracker\r\n{\r\nprotected:\r\n    TxRequestTracker() { } // pure virtual class, must instantiate via subclass\r\npublic:\r\n    virtual ~TxRequestTracker();\r\n    virtual void DeletedPeer(uint64_t peer) = 0;\r\n    ...\r\n};\r\nstd::unique_ptr<TxRequestTracker> CreateTxRequestTracker(bool deterministic = false);\r\n\r\nstatic std::unique_ptr<TxRequestTracker> g_txrequest = CreateTxRequestTracker() GUARDED_BY(cs_main);\r\n```\r\n\r\nthen hide the subclass in txrequest.cpp? Of course, \"exactly the same\" means no objective reason to prefer changing to this.",
      "commit_id" : "4508a6e58d28eb5436031861aca1a43b76156097",
      "created_at" : "2020-09-23T03:00:34Z",
      "diff_hunk" : "@@ -0,0 +1,220 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not (outbound and whitelisted peers are preferred).\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see further for details).\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"exptime\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing exptime, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the transaction was forgotten in\n+ *   between (see next point), and re-announced.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening invblock attacks. The flip side is that as long as an attacker manages to prevent\n+ *              us from receiving a transaction, failed announcements (including those from honest peers) will\n+ *              linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on\n+ *              the number of tracked announcements per peer.\n+ *\n+ * - Announcements are only forgotten about when the peer that announced them went offline, when the transaction\n+ *   was received successfully, or when no candidates for a transaction remain that haven't been tried already.\n+ *\n+ *   Rationale: we need to eventually forget announcements to keep memory bounded, but as long as viable\n+ *              candidate peers remain, we prefer to avoid fetching from failed ones. As every request has a finite\n+ *              timeout and we schedule new request as soon a previous one expired, there is always progress being\n+ *              made towards forgetting a transaction - either successfully or unsuccessfully.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable net_processing code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers (outbound, whitelisted) are chosen by us, so are less likely to be under attacker\n+ *                control.\n+ *\n+ *   - Among the remaining candidates, choose the one with the first marker if one exists (there can be at most\n+ *     one such peer, see further).\n+ *\n+ *     Rationale: in non-attack scenarios we want to give one chance to request from the fastest peer to reduce\n+ *                latency, and reduce risk of breaking chains of dependent transactions. An attacker who races the\n+ *                network can exploit this to delay us learning about a transaction, but it is available only once\n+ *                per txhash.\n+ *\n+ *   - If no remaining candidates have the first marker, pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: if the first mechanism failed, random assignments are hard to influence for attackers.\n+ *\n+ *   The overall effect of these rules is that an attacker that races announcements to us can delay\n+ *\n+ * \"First\" marker rules: the first marker is given to announcements for which at the time of announcement:\n+ * - No requests for its txhash have been attempted (ever, or since it was forgotten about).\n+ * - The peer that announced them was not overloaded.\n+ * - No announcement for the same txhash from another peer within the same preferred/nonpreferred class already has\n+ *   the first marker already.\n+ *\n+ *   Rationale: these restrictions avoid giving the speed benefit to honest but overloaded peers, and also\n+ *              reduce the impact an attacker who races the network for many transaction can have.\n+ *\n+ * Together these rules strike a balance between being fast in non-adverserial conditions and being influenceable by\n+ * attackers. An invblocking attacker that races the network:\n+ * - Will be unsuccessful if all preferred connections are honest (and there is at least one).\n+ * - If there are P preferred connections of which Ph>=1 are honest, the attacker can delay us from learning\n+ *   about a transaction by k expiration periods, where k ~ 1 + NHG(N=P-1,K=P-Ph-1,r=1), which has mean\n+ *   P/(Ph+1) (where NHG stands for Negative Hypergeometric distribution).\n+ * - If all P preferred connections are to the attacker, and there are NP non-preferred connections of which NPh are\n+ *   honest, k ~ P + 1 + NHG(N=NP-1,K=NP-NPh-1,r=1), with mean P + NP/(NPh+1).\n+ *\n+ * Complexity:\n+ * - Memory usage is proportional to the total number of tracked announcements (Size()) plus the number of\n+ *   peers with a nonzero number of tracked announcements.\n+ * - CPU usage is generally logarithmic in the total number of tracked announcements, plus the number of\n+ *   announcements affected by an operation (amortized O(1) per announcement).\n+ */\n+class TxRequestTracker {\n+public:\n+    /** A functor with embedded salt that computes priority of a txhash/peer combination. Lower priorities are\n+     *  selected first. */\n+    class PriorityComputer {\n+        const uint64_t m_k0, m_k1;\n+    public:\n+        explicit PriorityComputer(bool deterministic);\n+        uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred, bool first) const;\n+    };\n+\n+private:\n+    // Avoid littering this header file with implementation details.\n+    class Impl;\n+    std::unique_ptr<Impl> m_impl;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493168472",
      "id" : 493168472,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE2ODQ3Mg==",
      "original_commit_id" : "1b23bedf579aa615fa27a114da7cefbee756af6d",
      "original_line" : 122,
      "original_position" : 121,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 493984643,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-24T17:33:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493168472",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493169664"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493169664"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Are these needed for fuzz testing, or could they be deleted as well? (copy constructors are implicitly deleted because of the unique ptr, so I think currently this is just making the implicit defaults explicit)",
      "commit_id" : "4508a6e58d28eb5436031861aca1a43b76156097",
      "created_at" : "2020-09-23T03:05:34Z",
      "diff_hunk" : "@@ -0,0 +1,220 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not (outbound and whitelisted peers are preferred).\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see further for details).\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"exptime\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing exptime, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the transaction was forgotten in\n+ *   between (see next point), and re-announced.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening invblock attacks. The flip side is that as long as an attacker manages to prevent\n+ *              us from receiving a transaction, failed announcements (including those from honest peers) will\n+ *              linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on\n+ *              the number of tracked announcements per peer.\n+ *\n+ * - Announcements are only forgotten about when the peer that announced them went offline, when the transaction\n+ *   was received successfully, or when no candidates for a transaction remain that haven't been tried already.\n+ *\n+ *   Rationale: we need to eventually forget announcements to keep memory bounded, but as long as viable\n+ *              candidate peers remain, we prefer to avoid fetching from failed ones. As every request has a finite\n+ *              timeout and we schedule new request as soon a previous one expired, there is always progress being\n+ *              made towards forgetting a transaction - either successfully or unsuccessfully.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable net_processing code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers (outbound, whitelisted) are chosen by us, so are less likely to be under attacker\n+ *                control.\n+ *\n+ *   - Among the remaining candidates, choose the one with the first marker if one exists (there can be at most\n+ *     one such peer, see further).\n+ *\n+ *     Rationale: in non-attack scenarios we want to give one chance to request from the fastest peer to reduce\n+ *                latency, and reduce risk of breaking chains of dependent transactions. An attacker who races the\n+ *                network can exploit this to delay us learning about a transaction, but it is available only once\n+ *                per txhash.\n+ *\n+ *   - If no remaining candidates have the first marker, pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: if the first mechanism failed, random assignments are hard to influence for attackers.\n+ *\n+ *   The overall effect of these rules is that an attacker that races announcements to us can delay\n+ *\n+ * \"First\" marker rules: the first marker is given to announcements for which at the time of announcement:\n+ * - No requests for its txhash have been attempted (ever, or since it was forgotten about).\n+ * - The peer that announced them was not overloaded.\n+ * - No announcement for the same txhash from another peer within the same preferred/nonpreferred class already has\n+ *   the first marker already.\n+ *\n+ *   Rationale: these restrictions avoid giving the speed benefit to honest but overloaded peers, and also\n+ *              reduce the impact an attacker who races the network for many transaction can have.\n+ *\n+ * Together these rules strike a balance between being fast in non-adverserial conditions and being influenceable by\n+ * attackers. An invblocking attacker that races the network:\n+ * - Will be unsuccessful if all preferred connections are honest (and there is at least one).\n+ * - If there are P preferred connections of which Ph>=1 are honest, the attacker can delay us from learning\n+ *   about a transaction by k expiration periods, where k ~ 1 + NHG(N=P-1,K=P-Ph-1,r=1), which has mean\n+ *   P/(Ph+1) (where NHG stands for Negative Hypergeometric distribution).\n+ * - If all P preferred connections are to the attacker, and there are NP non-preferred connections of which NPh are\n+ *   honest, k ~ P + 1 + NHG(N=NP-1,K=NP-NPh-1,r=1), with mean P + NP/(NPh+1).\n+ *\n+ * Complexity:\n+ * - Memory usage is proportional to the total number of tracked announcements (Size()) plus the number of\n+ *   peers with a nonzero number of tracked announcements.\n+ * - CPU usage is generally logarithmic in the total number of tracked announcements, plus the number of\n+ *   announcements affected by an operation (amortized O(1) per announcement).\n+ */\n+class TxRequestTracker {\n+public:\n+    /** A functor with embedded salt that computes priority of a txhash/peer combination. Lower priorities are\n+     *  selected first. */\n+    class PriorityComputer {\n+        const uint64_t m_k0, m_k1;\n+    public:\n+        explicit PriorityComputer(bool deterministic);\n+        uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred, bool first) const;\n+    };\n+\n+private:\n+    // Avoid littering this header file with implementation details.\n+    class Impl;\n+    std::unique_ptr<Impl> m_impl;\n+\n+public:\n+    //! Construct a TxRequestTracker.\n+    TxRequestTracker(bool deterministic = false);\n+    ~TxRequestTracker();\n+\n+    // No copy constructors.\n+    TxRequestTracker(const TxRequestTracker&) = delete;\n+    TxRequestTracker& operator=(const TxRequestTracker&) = delete;\n+\n+    // Move constructors.\n+    TxRequestTracker(TxRequestTracker&&) = default;\n+    TxRequestTracker& operator=(TxRequestTracker&&) = default;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493169664",
      "id" : 493169664,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE2OTY2NA==",
      "original_commit_id" : "1b23bedf579aa615fa27a114da7cefbee756af6d",
      "original_line" : 134,
      "original_position" : 134,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 493984643,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-24T17:33:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493169664",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@sr-gi You may be interested in this.",
      "created_at" : "2020-09-23T03:06:40Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#issuecomment-697104797",
      "id" : 697104797,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19988",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY5NzEwNDc5Nw==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-09-23T03:06:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/697104797",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493172470"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493172470"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I'd like to keep txrequest mostly about the decision logic and data structure, while leaving net_processing responsible for the actual policy choices (\"what delays are given to which peers/requests\", \"what timeouts are used\", \"when exactly is a peer considered preferred\", \"when exactly is a peer considered overloaded\", \"how many announcements can be tracked per peer\").\r\n\r\nOf course, the explanation here is ideally as comprehensive as possible and not full of \"See some random comment in net_processing for the details\" references. Still, do you think it would be reasonable to say instead:\r\n\r\n> Whether it's from a \"preferred\" peer or not (what that means is up to the caller, but this is designed to correspond mostly to outbound peers, or others that are more trusted)\r\n\r\n?",
      "commit_id" : "4508a6e58d28eb5436031861aca1a43b76156097",
      "created_at" : "2020-09-23T03:17:11Z",
      "diff_hunk" : "@@ -0,0 +1,226 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not (outbound and whitelisted peers are preferred).",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493172470",
      "id" : 493172470,
      "in_reply_to_id" : 492832470,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE3MjQ3MA==",
      "original_commit_id" : "2cac00639e5eb22eb6b076bcc001196d958a4f2e",
      "original_line" : 28,
      "original_position" : 28,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 494000631,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-24T17:33:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493172470",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493177000"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493177000"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Does anything limit the size of the returned vector? I think the main constraints are those in net_processing.cpp:RequestTx which could leave as many as 100k entries in CANDIDATE state for a given peer, so this could be a 4MB vector, which seems like it might be larger than desirable?\r\n\r\nIt's also constrained by how many txs can be INVed by a peer inbetween calls to GetRequestable, so in normal circumstances I'd expect this to be perfectly fine. I think you could get the worst case by quickly sending two max-size INV messages and two max-size NOTFOUND messages once the first request comes in.\r\n\r\n(I think this has to return a copy of the data items, because you want to iterate over them and request them, which would then modify the data structure, and that would invalidate the iterator you were using if you hadn't made a copy)",
      "commit_id" : "4508a6e58d28eb5436031861aca1a43b76156097",
      "created_at" : "2020-09-23T03:35:42Z",
      "diff_hunk" : "@@ -0,0 +1,220 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not (outbound and whitelisted peers are preferred).\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see further for details).\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"exptime\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing exptime, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the transaction was forgotten in\n+ *   between (see next point), and re-announced.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening invblock attacks. The flip side is that as long as an attacker manages to prevent\n+ *              us from receiving a transaction, failed announcements (including those from honest peers) will\n+ *              linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on\n+ *              the number of tracked announcements per peer.\n+ *\n+ * - Announcements are only forgotten about when the peer that announced them went offline, when the transaction\n+ *   was received successfully, or when no candidates for a transaction remain that haven't been tried already.\n+ *\n+ *   Rationale: we need to eventually forget announcements to keep memory bounded, but as long as viable\n+ *              candidate peers remain, we prefer to avoid fetching from failed ones. As every request has a finite\n+ *              timeout and we schedule new request as soon a previous one expired, there is always progress being\n+ *              made towards forgetting a transaction - either successfully or unsuccessfully.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable net_processing code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers (outbound, whitelisted) are chosen by us, so are less likely to be under attacker\n+ *                control.\n+ *\n+ *   - Among the remaining candidates, choose the one with the first marker if one exists (there can be at most\n+ *     one such peer, see further).\n+ *\n+ *     Rationale: in non-attack scenarios we want to give one chance to request from the fastest peer to reduce\n+ *                latency, and reduce risk of breaking chains of dependent transactions. An attacker who races the\n+ *                network can exploit this to delay us learning about a transaction, but it is available only once\n+ *                per txhash.\n+ *\n+ *   - If no remaining candidates have the first marker, pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: if the first mechanism failed, random assignments are hard to influence for attackers.\n+ *\n+ *   The overall effect of these rules is that an attacker that races announcements to us can delay\n+ *\n+ * \"First\" marker rules: the first marker is given to announcements for which at the time of announcement:\n+ * - No requests for its txhash have been attempted (ever, or since it was forgotten about).\n+ * - The peer that announced them was not overloaded.\n+ * - No announcement for the same txhash from another peer within the same preferred/nonpreferred class already has\n+ *   the first marker already.\n+ *\n+ *   Rationale: these restrictions avoid giving the speed benefit to honest but overloaded peers, and also\n+ *              reduce the impact an attacker who races the network for many transaction can have.\n+ *\n+ * Together these rules strike a balance between being fast in non-adverserial conditions and being influenceable by\n+ * attackers. An invblocking attacker that races the network:\n+ * - Will be unsuccessful if all preferred connections are honest (and there is at least one).\n+ * - If there are P preferred connections of which Ph>=1 are honest, the attacker can delay us from learning\n+ *   about a transaction by k expiration periods, where k ~ 1 + NHG(N=P-1,K=P-Ph-1,r=1), which has mean\n+ *   P/(Ph+1) (where NHG stands for Negative Hypergeometric distribution).\n+ * - If all P preferred connections are to the attacker, and there are NP non-preferred connections of which NPh are\n+ *   honest, k ~ P + 1 + NHG(N=NP-1,K=NP-NPh-1,r=1), with mean P + NP/(NPh+1).\n+ *\n+ * Complexity:\n+ * - Memory usage is proportional to the total number of tracked announcements (Size()) plus the number of\n+ *   peers with a nonzero number of tracked announcements.\n+ * - CPU usage is generally logarithmic in the total number of tracked announcements, plus the number of\n+ *   announcements affected by an operation (amortized O(1) per announcement).\n+ */\n+class TxRequestTracker {\n+public:\n+    /** A functor with embedded salt that computes priority of a txhash/peer combination. Lower priorities are\n+     *  selected first. */\n+    class PriorityComputer {\n+        const uint64_t m_k0, m_k1;\n+    public:\n+        explicit PriorityComputer(bool deterministic);\n+        uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred, bool first) const;\n+    };\n+\n+private:\n+    // Avoid littering this header file with implementation details.\n+    class Impl;\n+    std::unique_ptr<Impl> m_impl;\n+\n+public:\n+    //! Construct a TxRequestTracker.\n+    TxRequestTracker(bool deterministic = false);\n+    ~TxRequestTracker();\n+\n+    // No copy constructors.\n+    TxRequestTracker(const TxRequestTracker&) = delete;\n+    TxRequestTracker& operator=(const TxRequestTracker&) = delete;\n+\n+    // Move constructors.\n+    TxRequestTracker(TxRequestTracker&&) = default;\n+    TxRequestTracker& operator=(TxRequestTracker&&) = default;\n+\n+    // Conceptually, the data structure consists of a collection of entries, one for each peer/txhash combination\n+    // (an \"announcement\"):\n+    //\n+    // - CANDIDATE entries represent transactions that were announced by a peer, and that become available for\n+    //   download after their reqtime has passed.\n+    //\n+    // - REQUESTED entries represent transactions that have been requested, and which we're awaiting a response for\n+    //   from that peer. Their exptime value determines when the request times out.\n+    //\n+    // - COMPLETED entries represent transactions that have been requested from a peer, but they timed out, a\n+    //   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to\n+    //   prevent requesting them again. If only COMPLETED entries for a given txhash remain (so no CANDIDATE or\n+    //   REQUESTED ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+    //\n+    // The operations below manipulate the data structure.\n+\n+    /** Deletes all entries for a given peer.\n+     *\n+     * It should be called when a peer goes offline.\n+     */\n+    void DeletedPeer(uint64_t uint64_t);\n+\n+    /** Deletes all entries for a given txhash.\n+     *\n+     * This should be called when a transaction is successfully added to the mempool, seen in a block, or for\n+     * whatever reason we no longer care about it. The is_wtxid flag of gtxid is ignored.\n+     */\n+    void ForgetTx(const GenTxid& gtxid);\n+\n+    /** Adds a new CANDIDATE entry.\n+     *\n+     * Does nothing if one already exists for that (txhash, peer) combination (whether it's CANDIDATE, REQUESTED, or\n+     * COMPLETED). Note that this means a second INV with the same txhash from the same peer will be ignored, even\n+     * if one is a txid and the other is wtxid (but that shouldn't happen, as BIP339 requires that all announced\n+     * inventory is exclusively using MSG_WTX). The new entry is given the specified preferred and reqtime values,\n+     * and takes it is_wtxid from the specified gtxid. It is eligible to get a first marker if overloaded is false\n+     * (but also subject to the other rules regarding the first marker).\n+     */\n+    void ReceivedInv(uint64_t peer, const GenTxid& gtxid, bool preferred, bool overloaded,\n+        std::chrono::microseconds reqtime);\n+\n+    /** Converts the CANDIDATE entry for the provided peer and gtxid into a REQUESTED one.\n+     *\n+     * Exptime is set to the specified value. This can ONLY be called immediately after GetRequestable was called\n+     * (for the same peer), with only ForgetTx and other RequestedTx calls (both for other txhashes) in\n+     * between. Any other non-const operation removes the ability to call RequestedTx.\n+     */\n+    void RequestedTx(uint64_t peer, const GenTxid& gtxid, std::chrono::microseconds exptime);\n+\n+    /** Converts any CANDIDATE or REQUESTED entry to a COMPLETED one, if one exists.\n+     *\n+     * It should be called whenever a transaction or NOTFOUND was received from a peer. When a good transaction is\n+     * received, ForgetTx should be called instead of (or in addition to) this operation.\n+     */\n+    void ReceivedResponse(uint64_t peer, const GenTxid& gtxid);\n+\n+    // The operations below inspect the data structure.\n+\n+    /** Find the txids to request now from peer.\n+     *\n+     * It does the following:\n+     *  - Convert all REQUESTED entries (for all txhashes/peers) with (exptime <= now) to COMPLETED entries.\n+     *  - Requestable entries are selected: CANDIDATE entries from the specified peer with (reqtime <= now) for\n+     *    which the specified peer is the best choice among all such CANDIDATE entries with the same txhash (subject\n+     *    to preference/first rules, and tiebreaking using a deterministic salted hash of peer and txhash).\n+     *  - The selected entries are sorted in order of announcement (even if multiple were added at the same time, or\n+     *    even when the clock went backwards while they were being added), converted to GenTxids using their\n+     *    is_wtxid flag, and returned.\n+     */\n+    std::vector<GenTxid> GetRequestable(uint64_t peer, std::chrono::microseconds now);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493177000",
      "id" : 493177000,
      "line" : 187,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE3NzAwMA==",
      "original_commit_id" : "1b23bedf579aa615fa27a114da7cefbee756af6d",
      "original_line" : 187,
      "original_position" : 205,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 187,
      "pull_request_review_id" : 493984643,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-24T17:33:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493177000",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493179243"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493179243"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "\"Run a check on consistency of request times after a call to GetRequestable (requires the same timestamp as was passed to GetRequestable)\" might be a better description? (At first glance I thought it might have been timing the sanity check, or doing a limited sanity check that checked different things depending on how much time it was taking to run)",
      "commit_id" : "4508a6e58d28eb5436031861aca1a43b76156097",
      "created_at" : "2020-09-23T03:44:42Z",
      "diff_hunk" : "@@ -215,6 +215,12 @@ class TxRequestTracker {\n \n     /** Access to the internal PriorityComputer (for testing) */\n     const PriorityComputer& GetPriorityComputer() const;\n+\n+    /** Run internal consistency check (test only). */\n+    void SanityCheck() const;\n+\n+    /** Run a time-dependent consistency check (can only be called immediately after GetRequestable; test only). */\n+    void TimeSanityCheck(std::chrono::microseconds now) const;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493179243",
      "id" : 493179243,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE3OTI0Mw==",
      "original_commit_id" : "c50b25c2c4c63e1cfea6428913f35926282f3fd8",
      "original_line" : 223,
      "original_position" : 9,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 493984643,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-24T17:33:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493179243",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493187263"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493187263"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Maybe this should be `overloaded == ... || g_txrequest.CountCandidates() >= 5000` or similar? I'm not sure I have a plausible enough scenario where this would be a benefit to justify the added code though.",
      "commit_id" : "4508a6e58d28eb5436031861aca1a43b76156097",
      "created_at" : "2020-09-23T04:18:11Z",
      "diff_hunk" : "@@ -793,69 +726,24 @@ static void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vec\n     }\n }\n \n-void EraseTxRequest(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    g_already_asked_for.erase(gtxid.GetHash());\n-}\n-\n-std::chrono::microseconds GetTxRequestTime(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it != g_already_asked_for.end()) {\n-        return it->second;\n-    }\n-    return {};\n-}\n-\n-void UpdateTxRequestTime(const GenTxid& gtxid, std::chrono::microseconds request_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it == g_already_asked_for.end()) {\n-        g_already_asked_for.insert(std::make_pair(gtxid.GetHash(), request_time));\n-    } else {\n-        g_already_asked_for.update(it, request_time);\n-    }\n-}\n-\n-std::chrono::microseconds CalculateTxGetDataTime(const GenTxid& gtxid, std::chrono::microseconds current_time, bool use_inbound_delay, bool use_txid_delay) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+void RequestTx(NodeId nodeid, const GenTxid& gtxid, std::chrono::microseconds current_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n-    std::chrono::microseconds process_time;\n-    const auto last_request_time = GetTxRequestTime(gtxid);\n-    // First time requesting this tx\n-    if (last_request_time.count() == 0) {\n-        process_time = current_time;\n-    } else {\n-        // Randomize the delay to avoid biasing some peers over others (such as due to\n-        // fixed ordering of peer processing in ThreadMessageHandler)\n-        process_time = last_request_time + GETDATA_TX_INTERVAL + GetRandMicros(MAX_GETDATA_RANDOM_DELAY);\n-    }\n-\n-    // We delay processing announcements from inbound peers\n-    if (use_inbound_delay) process_time += INBOUND_PEER_TX_DELAY;\n-\n-    // We delay processing announcements from peers that use txid-relay (instead of wtxid)\n-    if (use_txid_delay) process_time += TXID_RELAY_DELAY;\n-\n-    return process_time;\n-}\n-\n-void RequestTx(CNodeState* state, const GenTxid& gtxid, std::chrono::microseconds current_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    CNodeState::TxDownloadState& peer_download_state = state->m_tx_download;\n-    if (peer_download_state.m_tx_announced.size() >= MAX_PEER_TX_ANNOUNCEMENTS ||\n-            peer_download_state.m_tx_process_time.size() >= MAX_PEER_TX_ANNOUNCEMENTS ||\n-            peer_download_state.m_tx_announced.count(gtxid.GetHash())) {\n-        // Too many queued announcements from this peer, or we already have\n-        // this announcement\n+    if (g_txrequest.CountTracked(nodeid) >= MAX_PEER_TX_ANNOUNCEMENTS) {\n+        // Too many queued announcements from this peer\n         return;\n     }\n-    peer_download_state.m_tx_announced.insert(gtxid.GetHash());\n-\n-    // Calculate the time to try requesting this transaction. Use\n-    // fPreferredDownload as a proxy for outbound peers.\n-    const auto process_time = CalculateTxGetDataTime(gtxid, current_time, !state->fPreferredDownload, !state->m_wtxid_relay && g_wtxid_relay_peers > 0);\n-\n-    peer_download_state.m_tx_process_time.emplace(process_time, gtxid);\n+    auto state = State(nodeid);\n+    auto delay = std::chrono::microseconds{0};\n+    bool preferred = state->fPreferredDownload;\n+    bool overloaded = g_txrequest.CountInFlight(nodeid) >= MAX_PEER_TX_IN_FLIGHT;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493187263",
      "id" : 493187263,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE4NzI2Mw==",
      "original_commit_id" : "c7601cdb31f9c86a4308cf36bbbc9c74c1078f53",
      "original_line" : 747,
      "original_position" : 178,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : null,
      "pull_request_review_id" : 493984643,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-24T17:33:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493187263",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493190576"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493190576"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I think if you were to make `RequestTx()` a method of `class PeerManager`, you could make `g_txrequest` be a private member `PeerManager::m_txrequest GUARDED_BY(cs_main)` instead of a global. OTOH, might be better to not do that until other globals that `PeerManager` methods rely on (like `mapNodeState`) are also moved. cc @jnewbery",
      "commit_id" : "4508a6e58d28eb5436031861aca1a43b76156097",
      "created_at" : "2020-09-23T04:30:45Z",
      "diff_hunk" : "@@ -793,69 +726,24 @@ static void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vec\n     }\n }\n \n-void EraseTxRequest(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    g_already_asked_for.erase(gtxid.GetHash());\n-}\n-\n-std::chrono::microseconds GetTxRequestTime(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it != g_already_asked_for.end()) {\n-        return it->second;\n-    }\n-    return {};\n-}\n-\n-void UpdateTxRequestTime(const GenTxid& gtxid, std::chrono::microseconds request_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it == g_already_asked_for.end()) {\n-        g_already_asked_for.insert(std::make_pair(gtxid.GetHash(), request_time));\n-    } else {\n-        g_already_asked_for.update(it, request_time);\n-    }\n-}\n-\n-std::chrono::microseconds CalculateTxGetDataTime(const GenTxid& gtxid, std::chrono::microseconds current_time, bool use_inbound_delay, bool use_txid_delay) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+void RequestTx(NodeId nodeid, const GenTxid& gtxid, std::chrono::microseconds current_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n-    std::chrono::microseconds process_time;\n-    const auto last_request_time = GetTxRequestTime(gtxid);\n-    // First time requesting this tx\n-    if (last_request_time.count() == 0) {\n-        process_time = current_time;\n-    } else {\n-        // Randomize the delay to avoid biasing some peers over others (such as due to\n-        // fixed ordering of peer processing in ThreadMessageHandler)\n-        process_time = last_request_time + GETDATA_TX_INTERVAL + GetRandMicros(MAX_GETDATA_RANDOM_DELAY);\n-    }\n-\n-    // We delay processing announcements from inbound peers\n-    if (use_inbound_delay) process_time += INBOUND_PEER_TX_DELAY;\n-\n-    // We delay processing announcements from peers that use txid-relay (instead of wtxid)\n-    if (use_txid_delay) process_time += TXID_RELAY_DELAY;\n-\n-    return process_time;\n-}\n-\n-void RequestTx(CNodeState* state, const GenTxid& gtxid, std::chrono::microseconds current_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493190576",
      "id" : 493190576,
      "line" : 842,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE5MDU3Ng==",
      "original_commit_id" : "c7601cdb31f9c86a4308cf36bbbc9c74c1078f53",
      "original_line" : 842,
      "original_position" : 156,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 154,
      "pull_request_review_id" : 493984643,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "LEFT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-24T17:33:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493190576",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493198222"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493198222"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Should replace this test with one that checks we start applying `OVERLOAD_PEER_TX_DELAY` ?",
      "commit_id" : "4508a6e58d28eb5436031861aca1a43b76156097",
      "created_at" : "2020-09-23T05:00:55Z",
      "diff_hunk" : "@@ -121,38 +116,10 @@ def test_inv_block(self):\n         # * the first time it is re-requested from the outbound peer, plus\n         # * 2 seconds to avoid races\n         assert self.nodes[1].getpeerinfo()[0]['inbound'] == False\n-        timeout = 2 + (MAX_GETDATA_RANDOM_DELAY + INBOUND_PEER_TX_DELAY) + (\n-            GETDATA_TX_INTERVAL + MAX_GETDATA_RANDOM_DELAY)\n+        timeout = 2 + INBOUND_PEER_TX_DELAY + GETDATA_TX_INTERVAL\n         self.log.info(\"Tx should be received at node 1 after {} seconds\".format(timeout))\n         self.sync_mempools(timeout=timeout)\n \n-    def test_in_flight_max(self):",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493198222",
      "id" : 493198222,
      "line" : 129,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE5ODIyMg==",
      "original_commit_id" : "c7601cdb31f9c86a4308cf36bbbc9c74c1078f53",
      "original_line" : 129,
      "original_position" : 37,
      "original_start_line" : null,
      "path" : "test/functional/p2p_tx_download.py",
      "position" : 37,
      "pull_request_review_id" : 493984643,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "LEFT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-24T17:33:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493198222",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493830506"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493830506"
         }
      },
      "author_association" : "MEMBER",
      "body" : "@ajtowns Feel like writing such a test?",
      "commit_id" : "4508a6e58d28eb5436031861aca1a43b76156097",
      "created_at" : "2020-09-23T19:05:24Z",
      "diff_hunk" : "@@ -121,38 +116,10 @@ def test_inv_block(self):\n         # * the first time it is re-requested from the outbound peer, plus\n         # * 2 seconds to avoid races\n         assert self.nodes[1].getpeerinfo()[0]['inbound'] == False\n-        timeout = 2 + (MAX_GETDATA_RANDOM_DELAY + INBOUND_PEER_TX_DELAY) + (\n-            GETDATA_TX_INTERVAL + MAX_GETDATA_RANDOM_DELAY)\n+        timeout = 2 + INBOUND_PEER_TX_DELAY + GETDATA_TX_INTERVAL\n         self.log.info(\"Tx should be received at node 1 after {} seconds\".format(timeout))\n         self.sync_mempools(timeout=timeout)\n \n-    def test_in_flight_max(self):",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493830506",
      "id" : 493830506,
      "in_reply_to_id" : 493198222,
      "line" : 129,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzgzMDUwNg==",
      "original_commit_id" : "c7601cdb31f9c86a4308cf36bbbc9c74c1078f53",
      "original_line" : 129,
      "original_position" : 37,
      "original_start_line" : null,
      "path" : "test/functional/p2p_tx_download.py",
      "position" : 37,
      "pull_request_review_id" : 494965962,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "LEFT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-24T17:33:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493830506",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493966435"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493966435"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done, approximately.",
      "commit_id" : "4508a6e58d28eb5436031861aca1a43b76156097",
      "created_at" : "2020-09-24T00:10:18Z",
      "diff_hunk" : "@@ -0,0 +1,226 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not (outbound and whitelisted peers are preferred).",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493966435",
      "id" : 493966435,
      "in_reply_to_id" : 492832470,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk2NjQzNQ==",
      "original_commit_id" : "2cac00639e5eb22eb6b076bcc001196d958a4f2e",
      "original_line" : 28,
      "original_position" : 28,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 495137408,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-24T17:33:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493966435",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493966501"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493966501"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Changed to \"expiry\".",
      "commit_id" : "4508a6e58d28eb5436031861aca1a43b76156097",
      "created_at" : "2020-09-24T00:10:29Z",
      "diff_hunk" : "@@ -0,0 +1,220 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not (outbound and whitelisted peers are preferred).\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see further for details).\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"exptime\").",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493966501",
      "id" : 493966501,
      "in_reply_to_id" : 493158786,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk2NjUwMQ==",
      "original_commit_id" : "1b23bedf579aa615fa27a114da7cefbee756af6d",
      "original_line" : 30,
      "original_position" : 30,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 495137464,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-24T17:33:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493966501",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493966652"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493966652"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I was trying to refer to the specific section on the \"first\" marker. Made that more explicit.",
      "commit_id" : "4508a6e58d28eb5436031861aca1a43b76156097",
      "created_at" : "2020-09-24T00:10:57Z",
      "diff_hunk" : "@@ -0,0 +1,220 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not (outbound and whitelisted peers are preferred).\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see further for details).",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493966652",
      "id" : 493966652,
      "in_reply_to_id" : 493160848,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk2NjY1Mg==",
      "original_commit_id" : "1b23bedf579aa615fa27a114da7cefbee756af6d",
      "original_line" : 29,
      "original_position" : 29,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 495137619,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-24T17:33:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493966652",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493966692"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493966692"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "4508a6e58d28eb5436031861aca1a43b76156097",
      "created_at" : "2020-09-24T00:11:05Z",
      "diff_hunk" : "@@ -0,0 +1,220 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not (outbound and whitelisted peers are preferred).\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see further for details).\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"exptime\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing exptime, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the transaction was forgotten in\n+ *   between (see next point), and re-announced.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening invblock attacks. The flip side is that as long as an attacker manages to prevent\n+ *              us from receiving a transaction, failed announcements (including those from honest peers) will\n+ *              linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on\n+ *              the number of tracked announcements per peer.\n+ *\n+ * - Announcements are only forgotten about when the peer that announced them went offline, when the transaction\n+ *   was received successfully, or when no candidates for a transaction remain that haven't been tried already.\n+ *\n+ *   Rationale: we need to eventually forget announcements to keep memory bounded, but as long as viable\n+ *              candidate peers remain, we prefer to avoid fetching from failed ones. As every request has a finite\n+ *              timeout and we schedule new request as soon a previous one expired, there is always progress being\n+ *              made towards forgetting a transaction - either successfully or unsuccessfully.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable net_processing code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers (outbound, whitelisted) are chosen by us, so are less likely to be under attacker\n+ *                control.\n+ *\n+ *   - Among the remaining candidates, choose the one with the first marker if one exists (there can be at most",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493966692",
      "id" : 493966692,
      "in_reply_to_id" : 493161600,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk2NjY5Mg==",
      "original_commit_id" : "1b23bedf579aa615fa27a114da7cefbee756af6d",
      "original_line" : 69,
      "original_position" : 69,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 495137670,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-24T17:33:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493966692",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493966778"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493966778"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Removed. It was a leftover of what turned into the last comment section.",
      "commit_id" : "4508a6e58d28eb5436031861aca1a43b76156097",
      "created_at" : "2020-09-24T00:11:20Z",
      "diff_hunk" : "@@ -0,0 +1,220 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not (outbound and whitelisted peers are preferred).\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see further for details).\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"exptime\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing exptime, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the transaction was forgotten in\n+ *   between (see next point), and re-announced.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening invblock attacks. The flip side is that as long as an attacker manages to prevent\n+ *              us from receiving a transaction, failed announcements (including those from honest peers) will\n+ *              linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on\n+ *              the number of tracked announcements per peer.\n+ *\n+ * - Announcements are only forgotten about when the peer that announced them went offline, when the transaction\n+ *   was received successfully, or when no candidates for a transaction remain that haven't been tried already.\n+ *\n+ *   Rationale: we need to eventually forget announcements to keep memory bounded, but as long as viable\n+ *              candidate peers remain, we prefer to avoid fetching from failed ones. As every request has a finite\n+ *              timeout and we schedule new request as soon a previous one expired, there is always progress being\n+ *              made towards forgetting a transaction - either successfully or unsuccessfully.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable net_processing code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers (outbound, whitelisted) are chosen by us, so are less likely to be under attacker\n+ *                control.\n+ *\n+ *   - Among the remaining candidates, choose the one with the first marker if one exists (there can be at most\n+ *     one such peer, see further).\n+ *\n+ *     Rationale: in non-attack scenarios we want to give one chance to request from the fastest peer to reduce\n+ *                latency, and reduce risk of breaking chains of dependent transactions. An attacker who races the\n+ *                network can exploit this to delay us learning about a transaction, but it is available only once\n+ *                per txhash.\n+ *\n+ *   - If no remaining candidates have the first marker, pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: if the first mechanism failed, random assignments are hard to influence for attackers.\n+ *\n+ *   The overall effect of these rules is that an attacker that races announcements to us can delay",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493966778",
      "id" : 493966778,
      "in_reply_to_id" : 493162248,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk2Njc3OA==",
      "original_commit_id" : "1b23bedf579aa615fa27a114da7cefbee756af6d",
      "original_line" : 81,
      "original_position" : 81,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 495137767,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-24T17:33:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493966778",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493966818"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493966818"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "4508a6e58d28eb5436031861aca1a43b76156097",
      "created_at" : "2020-09-24T00:11:26Z",
      "diff_hunk" : "@@ -0,0 +1,220 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not (outbound and whitelisted peers are preferred).\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see further for details).\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"exptime\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing exptime, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the transaction was forgotten in\n+ *   between (see next point), and re-announced.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening invblock attacks. The flip side is that as long as an attacker manages to prevent\n+ *              us from receiving a transaction, failed announcements (including those from honest peers) will\n+ *              linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on\n+ *              the number of tracked announcements per peer.\n+ *\n+ * - Announcements are only forgotten about when the peer that announced them went offline, when the transaction\n+ *   was received successfully, or when no candidates for a transaction remain that haven't been tried already.\n+ *\n+ *   Rationale: we need to eventually forget announcements to keep memory bounded, but as long as viable\n+ *              candidate peers remain, we prefer to avoid fetching from failed ones. As every request has a finite\n+ *              timeout and we schedule new request as soon a previous one expired, there is always progress being\n+ *              made towards forgetting a transaction - either successfully or unsuccessfully.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable net_processing code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers (outbound, whitelisted) are chosen by us, so are less likely to be under attacker\n+ *                control.\n+ *\n+ *   - Among the remaining candidates, choose the one with the first marker if one exists (there can be at most\n+ *     one such peer, see further).\n+ *\n+ *     Rationale: in non-attack scenarios we want to give one chance to request from the fastest peer to reduce\n+ *                latency, and reduce risk of breaking chains of dependent transactions. An attacker who races the\n+ *                network can exploit this to delay us learning about a transaction, but it is available only once\n+ *                per txhash.\n+ *\n+ *   - If no remaining candidates have the first marker, pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: if the first mechanism failed, random assignments are hard to influence for attackers.\n+ *\n+ *   The overall effect of these rules is that an attacker that races announcements to us can delay\n+ *\n+ * \"First\" marker rules: the first marker is given to announcements for which at the time of announcement:\n+ * - No requests for its txhash have been attempted (ever, or since it was forgotten about).\n+ * - The peer that announced them was not overloaded.\n+ * - No announcement for the same txhash from another peer within the same preferred/nonpreferred class already has\n+ *   the first marker already.\n+ *\n+ *   Rationale: these restrictions avoid giving the speed benefit to honest but overloaded peers, and also\n+ *              reduce the impact an attacker who races the network for many transaction can have.\n+ *\n+ * Together these rules strike a balance between being fast in non-adverserial conditions and being influenceable by\n+ * attackers. An invblocking attacker that races the network:\n+ * - Will be unsuccessful if all preferred connections are honest (and there is at least one).\n+ * - If there are P preferred connections of which Ph>=1 are honest, the attacker can delay us from learning\n+ *   about a transaction by k expiration periods, where k ~ 1 + NHG(N=P-1,K=P-Ph-1,r=1), which has mean\n+ *   P/(Ph+1) (where NHG stands for Negative Hypergeometric distribution).\n+ * - If all P preferred connections are to the attacker, and there are NP non-preferred connections of which NPh are\n+ *   honest, k ~ P + 1 + NHG(N=NP-1,K=NP-NPh-1,r=1), with mean P + NP/(NPh+1).\n+ *\n+ * Complexity:\n+ * - Memory usage is proportional to the total number of tracked announcements (Size()) plus the number of\n+ *   peers with a nonzero number of tracked announcements.\n+ * - CPU usage is generally logarithmic in the total number of tracked announcements, plus the number of\n+ *   announcements affected by an operation (amortized O(1) per announcement).\n+ */",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493966818",
      "id" : 493966818,
      "in_reply_to_id" : 493163586,
      "line" : 107,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk2NjgxOA==",
      "original_commit_id" : "1b23bedf579aa615fa27a114da7cefbee756af6d",
      "original_line" : 107,
      "original_position" : 106,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 107,
      "pull_request_review_id" : 495137808,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-24T17:33:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493966818",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493966899"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493966899"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done, approximately.",
      "commit_id" : "4508a6e58d28eb5436031861aca1a43b76156097",
      "created_at" : "2020-09-24T00:11:41Z",
      "diff_hunk" : "@@ -0,0 +1,220 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not (outbound and whitelisted peers are preferred).\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see further for details).\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"exptime\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing exptime, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the transaction was forgotten in\n+ *   between (see next point), and re-announced.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening invblock attacks. The flip side is that as long as an attacker manages to prevent\n+ *              us from receiving a transaction, failed announcements (including those from honest peers) will\n+ *              linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on\n+ *              the number of tracked announcements per peer.\n+ *\n+ * - Announcements are only forgotten about when the peer that announced them went offline, when the transaction\n+ *   was received successfully, or when no candidates for a transaction remain that haven't been tried already.\n+ *\n+ *   Rationale: we need to eventually forget announcements to keep memory bounded, but as long as viable\n+ *              candidate peers remain, we prefer to avoid fetching from failed ones. As every request has a finite\n+ *              timeout and we schedule new request as soon a previous one expired, there is always progress being\n+ *              made towards forgetting a transaction - either successfully or unsuccessfully.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable net_processing code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers (outbound, whitelisted) are chosen by us, so are less likely to be under attacker\n+ *                control.\n+ *\n+ *   - Among the remaining candidates, choose the one with the first marker if one exists (there can be at most\n+ *     one such peer, see further).\n+ *\n+ *     Rationale: in non-attack scenarios we want to give one chance to request from the fastest peer to reduce\n+ *                latency, and reduce risk of breaking chains of dependent transactions. An attacker who races the\n+ *                network can exploit this to delay us learning about a transaction, but it is available only once\n+ *                per txhash.\n+ *\n+ *   - If no remaining candidates have the first marker, pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: if the first mechanism failed, random assignments are hard to influence for attackers.\n+ *\n+ *   The overall effect of these rules is that an attacker that races announcements to us can delay\n+ *\n+ * \"First\" marker rules: the first marker is given to announcements for which at the time of announcement:\n+ * - No requests for its txhash have been attempted (ever, or since it was forgotten about).\n+ * - The peer that announced them was not overloaded.\n+ * - No announcement for the same txhash from another peer within the same preferred/nonpreferred class already has\n+ *   the first marker already.\n+ *\n+ *   Rationale: these restrictions avoid giving the speed benefit to honest but overloaded peers, and also\n+ *              reduce the impact an attacker who races the network for many transaction can have.\n+ *\n+ * Together these rules strike a balance between being fast in non-adverserial conditions and being influenceable by",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493966899",
      "id" : 493966899,
      "in_reply_to_id" : 493163901,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk2Njg5OQ==",
      "original_commit_id" : "1b23bedf579aa615fa27a114da7cefbee756af6d",
      "original_line" : 92,
      "original_position" : 92,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 495137901,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-24T17:33:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493966899",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493967057"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493967057"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Apparently that's not actually a 128-bit type ;)\r\n\r\nFixed.",
      "commit_id" : "4508a6e58d28eb5436031861aca1a43b76156097",
      "created_at" : "2020-09-24T00:12:19Z",
      "diff_hunk" : "@@ -0,0 +1,220 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not (outbound and whitelisted peers are preferred).\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see further for details).\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"exptime\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing exptime, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the transaction was forgotten in\n+ *   between (see next point), and re-announced.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening invblock attacks. The flip side is that as long as an attacker manages to prevent\n+ *              us from receiving a transaction, failed announcements (including those from honest peers) will\n+ *              linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on\n+ *              the number of tracked announcements per peer.\n+ *\n+ * - Announcements are only forgotten about when the peer that announced them went offline, when the transaction\n+ *   was received successfully, or when no candidates for a transaction remain that haven't been tried already.\n+ *\n+ *   Rationale: we need to eventually forget announcements to keep memory bounded, but as long as viable\n+ *              candidate peers remain, we prefer to avoid fetching from failed ones. As every request has a finite\n+ *              timeout and we schedule new request as soon a previous one expired, there is always progress being\n+ *              made towards forgetting a transaction - either successfully or unsuccessfully.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable net_processing code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers (outbound, whitelisted) are chosen by us, so are less likely to be under attacker\n+ *                control.\n+ *\n+ *   - Among the remaining candidates, choose the one with the first marker if one exists (there can be at most\n+ *     one such peer, see further).\n+ *\n+ *     Rationale: in non-attack scenarios we want to give one chance to request from the fastest peer to reduce\n+ *                latency, and reduce risk of breaking chains of dependent transactions. An attacker who races the\n+ *                network can exploit this to delay us learning about a transaction, but it is available only once\n+ *                per txhash.\n+ *\n+ *   - If no remaining candidates have the first marker, pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: if the first mechanism failed, random assignments are hard to influence for attackers.\n+ *\n+ *   The overall effect of these rules is that an attacker that races announcements to us can delay\n+ *\n+ * \"First\" marker rules: the first marker is given to announcements for which at the time of announcement:\n+ * - No requests for its txhash have been attempted (ever, or since it was forgotten about).\n+ * - The peer that announced them was not overloaded.\n+ * - No announcement for the same txhash from another peer within the same preferred/nonpreferred class already has\n+ *   the first marker already.\n+ *\n+ *   Rationale: these restrictions avoid giving the speed benefit to honest but overloaded peers, and also\n+ *              reduce the impact an attacker who races the network for many transaction can have.\n+ *\n+ * Together these rules strike a balance between being fast in non-adverserial conditions and being influenceable by\n+ * attackers. An invblocking attacker that races the network:\n+ * - Will be unsuccessful if all preferred connections are honest (and there is at least one).\n+ * - If there are P preferred connections of which Ph>=1 are honest, the attacker can delay us from learning\n+ *   about a transaction by k expiration periods, where k ~ 1 + NHG(N=P-1,K=P-Ph-1,r=1), which has mean\n+ *   P/(Ph+1) (where NHG stands for Negative Hypergeometric distribution).\n+ * - If all P preferred connections are to the attacker, and there are NP non-preferred connections of which NPh are\n+ *   honest, k ~ P + 1 + NHG(N=NP-1,K=NP-NPh-1,r=1), with mean P + NP/(NPh+1).\n+ *\n+ * Complexity:\n+ * - Memory usage is proportional to the total number of tracked announcements (Size()) plus the number of\n+ *   peers with a nonzero number of tracked announcements.\n+ * - CPU usage is generally logarithmic in the total number of tracked announcements, plus the number of\n+ *   announcements affected by an operation (amortized O(1) per announcement).\n+ */\n+class TxRequestTracker {\n+public:\n+    /** A functor with embedded salt that computes priority of a txhash/peer combination. Lower priorities are\n+     *  selected first. */\n+    class PriorityComputer {\n+        const uint64_t m_k0, m_k1;\n+    public:\n+        explicit PriorityComputer(bool deterministic);\n+        uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred, bool first) const;\n+    };\n+\n+private:\n+    // Avoid littering this header file with implementation details.\n+    class Impl;\n+    std::unique_ptr<Impl> m_impl;\n+\n+public:\n+    //! Construct a TxRequestTracker.\n+    TxRequestTracker(bool deterministic = false);\n+    ~TxRequestTracker();\n+\n+    // No copy constructors.\n+    TxRequestTracker(const TxRequestTracker&) = delete;\n+    TxRequestTracker& operator=(const TxRequestTracker&) = delete;\n+\n+    // Move constructors.\n+    TxRequestTracker(TxRequestTracker&&) = default;\n+    TxRequestTracker& operator=(TxRequestTracker&&) = default;\n+\n+    // Conceptually, the data structure consists of a collection of entries, one for each peer/txhash combination\n+    // (an \"announcement\"):\n+    //\n+    // - CANDIDATE entries represent transactions that were announced by a peer, and that become available for\n+    //   download after their reqtime has passed.\n+    //\n+    // - REQUESTED entries represent transactions that have been requested, and which we're awaiting a response for\n+    //   from that peer. Their exptime value determines when the request times out.\n+    //\n+    // - COMPLETED entries represent transactions that have been requested from a peer, but they timed out, a\n+    //   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to\n+    //   prevent requesting them again. If only COMPLETED entries for a given txhash remain (so no CANDIDATE or\n+    //   REQUESTED ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+    //\n+    // The operations below manipulate the data structure.\n+\n+    /** Deletes all entries for a given peer.\n+     *\n+     * It should be called when a peer goes offline.\n+     */\n+    void DeletedPeer(uint64_t uint64_t);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493967057",
      "id" : 493967057,
      "in_reply_to_id" : 493166644,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk2NzA1Nw==",
      "original_commit_id" : "1b23bedf579aa615fa27a114da7cefbee756af6d",
      "original_line" : 156,
      "original_position" : 156,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 495138090,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-24T17:33:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493967057",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493968967"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493968967"
         }
      },
      "author_association" : "MEMBER",
      "body" : "It's not **exactly** the same, I think. Calling member functions on a `TxRequestTracker` would incur a lookup in the vtable to find the code to execute. The current solution has link-time determined code flow, and only an extra indirection to find the object's storage.\r\n\r\nI don't think either is remotely relevant for performance here, and the subclass approach you suggest is probably somewhat lighter syntactically. I'm happy to change it if other reviewers agree.",
      "commit_id" : "4508a6e58d28eb5436031861aca1a43b76156097",
      "created_at" : "2020-09-24T00:18:55Z",
      "diff_hunk" : "@@ -0,0 +1,220 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not (outbound and whitelisted peers are preferred).\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see further for details).\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"exptime\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing exptime, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the transaction was forgotten in\n+ *   between (see next point), and re-announced.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening invblock attacks. The flip side is that as long as an attacker manages to prevent\n+ *              us from receiving a transaction, failed announcements (including those from honest peers) will\n+ *              linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on\n+ *              the number of tracked announcements per peer.\n+ *\n+ * - Announcements are only forgotten about when the peer that announced them went offline, when the transaction\n+ *   was received successfully, or when no candidates for a transaction remain that haven't been tried already.\n+ *\n+ *   Rationale: we need to eventually forget announcements to keep memory bounded, but as long as viable\n+ *              candidate peers remain, we prefer to avoid fetching from failed ones. As every request has a finite\n+ *              timeout and we schedule new request as soon a previous one expired, there is always progress being\n+ *              made towards forgetting a transaction - either successfully or unsuccessfully.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable net_processing code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers (outbound, whitelisted) are chosen by us, so are less likely to be under attacker\n+ *                control.\n+ *\n+ *   - Among the remaining candidates, choose the one with the first marker if one exists (there can be at most\n+ *     one such peer, see further).\n+ *\n+ *     Rationale: in non-attack scenarios we want to give one chance to request from the fastest peer to reduce\n+ *                latency, and reduce risk of breaking chains of dependent transactions. An attacker who races the\n+ *                network can exploit this to delay us learning about a transaction, but it is available only once\n+ *                per txhash.\n+ *\n+ *   - If no remaining candidates have the first marker, pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: if the first mechanism failed, random assignments are hard to influence for attackers.\n+ *\n+ *   The overall effect of these rules is that an attacker that races announcements to us can delay\n+ *\n+ * \"First\" marker rules: the first marker is given to announcements for which at the time of announcement:\n+ * - No requests for its txhash have been attempted (ever, or since it was forgotten about).\n+ * - The peer that announced them was not overloaded.\n+ * - No announcement for the same txhash from another peer within the same preferred/nonpreferred class already has\n+ *   the first marker already.\n+ *\n+ *   Rationale: these restrictions avoid giving the speed benefit to honest but overloaded peers, and also\n+ *              reduce the impact an attacker who races the network for many transaction can have.\n+ *\n+ * Together these rules strike a balance between being fast in non-adverserial conditions and being influenceable by\n+ * attackers. An invblocking attacker that races the network:\n+ * - Will be unsuccessful if all preferred connections are honest (and there is at least one).\n+ * - If there are P preferred connections of which Ph>=1 are honest, the attacker can delay us from learning\n+ *   about a transaction by k expiration periods, where k ~ 1 + NHG(N=P-1,K=P-Ph-1,r=1), which has mean\n+ *   P/(Ph+1) (where NHG stands for Negative Hypergeometric distribution).\n+ * - If all P preferred connections are to the attacker, and there are NP non-preferred connections of which NPh are\n+ *   honest, k ~ P + 1 + NHG(N=NP-1,K=NP-NPh-1,r=1), with mean P + NP/(NPh+1).\n+ *\n+ * Complexity:\n+ * - Memory usage is proportional to the total number of tracked announcements (Size()) plus the number of\n+ *   peers with a nonzero number of tracked announcements.\n+ * - CPU usage is generally logarithmic in the total number of tracked announcements, plus the number of\n+ *   announcements affected by an operation (amortized O(1) per announcement).\n+ */\n+class TxRequestTracker {\n+public:\n+    /** A functor with embedded salt that computes priority of a txhash/peer combination. Lower priorities are\n+     *  selected first. */\n+    class PriorityComputer {\n+        const uint64_t m_k0, m_k1;\n+    public:\n+        explicit PriorityComputer(bool deterministic);\n+        uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred, bool first) const;\n+    };\n+\n+private:\n+    // Avoid littering this header file with implementation details.\n+    class Impl;\n+    std::unique_ptr<Impl> m_impl;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493968967",
      "id" : 493968967,
      "in_reply_to_id" : 493168472,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk2ODk2Nw==",
      "original_commit_id" : "1b23bedf579aa615fa27a114da7cefbee756af6d",
      "original_line" : 122,
      "original_position" : 121,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 495140122,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-24T17:33:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493968967",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493969150"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493969150"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Gone.",
      "commit_id" : "4508a6e58d28eb5436031861aca1a43b76156097",
      "created_at" : "2020-09-24T00:19:27Z",
      "diff_hunk" : "@@ -0,0 +1,220 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not (outbound and whitelisted peers are preferred).\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see further for details).\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"exptime\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing exptime, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the transaction was forgotten in\n+ *   between (see next point), and re-announced.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening invblock attacks. The flip side is that as long as an attacker manages to prevent\n+ *              us from receiving a transaction, failed announcements (including those from honest peers) will\n+ *              linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on\n+ *              the number of tracked announcements per peer.\n+ *\n+ * - Announcements are only forgotten about when the peer that announced them went offline, when the transaction\n+ *   was received successfully, or when no candidates for a transaction remain that haven't been tried already.\n+ *\n+ *   Rationale: we need to eventually forget announcements to keep memory bounded, but as long as viable\n+ *              candidate peers remain, we prefer to avoid fetching from failed ones. As every request has a finite\n+ *              timeout and we schedule new request as soon a previous one expired, there is always progress being\n+ *              made towards forgetting a transaction - either successfully or unsuccessfully.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable net_processing code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers (outbound, whitelisted) are chosen by us, so are less likely to be under attacker\n+ *                control.\n+ *\n+ *   - Among the remaining candidates, choose the one with the first marker if one exists (there can be at most\n+ *     one such peer, see further).\n+ *\n+ *     Rationale: in non-attack scenarios we want to give one chance to request from the fastest peer to reduce\n+ *                latency, and reduce risk of breaking chains of dependent transactions. An attacker who races the\n+ *                network can exploit this to delay us learning about a transaction, but it is available only once\n+ *                per txhash.\n+ *\n+ *   - If no remaining candidates have the first marker, pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: if the first mechanism failed, random assignments are hard to influence for attackers.\n+ *\n+ *   The overall effect of these rules is that an attacker that races announcements to us can delay\n+ *\n+ * \"First\" marker rules: the first marker is given to announcements for which at the time of announcement:\n+ * - No requests for its txhash have been attempted (ever, or since it was forgotten about).\n+ * - The peer that announced them was not overloaded.\n+ * - No announcement for the same txhash from another peer within the same preferred/nonpreferred class already has\n+ *   the first marker already.\n+ *\n+ *   Rationale: these restrictions avoid giving the speed benefit to honest but overloaded peers, and also\n+ *              reduce the impact an attacker who races the network for many transaction can have.\n+ *\n+ * Together these rules strike a balance between being fast in non-adverserial conditions and being influenceable by\n+ * attackers. An invblocking attacker that races the network:\n+ * - Will be unsuccessful if all preferred connections are honest (and there is at least one).\n+ * - If there are P preferred connections of which Ph>=1 are honest, the attacker can delay us from learning\n+ *   about a transaction by k expiration periods, where k ~ 1 + NHG(N=P-1,K=P-Ph-1,r=1), which has mean\n+ *   P/(Ph+1) (where NHG stands for Negative Hypergeometric distribution).\n+ * - If all P preferred connections are to the attacker, and there are NP non-preferred connections of which NPh are\n+ *   honest, k ~ P + 1 + NHG(N=NP-1,K=NP-NPh-1,r=1), with mean P + NP/(NPh+1).\n+ *\n+ * Complexity:\n+ * - Memory usage is proportional to the total number of tracked announcements (Size()) plus the number of\n+ *   peers with a nonzero number of tracked announcements.\n+ * - CPU usage is generally logarithmic in the total number of tracked announcements, plus the number of\n+ *   announcements affected by an operation (amortized O(1) per announcement).\n+ */\n+class TxRequestTracker {\n+public:\n+    /** A functor with embedded salt that computes priority of a txhash/peer combination. Lower priorities are\n+     *  selected first. */\n+    class PriorityComputer {\n+        const uint64_t m_k0, m_k1;\n+    public:\n+        explicit PriorityComputer(bool deterministic);\n+        uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred, bool first) const;\n+    };\n+\n+private:\n+    // Avoid littering this header file with implementation details.\n+    class Impl;\n+    std::unique_ptr<Impl> m_impl;\n+\n+public:\n+    //! Construct a TxRequestTracker.\n+    TxRequestTracker(bool deterministic = false);\n+    ~TxRequestTracker();\n+\n+    // No copy constructors.\n+    TxRequestTracker(const TxRequestTracker&) = delete;\n+    TxRequestTracker& operator=(const TxRequestTracker&) = delete;\n+\n+    // Move constructors.\n+    TxRequestTracker(TxRequestTracker&&) = default;\n+    TxRequestTracker& operator=(TxRequestTracker&&) = default;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493969150",
      "id" : 493969150,
      "in_reply_to_id" : 493169664,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk2OTE1MA==",
      "original_commit_id" : "1b23bedf579aa615fa27a114da7cefbee756af6d",
      "original_line" : 134,
      "original_position" : 134,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 495140308,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-24T17:33:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493969150",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493969647"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493969647"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I've added a commit that just reduces MAX_PEER_TX_ANNOUNCEMENTS; 100000 was ridiculous. It can be bypassed using the PF_RELAY permission.",
      "commit_id" : "4508a6e58d28eb5436031861aca1a43b76156097",
      "created_at" : "2020-09-24T00:21:04Z",
      "diff_hunk" : "@@ -0,0 +1,220 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not (outbound and whitelisted peers are preferred).\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see further for details).\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"exptime\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing exptime, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the transaction was forgotten in\n+ *   between (see next point), and re-announced.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening invblock attacks. The flip side is that as long as an attacker manages to prevent\n+ *              us from receiving a transaction, failed announcements (including those from honest peers) will\n+ *              linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on\n+ *              the number of tracked announcements per peer.\n+ *\n+ * - Announcements are only forgotten about when the peer that announced them went offline, when the transaction\n+ *   was received successfully, or when no candidates for a transaction remain that haven't been tried already.\n+ *\n+ *   Rationale: we need to eventually forget announcements to keep memory bounded, but as long as viable\n+ *              candidate peers remain, we prefer to avoid fetching from failed ones. As every request has a finite\n+ *              timeout and we schedule new request as soon a previous one expired, there is always progress being\n+ *              made towards forgetting a transaction - either successfully or unsuccessfully.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable net_processing code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers (outbound, whitelisted) are chosen by us, so are less likely to be under attacker\n+ *                control.\n+ *\n+ *   - Among the remaining candidates, choose the one with the first marker if one exists (there can be at most\n+ *     one such peer, see further).\n+ *\n+ *     Rationale: in non-attack scenarios we want to give one chance to request from the fastest peer to reduce\n+ *                latency, and reduce risk of breaking chains of dependent transactions. An attacker who races the\n+ *                network can exploit this to delay us learning about a transaction, but it is available only once\n+ *                per txhash.\n+ *\n+ *   - If no remaining candidates have the first marker, pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: if the first mechanism failed, random assignments are hard to influence for attackers.\n+ *\n+ *   The overall effect of these rules is that an attacker that races announcements to us can delay\n+ *\n+ * \"First\" marker rules: the first marker is given to announcements for which at the time of announcement:\n+ * - No requests for its txhash have been attempted (ever, or since it was forgotten about).\n+ * - The peer that announced them was not overloaded.\n+ * - No announcement for the same txhash from another peer within the same preferred/nonpreferred class already has\n+ *   the first marker already.\n+ *\n+ *   Rationale: these restrictions avoid giving the speed benefit to honest but overloaded peers, and also\n+ *              reduce the impact an attacker who races the network for many transaction can have.\n+ *\n+ * Together these rules strike a balance between being fast in non-adverserial conditions and being influenceable by\n+ * attackers. An invblocking attacker that races the network:\n+ * - Will be unsuccessful if all preferred connections are honest (and there is at least one).\n+ * - If there are P preferred connections of which Ph>=1 are honest, the attacker can delay us from learning\n+ *   about a transaction by k expiration periods, where k ~ 1 + NHG(N=P-1,K=P-Ph-1,r=1), which has mean\n+ *   P/(Ph+1) (where NHG stands for Negative Hypergeometric distribution).\n+ * - If all P preferred connections are to the attacker, and there are NP non-preferred connections of which NPh are\n+ *   honest, k ~ P + 1 + NHG(N=NP-1,K=NP-NPh-1,r=1), with mean P + NP/(NPh+1).\n+ *\n+ * Complexity:\n+ * - Memory usage is proportional to the total number of tracked announcements (Size()) plus the number of\n+ *   peers with a nonzero number of tracked announcements.\n+ * - CPU usage is generally logarithmic in the total number of tracked announcements, plus the number of\n+ *   announcements affected by an operation (amortized O(1) per announcement).\n+ */\n+class TxRequestTracker {\n+public:\n+    /** A functor with embedded salt that computes priority of a txhash/peer combination. Lower priorities are\n+     *  selected first. */\n+    class PriorityComputer {\n+        const uint64_t m_k0, m_k1;\n+    public:\n+        explicit PriorityComputer(bool deterministic);\n+        uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred, bool first) const;\n+    };\n+\n+private:\n+    // Avoid littering this header file with implementation details.\n+    class Impl;\n+    std::unique_ptr<Impl> m_impl;\n+\n+public:\n+    //! Construct a TxRequestTracker.\n+    TxRequestTracker(bool deterministic = false);\n+    ~TxRequestTracker();\n+\n+    // No copy constructors.\n+    TxRequestTracker(const TxRequestTracker&) = delete;\n+    TxRequestTracker& operator=(const TxRequestTracker&) = delete;\n+\n+    // Move constructors.\n+    TxRequestTracker(TxRequestTracker&&) = default;\n+    TxRequestTracker& operator=(TxRequestTracker&&) = default;\n+\n+    // Conceptually, the data structure consists of a collection of entries, one for each peer/txhash combination\n+    // (an \"announcement\"):\n+    //\n+    // - CANDIDATE entries represent transactions that were announced by a peer, and that become available for\n+    //   download after their reqtime has passed.\n+    //\n+    // - REQUESTED entries represent transactions that have been requested, and which we're awaiting a response for\n+    //   from that peer. Their exptime value determines when the request times out.\n+    //\n+    // - COMPLETED entries represent transactions that have been requested from a peer, but they timed out, a\n+    //   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to\n+    //   prevent requesting them again. If only COMPLETED entries for a given txhash remain (so no CANDIDATE or\n+    //   REQUESTED ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+    //\n+    // The operations below manipulate the data structure.\n+\n+    /** Deletes all entries for a given peer.\n+     *\n+     * It should be called when a peer goes offline.\n+     */\n+    void DeletedPeer(uint64_t uint64_t);\n+\n+    /** Deletes all entries for a given txhash.\n+     *\n+     * This should be called when a transaction is successfully added to the mempool, seen in a block, or for\n+     * whatever reason we no longer care about it. The is_wtxid flag of gtxid is ignored.\n+     */\n+    void ForgetTx(const GenTxid& gtxid);\n+\n+    /** Adds a new CANDIDATE entry.\n+     *\n+     * Does nothing if one already exists for that (txhash, peer) combination (whether it's CANDIDATE, REQUESTED, or\n+     * COMPLETED). Note that this means a second INV with the same txhash from the same peer will be ignored, even\n+     * if one is a txid and the other is wtxid (but that shouldn't happen, as BIP339 requires that all announced\n+     * inventory is exclusively using MSG_WTX). The new entry is given the specified preferred and reqtime values,\n+     * and takes it is_wtxid from the specified gtxid. It is eligible to get a first marker if overloaded is false\n+     * (but also subject to the other rules regarding the first marker).\n+     */\n+    void ReceivedInv(uint64_t peer, const GenTxid& gtxid, bool preferred, bool overloaded,\n+        std::chrono::microseconds reqtime);\n+\n+    /** Converts the CANDIDATE entry for the provided peer and gtxid into a REQUESTED one.\n+     *\n+     * Exptime is set to the specified value. This can ONLY be called immediately after GetRequestable was called\n+     * (for the same peer), with only ForgetTx and other RequestedTx calls (both for other txhashes) in\n+     * between. Any other non-const operation removes the ability to call RequestedTx.\n+     */\n+    void RequestedTx(uint64_t peer, const GenTxid& gtxid, std::chrono::microseconds exptime);\n+\n+    /** Converts any CANDIDATE or REQUESTED entry to a COMPLETED one, if one exists.\n+     *\n+     * It should be called whenever a transaction or NOTFOUND was received from a peer. When a good transaction is\n+     * received, ForgetTx should be called instead of (or in addition to) this operation.\n+     */\n+    void ReceivedResponse(uint64_t peer, const GenTxid& gtxid);\n+\n+    // The operations below inspect the data structure.\n+\n+    /** Find the txids to request now from peer.\n+     *\n+     * It does the following:\n+     *  - Convert all REQUESTED entries (for all txhashes/peers) with (exptime <= now) to COMPLETED entries.\n+     *  - Requestable entries are selected: CANDIDATE entries from the specified peer with (reqtime <= now) for\n+     *    which the specified peer is the best choice among all such CANDIDATE entries with the same txhash (subject\n+     *    to preference/first rules, and tiebreaking using a deterministic salted hash of peer and txhash).\n+     *  - The selected entries are sorted in order of announcement (even if multiple were added at the same time, or\n+     *    even when the clock went backwards while they were being added), converted to GenTxids using their\n+     *    is_wtxid flag, and returned.\n+     */\n+    std::vector<GenTxid> GetRequestable(uint64_t peer, std::chrono::microseconds now);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493969647",
      "id" : 493969647,
      "in_reply_to_id" : 493177000,
      "line" : 187,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk2OTY0Nw==",
      "original_commit_id" : "1b23bedf579aa615fa27a114da7cefbee756af6d",
      "original_line" : 187,
      "original_position" : 205,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 187,
      "pull_request_review_id" : 495140823,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-24T17:33:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493969647",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493970079"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493970079"
         }
      },
      "author_association" : "MEMBER",
      "body" : "With MAX_PEER_TX_ANNOUNCEMENTS reduced, is that still needed?\r\n\r\nI'm a bit hesitant about this, as the number of announcements tracked for a peer is somewhat dependent on other peers' behavior.",
      "commit_id" : "4508a6e58d28eb5436031861aca1a43b76156097",
      "created_at" : "2020-09-24T00:22:26Z",
      "diff_hunk" : "@@ -793,69 +726,24 @@ static void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vec\n     }\n }\n \n-void EraseTxRequest(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    g_already_asked_for.erase(gtxid.GetHash());\n-}\n-\n-std::chrono::microseconds GetTxRequestTime(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it != g_already_asked_for.end()) {\n-        return it->second;\n-    }\n-    return {};\n-}\n-\n-void UpdateTxRequestTime(const GenTxid& gtxid, std::chrono::microseconds request_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it == g_already_asked_for.end()) {\n-        g_already_asked_for.insert(std::make_pair(gtxid.GetHash(), request_time));\n-    } else {\n-        g_already_asked_for.update(it, request_time);\n-    }\n-}\n-\n-std::chrono::microseconds CalculateTxGetDataTime(const GenTxid& gtxid, std::chrono::microseconds current_time, bool use_inbound_delay, bool use_txid_delay) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+void RequestTx(NodeId nodeid, const GenTxid& gtxid, std::chrono::microseconds current_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n-    std::chrono::microseconds process_time;\n-    const auto last_request_time = GetTxRequestTime(gtxid);\n-    // First time requesting this tx\n-    if (last_request_time.count() == 0) {\n-        process_time = current_time;\n-    } else {\n-        // Randomize the delay to avoid biasing some peers over others (such as due to\n-        // fixed ordering of peer processing in ThreadMessageHandler)\n-        process_time = last_request_time + GETDATA_TX_INTERVAL + GetRandMicros(MAX_GETDATA_RANDOM_DELAY);\n-    }\n-\n-    // We delay processing announcements from inbound peers\n-    if (use_inbound_delay) process_time += INBOUND_PEER_TX_DELAY;\n-\n-    // We delay processing announcements from peers that use txid-relay (instead of wtxid)\n-    if (use_txid_delay) process_time += TXID_RELAY_DELAY;\n-\n-    return process_time;\n-}\n-\n-void RequestTx(CNodeState* state, const GenTxid& gtxid, std::chrono::microseconds current_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    CNodeState::TxDownloadState& peer_download_state = state->m_tx_download;\n-    if (peer_download_state.m_tx_announced.size() >= MAX_PEER_TX_ANNOUNCEMENTS ||\n-            peer_download_state.m_tx_process_time.size() >= MAX_PEER_TX_ANNOUNCEMENTS ||\n-            peer_download_state.m_tx_announced.count(gtxid.GetHash())) {\n-        // Too many queued announcements from this peer, or we already have\n-        // this announcement\n+    if (g_txrequest.CountTracked(nodeid) >= MAX_PEER_TX_ANNOUNCEMENTS) {\n+        // Too many queued announcements from this peer\n         return;\n     }\n-    peer_download_state.m_tx_announced.insert(gtxid.GetHash());\n-\n-    // Calculate the time to try requesting this transaction. Use\n-    // fPreferredDownload as a proxy for outbound peers.\n-    const auto process_time = CalculateTxGetDataTime(gtxid, current_time, !state->fPreferredDownload, !state->m_wtxid_relay && g_wtxid_relay_peers > 0);\n-\n-    peer_download_state.m_tx_process_time.emplace(process_time, gtxid);\n+    auto state = State(nodeid);\n+    auto delay = std::chrono::microseconds{0};\n+    bool preferred = state->fPreferredDownload;\n+    bool overloaded = g_txrequest.CountInFlight(nodeid) >= MAX_PEER_TX_IN_FLIGHT;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493970079",
      "id" : 493970079,
      "in_reply_to_id" : 493187263,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk3MDA3OQ==",
      "original_commit_id" : "c7601cdb31f9c86a4308cf36bbbc9c74c1078f53",
      "original_line" : 747,
      "original_position" : 178,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : null,
      "pull_request_review_id" : 495141294,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-24T17:33:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493970079",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493970217"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493970217"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Renamed to PostGetRequestableSanityCheck, and updated comment.\r\n\r\nIt's not just a consistency check of request times.",
      "commit_id" : "4508a6e58d28eb5436031861aca1a43b76156097",
      "created_at" : "2020-09-24T00:23:02Z",
      "diff_hunk" : "@@ -215,6 +215,12 @@ class TxRequestTracker {\n \n     /** Access to the internal PriorityComputer (for testing) */\n     const PriorityComputer& GetPriorityComputer() const;\n+\n+    /** Run internal consistency check (test only). */\n+    void SanityCheck() const;\n+\n+    /** Run a time-dependent consistency check (can only be called immediately after GetRequestable; test only). */\n+    void TimeSanityCheck(std::chrono::microseconds now) const;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493970217",
      "id" : 493970217,
      "in_reply_to_id" : 493179243,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk3MDIxNw==",
      "original_commit_id" : "c50b25c2c4c63e1cfea6428913f35926282f3fd8",
      "original_line" : 223,
      "original_position" : 9,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 495141467,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-24T17:33:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493970217",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493970343"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493970343"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I haven't paid too much attention to that, but I'm happy to change this if desirable.",
      "commit_id" : "4508a6e58d28eb5436031861aca1a43b76156097",
      "created_at" : "2020-09-24T00:23:31Z",
      "diff_hunk" : "@@ -793,69 +726,24 @@ static void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vec\n     }\n }\n \n-void EraseTxRequest(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    g_already_asked_for.erase(gtxid.GetHash());\n-}\n-\n-std::chrono::microseconds GetTxRequestTime(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it != g_already_asked_for.end()) {\n-        return it->second;\n-    }\n-    return {};\n-}\n-\n-void UpdateTxRequestTime(const GenTxid& gtxid, std::chrono::microseconds request_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it == g_already_asked_for.end()) {\n-        g_already_asked_for.insert(std::make_pair(gtxid.GetHash(), request_time));\n-    } else {\n-        g_already_asked_for.update(it, request_time);\n-    }\n-}\n-\n-std::chrono::microseconds CalculateTxGetDataTime(const GenTxid& gtxid, std::chrono::microseconds current_time, bool use_inbound_delay, bool use_txid_delay) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+void RequestTx(NodeId nodeid, const GenTxid& gtxid, std::chrono::microseconds current_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n-    std::chrono::microseconds process_time;\n-    const auto last_request_time = GetTxRequestTime(gtxid);\n-    // First time requesting this tx\n-    if (last_request_time.count() == 0) {\n-        process_time = current_time;\n-    } else {\n-        // Randomize the delay to avoid biasing some peers over others (such as due to\n-        // fixed ordering of peer processing in ThreadMessageHandler)\n-        process_time = last_request_time + GETDATA_TX_INTERVAL + GetRandMicros(MAX_GETDATA_RANDOM_DELAY);\n-    }\n-\n-    // We delay processing announcements from inbound peers\n-    if (use_inbound_delay) process_time += INBOUND_PEER_TX_DELAY;\n-\n-    // We delay processing announcements from peers that use txid-relay (instead of wtxid)\n-    if (use_txid_delay) process_time += TXID_RELAY_DELAY;\n-\n-    return process_time;\n-}\n-\n-void RequestTx(CNodeState* state, const GenTxid& gtxid, std::chrono::microseconds current_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r493970343",
      "id" : 493970343,
      "in_reply_to_id" : 493190576,
      "line" : 842,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk3MDM0Mw==",
      "original_commit_id" : "c7601cdb31f9c86a4308cf36bbbc9c74c1078f53",
      "original_line" : 842,
      "original_position" : 156,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 154,
      "pull_request_review_id" : 495141615,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "LEFT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-24T17:33:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/493970343",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494035871"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494035871"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Ah, good point! That seems a sufficient reason, so going to mark this as resolved.",
      "commit_id" : "4508a6e58d28eb5436031861aca1a43b76156097",
      "created_at" : "2020-09-24T04:46:23Z",
      "diff_hunk" : "@@ -0,0 +1,220 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not (outbound and whitelisted peers are preferred).\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see further for details).\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"exptime\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing exptime, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the transaction was forgotten in\n+ *   between (see next point), and re-announced.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening invblock attacks. The flip side is that as long as an attacker manages to prevent\n+ *              us from receiving a transaction, failed announcements (including those from honest peers) will\n+ *              linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on\n+ *              the number of tracked announcements per peer.\n+ *\n+ * - Announcements are only forgotten about when the peer that announced them went offline, when the transaction\n+ *   was received successfully, or when no candidates for a transaction remain that haven't been tried already.\n+ *\n+ *   Rationale: we need to eventually forget announcements to keep memory bounded, but as long as viable\n+ *              candidate peers remain, we prefer to avoid fetching from failed ones. As every request has a finite\n+ *              timeout and we schedule new request as soon a previous one expired, there is always progress being\n+ *              made towards forgetting a transaction - either successfully or unsuccessfully.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable net_processing code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers (outbound, whitelisted) are chosen by us, so are less likely to be under attacker\n+ *                control.\n+ *\n+ *   - Among the remaining candidates, choose the one with the first marker if one exists (there can be at most\n+ *     one such peer, see further).\n+ *\n+ *     Rationale: in non-attack scenarios we want to give one chance to request from the fastest peer to reduce\n+ *                latency, and reduce risk of breaking chains of dependent transactions. An attacker who races the\n+ *                network can exploit this to delay us learning about a transaction, but it is available only once\n+ *                per txhash.\n+ *\n+ *   - If no remaining candidates have the first marker, pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: if the first mechanism failed, random assignments are hard to influence for attackers.\n+ *\n+ *   The overall effect of these rules is that an attacker that races announcements to us can delay\n+ *\n+ * \"First\" marker rules: the first marker is given to announcements for which at the time of announcement:\n+ * - No requests for its txhash have been attempted (ever, or since it was forgotten about).\n+ * - The peer that announced them was not overloaded.\n+ * - No announcement for the same txhash from another peer within the same preferred/nonpreferred class already has\n+ *   the first marker already.\n+ *\n+ *   Rationale: these restrictions avoid giving the speed benefit to honest but overloaded peers, and also\n+ *              reduce the impact an attacker who races the network for many transaction can have.\n+ *\n+ * Together these rules strike a balance between being fast in non-adverserial conditions and being influenceable by\n+ * attackers. An invblocking attacker that races the network:\n+ * - Will be unsuccessful if all preferred connections are honest (and there is at least one).\n+ * - If there are P preferred connections of which Ph>=1 are honest, the attacker can delay us from learning\n+ *   about a transaction by k expiration periods, where k ~ 1 + NHG(N=P-1,K=P-Ph-1,r=1), which has mean\n+ *   P/(Ph+1) (where NHG stands for Negative Hypergeometric distribution).\n+ * - If all P preferred connections are to the attacker, and there are NP non-preferred connections of which NPh are\n+ *   honest, k ~ P + 1 + NHG(N=NP-1,K=NP-NPh-1,r=1), with mean P + NP/(NPh+1).\n+ *\n+ * Complexity:\n+ * - Memory usage is proportional to the total number of tracked announcements (Size()) plus the number of\n+ *   peers with a nonzero number of tracked announcements.\n+ * - CPU usage is generally logarithmic in the total number of tracked announcements, plus the number of\n+ *   announcements affected by an operation (amortized O(1) per announcement).\n+ */\n+class TxRequestTracker {\n+public:\n+    /** A functor with embedded salt that computes priority of a txhash/peer combination. Lower priorities are\n+     *  selected first. */\n+    class PriorityComputer {\n+        const uint64_t m_k0, m_k1;\n+    public:\n+        explicit PriorityComputer(bool deterministic);\n+        uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred, bool first) const;\n+    };\n+\n+private:\n+    // Avoid littering this header file with implementation details.\n+    class Impl;\n+    std::unique_ptr<Impl> m_impl;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494035871",
      "id" : 494035871,
      "in_reply_to_id" : 493168472,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDAzNTg3MQ==",
      "original_commit_id" : "1b23bedf579aa615fa27a114da7cefbee756af6d",
      "original_line" : 122,
      "original_position" : 121,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 495216030,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-24T17:33:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494035871",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494039908"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494039908"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Yeah, sounds good.",
      "commit_id" : "4508a6e58d28eb5436031861aca1a43b76156097",
      "created_at" : "2020-09-24T05:01:46Z",
      "diff_hunk" : "@@ -793,69 +726,24 @@ static void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vec\n     }\n }\n \n-void EraseTxRequest(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    g_already_asked_for.erase(gtxid.GetHash());\n-}\n-\n-std::chrono::microseconds GetTxRequestTime(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it != g_already_asked_for.end()) {\n-        return it->second;\n-    }\n-    return {};\n-}\n-\n-void UpdateTxRequestTime(const GenTxid& gtxid, std::chrono::microseconds request_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it == g_already_asked_for.end()) {\n-        g_already_asked_for.insert(std::make_pair(gtxid.GetHash(), request_time));\n-    } else {\n-        g_already_asked_for.update(it, request_time);\n-    }\n-}\n-\n-std::chrono::microseconds CalculateTxGetDataTime(const GenTxid& gtxid, std::chrono::microseconds current_time, bool use_inbound_delay, bool use_txid_delay) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+void RequestTx(NodeId nodeid, const GenTxid& gtxid, std::chrono::microseconds current_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n-    std::chrono::microseconds process_time;\n-    const auto last_request_time = GetTxRequestTime(gtxid);\n-    // First time requesting this tx\n-    if (last_request_time.count() == 0) {\n-        process_time = current_time;\n-    } else {\n-        // Randomize the delay to avoid biasing some peers over others (such as due to\n-        // fixed ordering of peer processing in ThreadMessageHandler)\n-        process_time = last_request_time + GETDATA_TX_INTERVAL + GetRandMicros(MAX_GETDATA_RANDOM_DELAY);\n-    }\n-\n-    // We delay processing announcements from inbound peers\n-    if (use_inbound_delay) process_time += INBOUND_PEER_TX_DELAY;\n-\n-    // We delay processing announcements from peers that use txid-relay (instead of wtxid)\n-    if (use_txid_delay) process_time += TXID_RELAY_DELAY;\n-\n-    return process_time;\n-}\n-\n-void RequestTx(CNodeState* state, const GenTxid& gtxid, std::chrono::microseconds current_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    CNodeState::TxDownloadState& peer_download_state = state->m_tx_download;\n-    if (peer_download_state.m_tx_announced.size() >= MAX_PEER_TX_ANNOUNCEMENTS ||\n-            peer_download_state.m_tx_process_time.size() >= MAX_PEER_TX_ANNOUNCEMENTS ||\n-            peer_download_state.m_tx_announced.count(gtxid.GetHash())) {\n-        // Too many queued announcements from this peer, or we already have\n-        // this announcement\n+    if (g_txrequest.CountTracked(nodeid) >= MAX_PEER_TX_ANNOUNCEMENTS) {\n+        // Too many queued announcements from this peer\n         return;\n     }\n-    peer_download_state.m_tx_announced.insert(gtxid.GetHash());\n-\n-    // Calculate the time to try requesting this transaction. Use\n-    // fPreferredDownload as a proxy for outbound peers.\n-    const auto process_time = CalculateTxGetDataTime(gtxid, current_time, !state->fPreferredDownload, !state->m_wtxid_relay && g_wtxid_relay_peers > 0);\n-\n-    peer_download_state.m_tx_process_time.emplace(process_time, gtxid);\n+    auto state = State(nodeid);\n+    auto delay = std::chrono::microseconds{0};\n+    bool preferred = state->fPreferredDownload;\n+    bool overloaded = g_txrequest.CountInFlight(nodeid) >= MAX_PEER_TX_IN_FLIGHT;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494039908",
      "id" : 494039908,
      "in_reply_to_id" : 493187263,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDAzOTkwOA==",
      "original_commit_id" : "c7601cdb31f9c86a4308cf36bbbc9c74c1078f53",
      "original_line" : 747,
      "original_position" : 178,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : null,
      "pull_request_review_id" : 495220833,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-24T17:33:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494039908",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494041957"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494041957"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Not sure I follow, the only asserts are comparisons between `entry.m_time` and `now` ? Or should I have said \"entry times\" because \"request\" times might only mean REQUESTED entries?",
      "commit_id" : "4508a6e58d28eb5436031861aca1a43b76156097",
      "created_at" : "2020-09-24T05:09:51Z",
      "diff_hunk" : "@@ -215,6 +215,12 @@ class TxRequestTracker {\n \n     /** Access to the internal PriorityComputer (for testing) */\n     const PriorityComputer& GetPriorityComputer() const;\n+\n+    /** Run internal consistency check (test only). */\n+    void SanityCheck() const;\n+\n+    /** Run a time-dependent consistency check (can only be called immediately after GetRequestable; test only). */\n+    void TimeSanityCheck(std::chrono::microseconds now) const;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494041957",
      "id" : 494041957,
      "in_reply_to_id" : 493179243,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDA0MTk1Nw==",
      "original_commit_id" : "c50b25c2c4c63e1cfea6428913f35926282f3fd8",
      "original_line" : 223,
      "original_position" : 9,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 495223339,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-24T17:33:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494041957",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494043594"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494043594"
         }
      },
      "author_association" : "MEMBER",
      "body" : "m_time is the reqtime for CANDIDATE_*, but expiry for REQUESTED entries.",
      "commit_id" : "4508a6e58d28eb5436031861aca1a43b76156097",
      "created_at" : "2020-09-24T05:16:04Z",
      "diff_hunk" : "@@ -215,6 +215,12 @@ class TxRequestTracker {\n \n     /** Access to the internal PriorityComputer (for testing) */\n     const PriorityComputer& GetPriorityComputer() const;\n+\n+    /** Run internal consistency check (test only). */\n+    void SanityCheck() const;\n+\n+    /** Run a time-dependent consistency check (can only be called immediately after GetRequestable; test only). */\n+    void TimeSanityCheck(std::chrono::microseconds now) const;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494043594",
      "id" : 494043594,
      "in_reply_to_id" : 493179243,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDA0MzU5NA==",
      "original_commit_id" : "c50b25c2c4c63e1cfea6428913f35926282f3fd8",
      "original_line" : 223,
      "original_position" : 9,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 495225257,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-24T17:33:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494043594",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494242666"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494242666"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Yes, I think this would be an improvement for encapsulation and for being explicit about when the TxRequestManager is constructed/destructed. It's my understanding that global static objects can be constructed before main() or later.\r\n\r\nThere isn't any requirement to wait for `mapNodeState` to move to `PeerManager`.\r\n\r\nI have a branch that moves TxRequestTracker and RequestTx() to be members of PeerManager here: https://github.com/jnewbery/bitcoin/tree/pr19988.1. The move is in a separate commit in that branch for ease of review, but should be squashed into _Change transaction request logic to use txrequest_.",
      "commit_id" : "4508a6e58d28eb5436031861aca1a43b76156097",
      "created_at" : "2020-09-24T11:36:53Z",
      "diff_hunk" : "@@ -793,69 +726,24 @@ static void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vec\n     }\n }\n \n-void EraseTxRequest(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    g_already_asked_for.erase(gtxid.GetHash());\n-}\n-\n-std::chrono::microseconds GetTxRequestTime(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it != g_already_asked_for.end()) {\n-        return it->second;\n-    }\n-    return {};\n-}\n-\n-void UpdateTxRequestTime(const GenTxid& gtxid, std::chrono::microseconds request_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it == g_already_asked_for.end()) {\n-        g_already_asked_for.insert(std::make_pair(gtxid.GetHash(), request_time));\n-    } else {\n-        g_already_asked_for.update(it, request_time);\n-    }\n-}\n-\n-std::chrono::microseconds CalculateTxGetDataTime(const GenTxid& gtxid, std::chrono::microseconds current_time, bool use_inbound_delay, bool use_txid_delay) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+void RequestTx(NodeId nodeid, const GenTxid& gtxid, std::chrono::microseconds current_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n-    std::chrono::microseconds process_time;\n-    const auto last_request_time = GetTxRequestTime(gtxid);\n-    // First time requesting this tx\n-    if (last_request_time.count() == 0) {\n-        process_time = current_time;\n-    } else {\n-        // Randomize the delay to avoid biasing some peers over others (such as due to\n-        // fixed ordering of peer processing in ThreadMessageHandler)\n-        process_time = last_request_time + GETDATA_TX_INTERVAL + GetRandMicros(MAX_GETDATA_RANDOM_DELAY);\n-    }\n-\n-    // We delay processing announcements from inbound peers\n-    if (use_inbound_delay) process_time += INBOUND_PEER_TX_DELAY;\n-\n-    // We delay processing announcements from peers that use txid-relay (instead of wtxid)\n-    if (use_txid_delay) process_time += TXID_RELAY_DELAY;\n-\n-    return process_time;\n-}\n-\n-void RequestTx(CNodeState* state, const GenTxid& gtxid, std::chrono::microseconds current_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494242666",
      "id" : 494242666,
      "in_reply_to_id" : 493190576,
      "line" : 842,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDI0MjY2Ng==",
      "original_commit_id" : "c7601cdb31f9c86a4308cf36bbbc9c74c1078f53",
      "original_line" : 842,
      "original_position" : 156,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 154,
      "pull_request_review_id" : 495477045,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "LEFT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-24T17:33:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494242666",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494257310"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494257310"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Consider using the `default` syntax to indicate that you only included this in the cpp file so the `m_impl` unique ptr can be destructed:\r\n\r\n```suggestion\r\nTxRequestTracker::~TxRequestTracker() = default;\r\n```",
      "commit_id" : "4508a6e58d28eb5436031861aca1a43b76156097",
      "created_at" : "2020-09-24T12:00:49Z",
      "diff_hunk" : "@@ -0,0 +1,715 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+TxRequestTracker::PriorityComputer::PriorityComputer(bool deterministic) :\n+    m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+    m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+uint64_t TxRequestTracker::PriorityComputer::operator()(const uint256& txhash, uint64_t peer, bool preferred, bool first) const\n+{\n+    uint64_t low_bits = 0;\n+    if (!first) {\n+        low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+    }\n+    return low_bits | uint64_t{!preferred} << 63;\n+}\n+\n+static const uint256 UINT256_ZERO;\n+\n+/** Actual implementation for TxRequestTracker's data structure. */\n+class TxRequestTracker::Impl {\n+    //! The various states a (txid,node) pair can be in.\n+    //! Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient\n+    //! implementation. Also note that the sorting order of EntryTxHash relies on the specific order of values in\n+    //! this enum.\n+    enum class State : uint8_t {\n+        //! A CANDIDATE entry whose reqtime is in the future.\n+        CANDIDATE_DELAYED,\n+        //! The best CANDIDATE for a given txid; only if there is no REQUESTED entry already for that txid.\n+        //! The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txid.\n+        CANDIDATE_BEST,\n+        //! A REQUESTED entry.\n+        REQUESTED,\n+        //! A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST.\n+        CANDIDATE_READY,\n+        //! A COMPLETED entry.\n+        COMPLETED,\n+\n+        //! An invalid State value that's larger than all valid ones.\n+        TOO_LARGE,\n+    };\n+\n+    /** A flag (in Entry::m_per_txhash) to indicate that for that txhash,\n+     *  new preferred announcements are not eligible to get the 'first' marker. */\n+    static constexpr uint8_t TXHASHINFO_NO_MORE_PREFERRED_FIRST = 1;\n+    /** A flag (in Entry::m_per_txhash) to indicate that for that txhash,\n+     *  new non-preferred announcements are not eligible to get the 'first' marker. */\n+    static constexpr uint8_t TXHASHINFO_NO_MORE_NONPREFERRED_FIRST = 2;\n+\n+    //! Tag for the EntryPeer-based index.\n+    struct ByPeer {};\n+    //! Tag for the EntryTxHash-based index.\n+    struct ByTxHash {};\n+    //! Tag for the EntryTime-based index.\n+    struct ByTime {};\n+\n+    //! The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txid)\n+    using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+\n+    //! The ByTxHash index is sorted by (txhash, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+    using EntryTxHash = std::tuple<const uint256&, State, uint64_t>;\n+\n+    //! The ByTime index is sorted by (0 [CANDIDATE_DELAYED,REQUESTED]; 1 [COMPLETED];\n+    // 2 [CANDIDATE_READY,CANDIDATE_BEST], time)\n+    using EntryTime = std::pair<int, std::chrono::microseconds>;\n+\n+    //! The current sequence number. Increases for every announcement. This is used to sort txids returned by\n+    //! GetRequestable in announcement order.\n+    uint64_t m_sequence{0};\n+\n+    //! An announcement entry.\n+    struct Entry {\n+        //! Txid that was announced.\n+        const uint256 m_txhash;\n+        //! For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry\n+        std::chrono::microseconds m_time;\n+        //! What peer the request was from.\n+        const uint64_t m_peer;\n+        //! What sequence number this announcement has.\n+        const uint64_t m_sequence : 56;\n+        //! Whether the request is preferred (giving it priority higher than non-preferred ones).\n+        const bool m_preferred : 1;\n+        //! Whether this is a wtxid request.\n+        const bool m_is_wtxid : 1;\n+        //! Whether this was: the very first announcement for this txhash, within the\n+        //! preferred or non-preferred ones, and no request had been made for this\n+        //! txhash from any peer at the time the announcement came in.\n+        const bool m_first : 1;\n+\n+        //! What state this announcement is in\n+        //! This is a uint8_t instead of a State to silence a GCC warning.\n+        uint8_t m_state : 3;\n+\n+        /** Per-txhash flags. These are stored in the last Entry for a given txhash (ByTxHash order).\n+         *  The values for other Entry objects can be arbitrary subsets of the actual flags. */\n+        mutable uint8_t m_per_txhash : 2;\n+\n+        //! Convert the m_state variable to a State enum.\n+        State GetState() const { return State(m_state); }\n+        //! Convert a State to a uint8_t and store it in m_state.\n+        void SetState(State state) { m_state = uint8_t(state); }\n+\n+        //! Whether this entry is selected. There can be at most 1 selected peer per txhash.\n+        bool IsSelected() const\n+        {\n+            return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+        }\n+\n+        //! Whether this entry is waiting for a certain time to pass.\n+        bool IsWaiting() const\n+        {\n+            return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+        }\n+\n+        //! Whether this entry can feasibly be selected if the current IsSelected() one disappears.\n+        bool IsSelectable() const\n+        {\n+            return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+        }\n+\n+        //! Construct a new entry from scratch, initially in CANDIDATE_DELAYED state.\n+        Entry(const GenTxid& gtxid, uint64_t peer, bool preferred, std::chrono::microseconds reqtime,\n+            uint64_t sequence, bool first) :\n+            m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+            m_is_wtxid(gtxid.IsWtxid()), m_first(first), m_state(uint8_t(State::CANDIDATE_DELAYED)),\n+            m_per_txhash(0) {}\n+\n+        //! Compute this Entry's priority.\n+        uint64_t ComputePriority(const PriorityComputer& computer) const\n+        {\n+            return computer(m_txhash, m_peer, m_preferred, m_first);\n+        }\n+\n+        //! Extract the EntryPeer from this Entry.\n+        EntryPeer ExtractPeer() const { return EntryPeer{m_peer, GetState() == State::CANDIDATE_BEST, m_txhash}; }\n+\n+        //! Extract the EntryTxHash from this Entry.\n+        EntryTxHash ExtractTxid(const PriorityComputer& computer) const\n+        {\n+            return EntryTxHash{\n+                m_txhash,\n+                GetState(),\n+                GetState() == State::CANDIDATE_READY ? ComputePriority(computer) : 0\n+            };\n+        }\n+\n+        //! Extract the EntryTime from this Entry.\n+        EntryTime ExtractTime() const { return EntryTime{IsWaiting() ? 0 : IsSelectable() ? 2 : 1, m_time}; }\n+    };\n+\n+    //! This tracker's priority computer.\n+    const PriorityComputer m_computer;\n+\n+    /** An extractor for EntryTxHash (with encapsulated PriorityComputer reference).\n+     *\n+     * See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+     * for more information about the key extraction concept.\n+     */\n+    class EntryTxHashExtractor {\n+        const PriorityComputer& m_computer;\n+    public:\n+        EntryTxHashExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+        using result_type = EntryTxHash; // Needed to comply with key extractor interface\n+        result_type operator()(const Entry& entry) const { return entry.ExtractTxid(m_computer); }\n+    };\n+\n+    //! Data type for the main data structure (Entry objects with ByPeer/ByTxHash/ByTime indexes).\n+    using Index = boost::multi_index_container<\n+        Entry,\n+        boost::multi_index::indexed_by<\n+            boost::multi_index::ordered_unique<\n+                boost::multi_index::tag<ByPeer>,\n+                boost::multi_index::const_mem_fun<Entry, EntryPeer, &Entry::ExtractPeer>\n+            >,\n+            boost::multi_index::ordered_non_unique<\n+                boost::multi_index::tag<ByTxHash>,\n+                EntryTxHashExtractor\n+            >,\n+            boost::multi_index::ordered_non_unique<\n+                boost::multi_index::tag<ByTime>,\n+                boost::multi_index::const_mem_fun<Entry, EntryTime, &Entry::ExtractTime>\n+            >\n+        >\n+    >;\n+\n+    //! This tracker's main data structure.\n+    Index m_index;\n+\n+    //! Per-peer statistics object.\n+    struct PeerInfo {\n+        size_t m_total = 0; //!< Total number of entries for this peer.\n+        size_t m_requested = 0; //!< Total number of REQUESTED entries for this peer.\n+\n+        friend bool operator==(const PeerInfo& a, const PeerInfo& b)\n+        {\n+            return std::tie(a.m_total, a.m_requested) == std::tie(b.m_total, b.m_requested);\n+        }\n+    };\n+\n+    //! Map with this tracker's per-peer statistics.\n+    std::unordered_map<uint64_t, PeerInfo> m_peerinfo;\n+\n+    //! Wrapper around Index::...::erase that keeps m_peerinfo and m_per_txhash up to date.\n+    template<typename Tag>\n+    typename Index::index<Tag>::type::iterator Erase(typename Index::index<Tag>::type::iterator it)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        if (--peerit->second.m_total == 0) m_peerinfo.erase(peerit);\n+        // As it may possibly be the last-sorted Entry for a given txhash, propagate its per-txhash flags to its\n+        // predecessor (if it belongs to the same txhash).\n+        auto bytxhashit = m_index.project<ByTxHash>(it);\n+        if (bytxhashit != m_index.get<ByTxHash>().begin() &&\n+            bytxhashit->m_txhash == std::prev(bytxhashit)->m_txhash) {\n+            std::prev(bytxhashit)->m_per_txhash |= bytxhashit->m_per_txhash;\n+        }\n+        return m_index.get<Tag>().erase(it);\n+    }\n+\n+\n+    //! Wrapper around Index::...::modify that keeps m_peerinfo and m_per_txhash up to date.\n+    template<typename Tag, typename Modifier>\n+    void Modify(typename Index::index<Tag>::type::iterator it, Modifier modifier)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        // It's possible that it used to be the last-sorted Entry for its txhash, so propagate its\n+        // flags to its predecessor (which would then become the new last-sorted Entry).\n+        auto bytxhashit = m_index.project<ByTxHash>(it);\n+        if (bytxhashit != m_index.get<ByTxHash>().begin() &&\n+            bytxhashit->m_txhash == std::prev(bytxhashit)->m_txhash) {\n+            std::prev(bytxhashit)->m_per_txhash |= bytxhashit->m_per_txhash;\n+        }\n+        m_index.get<Tag>().modify(it, std::move(modifier));\n+        // It's possible that it is now the new last-sorted Entry for its txhash, so propagate flags\n+        // from its predecessor to it.\n+        bytxhashit = m_index.project<ByTxHash>(it);\n+        if (bytxhashit != m_index.get<ByTxHash>().begin() &&\n+            bytxhashit->m_txhash == std::prev(bytxhashit)->m_txhash) {\n+            bytxhashit->m_per_txhash |= std::prev(bytxhashit)->m_per_txhash;\n+        }\n+        peerit->second.m_requested += it->GetState() == State::REQUESTED;\n+    }\n+\n+\n+    //! Convert a CANDIDATE_DELAYED entry into a CANDIDATE_READY. If this makes it the new best CANDIDATE_READY\n+    //! (and no REQUESTED exists) and better than the CANDIDATE_BEST (if any), it becomes the new CANDIDATE_BEST.\n+    void PromoteCandidateReady(typename Index::index<ByTxHash>::type::iterator it)\n+    {\n+        assert(it->GetState() == State::CANDIDATE_DELAYED);\n+        // Convert CANDIDATE_DELAYED to CANDIDATE_READY first.\n+        Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+        // The following code relies on the fact that the ByTxHash is sorted by txid, and then by state (first\n+        // _DELAYED, then _BEST/REQUESTED, then _READY). Within the _READY entries, the best one (lowest priority)\n+        // comes first. Thus, if an existing _BEST exists for the same txid that this entry may be preferred over,\n+        // it must immediately precede the newly created _READY.\n+        if (it == m_index.get<ByTxHash>().begin() || std::prev(it)->m_txhash != it->m_txhash ||\n+            std::prev(it)->GetState() == State::CANDIDATE_DELAYED) {\n+            // This is the new best CANDIDATE_READY, and there is no IsSelected() entry for this txid already.\n+            Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+        } else if (std::prev(it)->GetState() == State::CANDIDATE_BEST) {\n+            uint64_t priority_old = std::prev(it)->ComputePriority(m_computer);\n+            uint64_t priority_new = it->ComputePriority(m_computer);\n+            if (priority_new < priority_old) {\n+                // There is a CANDIDATE_BEST entry already, but this one is better.\n+                auto new_ready_it = std::prev(it);\n+                Modify<ByTxHash>(new_ready_it, [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+                Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+    }\n+\n+    //! Change the state of an entry to something non-IsSelected(). If it was IsSelected(), the next best entry will\n+    //! be marked CANDIDATE_BEST.\n+    void ChangeAndReselect(typename Index::index<ByTxHash>::type::iterator it, State new_state)\n+    {\n+        if (it->IsSelected()) {\n+            auto it_next = std::next(it);\n+            // The next best CANDIDATE_READY, if any, immediately follows the REQUESTED or CANDIDATE_BEST entry in\n+            // the ByTxHash index.\n+            if (it_next != m_index.get<ByTxHash>().end() && it_next->m_txhash == it->m_txhash &&\n+                it_next->GetState() == State::CANDIDATE_READY) {\n+                // If one such CANDIDATE_READY exists (for this txhash), convert it to CANDIDATE_BEST.\n+                Modify<ByTxHash>(it_next, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+        Modify<ByTxHash>(it, [new_state](Entry& entry){ entry.SetState(new_state); });\n+        assert(!it->IsSelected());\n+    }\n+\n+    //! Check if 'it' is the only Entry for a given txhash that isn't COMPLETED.\n+    bool IsOnlyNonCompleted(typename Index::index<ByTxHash>::type::iterator it)\n+    {\n+        assert(it->GetState() != State::COMPLETED); // Not allowed to call this on COMPLETED entries.\n+\n+        // If this Entry's predecessor exists, and belongs to the same txhash, it can't be COMPLETED either.\n+        if (it != m_index.get<ByTxHash>().begin() && std::prev(it)->m_txhash == it->m_txhash) return false;\n+\n+        // If this Entry's successor exists, belongs to the same txhash, and isn't COMPLETED, fail.\n+        if (std::next(it) != m_index.get<ByTxHash>().end() && std::next(it)->m_txhash == it->m_txhash &&\n+            std::next(it)->GetState() != State::COMPLETED) return false;\n+\n+        return true;\n+    }\n+\n+    //! Convert any entry to a COMPLETED one. If there are no non-COMPLETED entries left for this txid, they are all\n+    //! deleted. If this was a REQUESTED entry, and there are other CANDIDATEs left, the best one is made\n+    //! CANDIDATE_BEST. Returns whether the Entry still exists.\n+    bool MakeCompleted(typename Index::index<ByTxHash>::type::iterator it)\n+    {\n+        // Nothing to be done if it's already COMPLETED.\n+        if (it->GetState() == State::COMPLETED) return true;\n+\n+        if (IsOnlyNonCompleted(it)) {\n+            // This is the last non-COMPLETED entry for this txhash. Delete all.\n+            uint256 txhash = it->m_txhash;\n+            do {\n+                it = Erase<ByTxHash>(it);\n+            } while (it != m_index.get<ByTxHash>().end() && it->m_txhash == txhash);\n+            return false;\n+        }\n+\n+        // Mark the entry COMPLETED, and select the next best entry (the first CANDIDATE_READY) if needed.\n+        ChangeAndReselect(it, State::COMPLETED);\n+\n+        return true;\n+    }\n+\n+    //! Make the data structure consistent with a given point in time:\n+    //! - REQUESTED entries with expiry <= now are turned into COMPLETED.\n+    //! - CANDIDATE_DELAYED entries with reqtime <= now are turned into CANDIDATE_{READY,BEST}.\n+    //! - CANDIDATE_{READY,BEST} entries with reqtime > now are turned into CANDIDATE_DELAYED.\n+    void SetTimePoint(std::chrono::microseconds now)\n+    {\n+        // Iterate over all CANDIDATE_DELAYED and REQUESTED from old to new, as long as they're in the past,\n+        // and convert them to CANDIDATE_READY and COMPLETED respectively.\n+        while (!m_index.empty()) {\n+            auto it = m_index.get<ByTime>().begin();\n+            if (it->GetState() == State::CANDIDATE_DELAYED && it->m_time <= now) {\n+                PromoteCandidateReady(m_index.project<ByTxHash>(it));\n+            } else if (it->GetState() == State::REQUESTED && it->m_time <= now) {\n+                MakeCompleted(m_index.project<ByTxHash>(it));\n+            } else {\n+                break;\n+            }\n+        }\n+\n+        while (!m_index.empty()) {\n+            // If time went backwards, we may need to demote CANDIDATE_BEST and CANDIDATE_READY entries back\n+            // to CANDIDATE_DELAYED. This is an unusual edge case, and unlikely to matter in production. However,\n+            // it makes it much easier to specify and test TxRequestTracker::Impl's behaviour.\n+            auto it = std::prev(m_index.get<ByTime>().end());\n+            if (it->IsSelectable() && it->m_time > now) {\n+                ChangeAndReselect(m_index.project<ByTxHash>(it), State::CANDIDATE_DELAYED);\n+            } else {\n+                break;\n+            }\n+        }\n+    }\n+\n+public:\n+    Impl(bool deterministic) :\n+        m_computer(deterministic),\n+        // Explicitly initialize m_index as we need to pass a reference to m_computer to EntryTxHashExtractor.\n+        m_index(boost::make_tuple(\n+            boost::make_tuple(\n+                boost::multi_index::const_mem_fun<Entry, EntryPeer, &Entry::ExtractPeer>(),\n+                std::less<EntryPeer>()\n+            ),\n+            boost::make_tuple(\n+                EntryTxHashExtractor(m_computer),\n+                std::less<EntryTxHash>()\n+            ),\n+            boost::make_tuple(\n+                boost::multi_index::const_mem_fun<Entry, EntryTime, &Entry::ExtractTime>(),\n+                std::less<EntryTime>()\n+            )\n+        )) {}\n+\n+\n+    // Disable copying and assigning (a default copy won't work due the stateful EntryTxHashExtractor).\n+    Impl(const Impl&) = delete;\n+    Impl& operator=(const Impl&) = delete;\n+\n+    void DeletedPeer(uint64_t peer)\n+    {\n+        auto& index = m_index.get<ByPeer>();\n+        auto it = index.lower_bound(EntryPeer{peer, false, UINT256_ZERO});\n+        while (it != index.end() && it->m_peer == peer) {\n+            // Check what to continue with after this iteration. Note that 'it' may change position, and\n+            // std::next(it) may be deleted in the process, so this needs to be decided beforehand.\n+            auto it_next = (std::next(it) == index.end() || std::next(it)->m_peer != peer) ?\n+                index.end() : std::next(it);\n+            // If the entry isn't already COMPLETED, first make it COMPLETED (which will mark other CANDIDATEs as\n+            // CANDIDATE_BEST, or delete all of a txid's entries if no non-COMPLETED ones are left).\n+            if (MakeCompleted(m_index.project<ByTxHash>(it))) {\n+                // Then actually delete the entry (unless it was already deleted by MakeCompleted).\n+                Erase<ByPeer>(it);\n+            }\n+            it = it_next;\n+        }\n+    }\n+\n+    void ForgetTx(const GenTxid& gtxid)\n+    {\n+        auto it = m_index.get<ByTxHash>().lower_bound(EntryTxHash{gtxid.GetHash(), State::CANDIDATE_DELAYED, 0});\n+        while (it != m_index.get<ByTxHash>().end() && it->m_txhash == gtxid.GetHash()) {\n+            it = Erase<ByTxHash>(it);\n+        }\n+    }\n+\n+    void ReceivedInv(uint64_t peer, const GenTxid& gtxid, bool preferred, bool overloaded,\n+        std::chrono::microseconds reqtime)\n+    {\n+        // Bail out if we already have a CANDIDATE_BEST entry for this (txid, peer) combination. The case where there is\n+        // a non-CANDIDATE_BEST entry already will be caught by the uniqueness property of the ByPeer index\n+        // automatically.\n+        if (m_index.get<ByPeer>().count(EntryPeer{peer, true, gtxid.GetHash()})) return;\n+\n+        // Find last entry for this txhash, and extract per_txhash information from it.\n+        uint8_t per_txhash = 0;\n+        typename Index::index<ByTxHash>::type::iterator it_last = m_index.get<ByTxHash>().end();\n+        // First find the first entry past this txhash.\n+        it_last = m_index.get<ByTxHash>().lower_bound(EntryTxHash{gtxid.GetHash(), State::TOO_LARGE, 0});\n+        if (it_last != m_index.get<ByTxHash>().begin() && std::prev(it_last)->m_txhash == gtxid.GetHash()) {\n+            // Its predecessor exists, and has the right txhash. Remember it, and OR in its flags.\n+            it_last--;\n+            per_txhash |= it_last->m_per_txhash;\n+        } else {\n+            // No entry for this txhash exists yet.\n+            it_last = m_index.get<ByTxHash>().end();\n+        }\n+\n+        // Determine whether the new announcement's Entry will get the first marker, and update\n+        // the per_txhash information to be stored (but note that per_txhash isn't actually stored\n+        // until after the emplace below succeeds).\n+        bool first = false;\n+        if (!overloaded) {\n+            if (preferred && !(per_txhash & TXHASHINFO_NO_MORE_PREFERRED_FIRST)) {\n+                first = true;\n+                per_txhash |= TXHASHINFO_NO_MORE_PREFERRED_FIRST;\n+            } else if (!preferred && !(per_txhash & TXHASHINFO_NO_MORE_NONPREFERRED_FIRST)) {\n+                first = true;\n+                per_txhash |= TXHASHINFO_NO_MORE_NONPREFERRED_FIRST;\n+            }\n+        }\n+\n+        // Try creating the entry with CANDIDATE_DELAYED state (which will fail due to the uniqueness\n+        // of the ByPeer index if a non-CANDIDATE_BEST entry already exists with the same txhash and peer).\n+        // Bail out in that case.\n+        auto ret = m_index.get<ByPeer>().emplace(gtxid, peer, preferred, reqtime, m_sequence, first);\n+        if (!ret.second) return;\n+\n+        // Update accounting metadata.\n+        ++m_peerinfo[peer].m_total;\n+        ++m_sequence;\n+\n+        // Update m_per_txhash of the new last Entry (either the newly created one, or it_last).\n+        auto it = m_index.project<ByTxHash>(ret.first);\n+        if (it_last == m_index.get<ByTxHash>().end() || std::next(it_last) == it) it_last = it;\n+        it_last->m_per_txhash |= per_txhash;\n+    }\n+\n+    //! Find the txids to request now from peer.\n+    std::vector<GenTxid> GetRequestable(uint64_t peer, std::chrono::microseconds now)\n+    {\n+        // Move time.\n+        SetTimePoint(now);\n+\n+        // Find all CANDIDATE_BEST entries for this peer.\n+        std::vector<std::pair<uint64_t, const Entry*>> selected;\n+        auto it_peer = m_index.get<ByPeer>().lower_bound(EntryPeer{peer, true, UINT256_ZERO});\n+        while (it_peer != m_index.get<ByPeer>().end() && it_peer->m_peer == peer &&\n+            it_peer->GetState() == State::CANDIDATE_BEST) {\n+            selected.emplace_back(it_peer->m_sequence, &*it_peer);\n+            ++it_peer;\n+        }\n+\n+        // Return them, sorted by sequence number.\n+        std::sort(selected.begin(), selected.end());\n+        std::vector<GenTxid> ret;\n+        for (const auto& item : selected) {\n+            ret.emplace_back(item.second->m_is_wtxid, item.second->m_txhash);\n+        }\n+        return ret;\n+    }\n+\n+    void RequestedTx(uint64_t peer, const GenTxid& gtxid, std::chrono::microseconds expiry)\n+    {\n+        auto it = m_index.get<ByPeer>().find(EntryPeer{peer, true, gtxid.GetHash()});\n+        // RequestedTx can only be called on CANDIDATE_BEST entries (this is implied by its condition that it can only be\n+        // called on txids returned by GetRequestable (and only AlreadyHave and RequestedTx can be called in between,\n+        // which preserve the state of other txids).\n+        assert(it != m_index.get<ByPeer>().end());\n+        assert(it->GetState() == State::CANDIDATE_BEST);\n+        Modify<ByPeer>(it, [expiry](Entry& entry) {\n+            entry.SetState(State::REQUESTED);\n+            entry.m_time = expiry;\n+        });\n+\n+        // Update the m_per_txhash (of the last Entry for this txhash) to reflect that new ones are no longer\n+        // eligible for the \"first\" marker.\n+        auto it_last = std::prev(m_index.get<ByTxHash>().lower_bound(EntryTxHash{gtxid.GetHash(), State::TOO_LARGE, 0}));\n+        assert(it_last->m_txhash == gtxid.GetHash());\n+        it_last->m_per_txhash |= TXHASHINFO_NO_MORE_PREFERRED_FIRST | TXHASHINFO_NO_MORE_NONPREFERRED_FIRST;\n+    }\n+\n+    void ReceivedResponse(uint64_t peer, const GenTxid& gtxid)\n+    {\n+        // We need to search the ByPeer index for both (peer, false, txid) and (peer, true, txid).\n+        auto it = m_index.get<ByPeer>().find(EntryPeer{peer, false, gtxid.GetHash()});\n+        if (it == m_index.get<ByPeer>().end()) {\n+            it = m_index.get<ByPeer>().find(EntryPeer{peer, true, gtxid.GetHash()});\n+        }\n+        if (it != m_index.get<ByPeer>().end()) MakeCompleted(m_index.project<ByTxHash>(it));\n+    }\n+\n+    size_t CountInFlight(uint64_t peer) const\n+    {\n+        auto it = m_peerinfo.find(peer);\n+        if (it != m_peerinfo.end()) return it->second.m_requested;\n+        return 0;\n+    }\n+\n+    size_t CountTracked(uint64_t peer) const\n+    {\n+        auto it = m_peerinfo.find(peer);\n+        if (it != m_peerinfo.end()) return it->second.m_total;\n+        return 0;\n+    }\n+\n+    //! Count how many announcements are being tracked in total across all peers and transactions.\n+    size_t Size() const { return m_index.size(); }\n+\n+    //! Access to the internal PriorityComputer (for testing)\n+    const PriorityComputer& GetPriorityComputer() const { return m_computer; }\n+\n+    void SanityCheck() const\n+    {\n+        // Recompute m_peerdata.\n+        // This verifies the data in it, including the invariant\n+        // that no entries with m_total_announcements==0 exist.\n+        std::unordered_map<uint64_t, PeerInfo> peerinfo;\n+        for (const auto& a : m_index) {\n+            auto& entry = peerinfo[a.m_peer];\n+            ++entry.m_total;\n+            entry.m_requested += (a.GetState() == State::REQUESTED);\n+        }\n+        assert(m_peerinfo == peerinfo);\n+\n+        struct Counts {\n+            //! Number of CANDIDATE_DELAYED entries for this txhash.\n+            size_t m_candidate_delayed = 0;\n+            //! Number of CANDIDATE_READY entries for this txhash.\n+            size_t m_candidate_ready = 0;\n+            //! Number of CANDIDATE_BEST entries for this txhash (at most one).\n+            size_t m_candidate_best = 0;\n+            //! Number of REQUESTED entries for this txhash.\n+            size_t m_requested = 0;\n+            //! The priority of the CANDIDATE_BEST entry if one exists, or 0 otherwise.\n+            uint64_t m_priority_candidate_best = 0;\n+            //! The lowest priority of all CANDIDATE_READY entries (or max() if none exist).\n+            uint64_t m_priority_best_candidate_ready = std::numeric_limits<uint64_t>::max();\n+            //! All peers we have an entry for this txhash for.\n+            std::vector<uint64_t> m_peers;\n+            //! Whether any preferred first entry exists.\n+            bool m_any_preferred_first = false;\n+            //! Whether any non-preferred first entry exists.\n+            bool m_any_nonpreferred_first = false;\n+            //! OR of all m_per_txhash flags.\n+            uint8_t m_or_all_per_txhash = 0;\n+        };\n+\n+        std::map<uint256, Counts> table;\n+        for (const auto& a : m_index) {\n+            auto& entry = table[a.m_txhash];\n+            // Classify how many types peers we have for this txid.\n+            entry.m_candidate_delayed += (a.GetState() == State::CANDIDATE_DELAYED);\n+            entry.m_candidate_ready += (a.GetState() == State::CANDIDATE_READY);\n+            entry.m_candidate_best += (a.GetState() == State::CANDIDATE_BEST);\n+            entry.m_requested += (a.GetState() == State::REQUESTED);\n+            // And track the priority of the best CANDIDATE_READY/CANDIDATE_BEST entries.\n+            if (a.GetState() == State::CANDIDATE_BEST) {\n+                entry.m_priority_candidate_best = a.ComputePriority(m_computer);\n+            }\n+            if (a.GetState() == State::CANDIDATE_READY) {\n+                entry.m_priority_best_candidate_ready = std::min(entry.m_priority_best_candidate_ready,\n+                    a.ComputePriority(m_computer));\n+            }\n+            // Also keep track of which peers this txid has an entry for (so we can detect duplicates).\n+            entry.m_peers.push_back(a.m_peer);\n+            // Track preferred/first.\n+            entry.m_any_preferred_first |= (a.m_first && a.m_preferred);\n+            entry.m_any_nonpreferred_first |= (a.m_first && !a.m_preferred);\n+            entry.m_or_all_per_txhash |= a.m_per_txhash;\n+        }\n+        for (auto& entry : table) {\n+            auto& c = entry.second;\n+            // Cannot have only COMPLETED peers (txid should have been deleted)\n+            assert(c.m_candidate_delayed + c.m_candidate_ready + c.m_candidate_best + c.m_requested > 0);\n+            // Can have at most 1 CANDIDATE_BEST/REQUESTED peer\n+            assert(c.m_candidate_best + c.m_requested <= 1);\n+            // If there are any CANDIDATE_READY entries, there must be exactly one CANDIDATE_BEST or REQUESTED\n+            // entry.\n+            if (c.m_candidate_ready > 0) {\n+                assert(c.m_candidate_best + c.m_requested == 1);\n+            }\n+            // If there is both a CANDIDATE_READY and a CANDIDATE_BEST entry, the CANDIDATE_BEST one must be at\n+            // least as good as the best CANDIDATE_READY.\n+            if (c.m_candidate_ready && c.m_candidate_best) {\n+                assert(c.m_priority_candidate_best <= c.m_priority_best_candidate_ready);\n+            }\n+            // Detect duplicate (peer, txid) entries\n+            std::sort(c.m_peers.begin(), c.m_peers.end());\n+            assert(std::adjacent_find(c.m_peers.begin(), c.m_peers.end()) == c.m_peers.end());\n+            // Verify all per_txhash flags.\n+            uint8_t expected_per_txhash = 0;\n+            if (c.m_any_preferred_first || c.m_requested) {\n+                expected_per_txhash |= TXHASHINFO_NO_MORE_PREFERRED_FIRST;\n+            }\n+            if (c.m_any_nonpreferred_first || c.m_requested) {\n+                expected_per_txhash |= TXHASHINFO_NO_MORE_NONPREFERRED_FIRST;\n+            }\n+            // All expected flags must be present, but there can be more. If a node went from REQUESTED to\n+            // COMPLETED, or was deleted, our expected_per_txhash may miss the relevant bits.\n+            assert((expected_per_txhash & ~c.m_or_all_per_txhash) == 0);\n+            // No entry can have flags that are a superset of the actual ones (they're always ORed into the actual\n+            // one).\n+            auto it_last = std::prev(m_index.get<ByTxHash>().lower_bound(\n+                EntryTxHash{entry.first, State::TOO_LARGE, 0}));\n+            assert(it_last->m_txhash == entry.first);\n+            assert(c.m_or_all_per_txhash == it_last->m_per_txhash);\n+        }\n+    }\n+\n+    void PostGetRequestableSanityCheck(std::chrono::microseconds now) const\n+    {\n+        for (const auto& entry : m_index) {\n+            if (entry.IsWaiting()) {\n+                // REQUESTED and CANDIDATE_DELAYED must have a time in the future (they should have been converted\n+                // to COMPLETED/CANDIDATE_READY respectively).\n+                assert(entry.m_time > now);\n+            } else if (entry.IsSelectable()) {\n+                // CANDIDATE_READY and CANDIDATE_BEST cannot have a time in the future (they should have remained\n+                // CANDIDATE_DELAYED, or should have been converted back to it if time went backwards).\n+                assert(entry.m_time <= now);\n+            }\n+        }\n+    }\n+};\n+\n+TxRequestTracker::TxRequestTracker(bool deterministic)\n+{\n+    m_impl = MakeUnique<TxRequestTracker::Impl>(deterministic);\n+}\n+\n+TxRequestTracker::~TxRequestTracker() {}",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494257310",
      "id" : 494257310,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDI1NzMxMA==",
      "original_commit_id" : "7949d08406774f27fd0291c2aa046ecdf985c191",
      "original_line" : 676,
      "original_position" : 676,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : null,
      "pull_request_review_id" : 495495274,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-24T17:33:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494257310",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494323998"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494323998"
         }
      },
      "author_association" : "MEMBER",
      "body" : "It looks like this is only in the header so that the unit and fuzz tests can call `GetPriorityComputer()` and get the computer, and the only reason they do that is so they can call `PriorityComputer::operator()()`.\r\n\r\nCould you move all this to the implementation file, and add a public method `ComputePriority` to by used by the tests that calculates the priority internally and returns it?",
      "commit_id" : "4508a6e58d28eb5436031861aca1a43b76156097",
      "created_at" : "2020-09-24T13:38:39Z",
      "diff_hunk" : "@@ -0,0 +1,222 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not (which peers are preferred is determined by the caller, but this is\n+ *   designed for outbound peers, or other peers that we have a higher level of trust in).\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see '\"First\" marker rules').\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the transaction was forgotten in\n+ *   between (see next point), and re-announced.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening invblock attacks. The flip side is that as long as an attacker manages to prevent\n+ *              us from receiving a transaction, failed announcements (including those from honest peers) will\n+ *              linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on\n+ *              the number of tracked announcements per peer.\n+ *              See https://allquantor.at/blockchainbib/pdf/miller2015topology.pdf for information on invblocking.\n+ *\n+ * - Announcements are only forgotten about when the peer that announced them went offline, when the transaction\n+ *   was received successfully, or when no candidates for a transaction remain that haven't been tried already.\n+ *\n+ *   Rationale: we need to eventually forget announcements to keep memory bounded, but as long as viable\n+ *              candidate peers remain, we prefer to avoid fetching from failed ones. As every request has a finite\n+ *              timeout and we schedule new request as soon a previous one expired, there is always progress being\n+ *              made towards forgetting a transaction - either successfully or unsuccessfully.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable net_processing code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers (outbound, whitelisted) are chosen by us, so are less likely to be under attacker\n+ *                control.\n+ *\n+ *   - Among the remaining candidates, choose the one with the \"first\" marker if one exists (there can be at most\n+ *     one such peer, see further).\n+ *\n+ *     Rationale: in non-attack scenarios we want to give one chance to request from the fastest peer to reduce\n+ *                latency, and reduce risk of breaking chains of dependent transactions. An attacker who races the\n+ *                network can exploit this to delay us learning about a transaction, but it is available only once\n+ *                per txhash.\n+ *\n+ *   - If no remaining candidates have the \"first\" marker, pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: if the \"first\" mechanism failed, random assignments are hard to influence for attackers.\n+ *\n+ * \"First\" marker rules: the \"first\" marker is given to announcements for which at the time of announcement:\n+ * - No requests for its txhash have been attempted (ever, or since it was forgotten about).\n+ * - The peer that announced them was not overloaded.\n+ * - No announcement for the same txhash from another peer within the same preferred/nonpreferred class already has\n+ *   the first marker already.\n+ *\n+ *   Rationale: these restrictions avoid giving the speed benefit to honest but overloaded peers, and also\n+ *              reduce the extent to which attackers that race the network in announcing all transactions\n+ *              can break chains of dependent transactions.\n+ *\n+ * Together these rules strike a balance between being fast in non-adverserial conditions and avoiding influenceable\n+ * by attackers. An invblocking attacker that races the network:\n+ * - Will be unsuccessful if all preferred connections are honest (and there is at least one).\n+ * - If there are P preferred connections of which Ph>=1 are honest, the attacker can delay us from learning\n+ *   about a transaction by k expiration periods, where k ~ 1 + NHG(N=P-1,K=P-Ph-1,r=1), which has mean\n+ *   P/(Ph+1) (where NHG stands for Negative Hypergeometric distribution).\n+ * - If all P preferred connections are to the attacker, and there are NP non-preferred connections of which NPh are\n+ *   honest, k ~ P + 1 + NHG(N=NP-1,K=NP-NPh-1,r=1), with mean P + NP/(NPh+1).\n+ *\n+ * Complexity:\n+ * - Memory usage is proportional to the total number of tracked announcements (Size()) plus the number of\n+ *   peers with a nonzero number of tracked announcements.\n+ * - CPU usage is generally logarithmic in the total number of tracked announcements, plus the number of\n+ *   announcements affected by an operation (amortized O(1) per announcement).\n+ */\n+class TxRequestTracker {\n+public:\n+    /** A functor with embedded salt that computes priority of a txhash/peer combination. Lower priorities are\n+     *  selected first. */\n+    class PriorityComputer {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494323998",
      "id" : 494323998,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDMyMzk5OA==",
      "original_commit_id" : "7949d08406774f27fd0291c2aa046ecdf985c191",
      "original_line" : 112,
      "original_position" : 112,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 495579753,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-24T17:33:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494323998",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494348645"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494348645"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Consider using an initializer list here instead of setting `m_impl` in the ctor function body.\r\n\r\nIf you did that, you could make `m_impl` const, which is fine since you've deleted the move constructor and assignment.\r\n\r\n`const unique_ptr` communicates that _this_ `m_impl` is always the object that `TxRequestTracker` owns. See Herb Sutter's Leak-Freedom talk at https://youtu.be/JfmTagWcqoE?t=571\r\n\r\n```diff\r\ndiff --git a/src/txrequest.cpp b/src/txrequest.cpp\r\nindex f6c387f8f4..b7d90a1ba5 100644\r\n--- a/src/txrequest.cpp\r\n+++ b/src/txrequest.cpp\r\n@@ -668,10 +668,8 @@ public:\r\n     }\r\n };\r\n \r\n-TxRequestTracker::TxRequestTracker(bool deterministic)\r\n-{\r\n-    m_impl = MakeUnique<TxRequestTracker::Impl>(deterministic);\r\n-}\r\n+TxRequestTracker::TxRequestTracker(bool deterministic) :\r\n+    m_impl{MakeUnique<TxRequestTracker::Impl>(deterministic)} {}\r\n \r\n TxRequestTracker::~TxRequestTracker() {}\r\n \r\ndiff --git a/src/txrequest.h b/src/txrequest.h\r\nindex 6e892eebe1..83f6dbe2fe 100644\r\n--- a/src/txrequest.h\r\n+++ b/src/txrequest.h\r\n@@ -119,7 +119,7 @@ public:\r\n private:\r\n     // Avoid littering this header file with implementation details.\r\n     class Impl;\r\n-    std::unique_ptr<Impl> m_impl;\r\n+    const std::unique_ptr<Impl> m_impl;\r\n \r\n public:\r\n     //! Construct a TxRequestTracker.\r\n```",
      "commit_id" : "4508a6e58d28eb5436031861aca1a43b76156097",
      "created_at" : "2020-09-24T14:06:12Z",
      "diff_hunk" : "@@ -0,0 +1,715 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+TxRequestTracker::PriorityComputer::PriorityComputer(bool deterministic) :\n+    m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+    m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+uint64_t TxRequestTracker::PriorityComputer::operator()(const uint256& txhash, uint64_t peer, bool preferred, bool first) const\n+{\n+    uint64_t low_bits = 0;\n+    if (!first) {\n+        low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+    }\n+    return low_bits | uint64_t{!preferred} << 63;\n+}\n+\n+static const uint256 UINT256_ZERO;\n+\n+/** Actual implementation for TxRequestTracker's data structure. */\n+class TxRequestTracker::Impl {\n+    //! The various states a (txid,node) pair can be in.\n+    //! Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient\n+    //! implementation. Also note that the sorting order of EntryTxHash relies on the specific order of values in\n+    //! this enum.\n+    enum class State : uint8_t {\n+        //! A CANDIDATE entry whose reqtime is in the future.\n+        CANDIDATE_DELAYED,\n+        //! The best CANDIDATE for a given txid; only if there is no REQUESTED entry already for that txid.\n+        //! The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txid.\n+        CANDIDATE_BEST,\n+        //! A REQUESTED entry.\n+        REQUESTED,\n+        //! A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST.\n+        CANDIDATE_READY,\n+        //! A COMPLETED entry.\n+        COMPLETED,\n+\n+        //! An invalid State value that's larger than all valid ones.\n+        TOO_LARGE,\n+    };\n+\n+    /** A flag (in Entry::m_per_txhash) to indicate that for that txhash,\n+     *  new preferred announcements are not eligible to get the 'first' marker. */\n+    static constexpr uint8_t TXHASHINFO_NO_MORE_PREFERRED_FIRST = 1;\n+    /** A flag (in Entry::m_per_txhash) to indicate that for that txhash,\n+     *  new non-preferred announcements are not eligible to get the 'first' marker. */\n+    static constexpr uint8_t TXHASHINFO_NO_MORE_NONPREFERRED_FIRST = 2;\n+\n+    //! Tag for the EntryPeer-based index.\n+    struct ByPeer {};\n+    //! Tag for the EntryTxHash-based index.\n+    struct ByTxHash {};\n+    //! Tag for the EntryTime-based index.\n+    struct ByTime {};\n+\n+    //! The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txid)\n+    using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+\n+    //! The ByTxHash index is sorted by (txhash, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+    using EntryTxHash = std::tuple<const uint256&, State, uint64_t>;\n+\n+    //! The ByTime index is sorted by (0 [CANDIDATE_DELAYED,REQUESTED]; 1 [COMPLETED];\n+    // 2 [CANDIDATE_READY,CANDIDATE_BEST], time)\n+    using EntryTime = std::pair<int, std::chrono::microseconds>;\n+\n+    //! The current sequence number. Increases for every announcement. This is used to sort txids returned by\n+    //! GetRequestable in announcement order.\n+    uint64_t m_sequence{0};\n+\n+    //! An announcement entry.\n+    struct Entry {\n+        //! Txid that was announced.\n+        const uint256 m_txhash;\n+        //! For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry\n+        std::chrono::microseconds m_time;\n+        //! What peer the request was from.\n+        const uint64_t m_peer;\n+        //! What sequence number this announcement has.\n+        const uint64_t m_sequence : 56;\n+        //! Whether the request is preferred (giving it priority higher than non-preferred ones).\n+        const bool m_preferred : 1;\n+        //! Whether this is a wtxid request.\n+        const bool m_is_wtxid : 1;\n+        //! Whether this was: the very first announcement for this txhash, within the\n+        //! preferred or non-preferred ones, and no request had been made for this\n+        //! txhash from any peer at the time the announcement came in.\n+        const bool m_first : 1;\n+\n+        //! What state this announcement is in\n+        //! This is a uint8_t instead of a State to silence a GCC warning.\n+        uint8_t m_state : 3;\n+\n+        /** Per-txhash flags. These are stored in the last Entry for a given txhash (ByTxHash order).\n+         *  The values for other Entry objects can be arbitrary subsets of the actual flags. */\n+        mutable uint8_t m_per_txhash : 2;\n+\n+        //! Convert the m_state variable to a State enum.\n+        State GetState() const { return State(m_state); }\n+        //! Convert a State to a uint8_t and store it in m_state.\n+        void SetState(State state) { m_state = uint8_t(state); }\n+\n+        //! Whether this entry is selected. There can be at most 1 selected peer per txhash.\n+        bool IsSelected() const\n+        {\n+            return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+        }\n+\n+        //! Whether this entry is waiting for a certain time to pass.\n+        bool IsWaiting() const\n+        {\n+            return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+        }\n+\n+        //! Whether this entry can feasibly be selected if the current IsSelected() one disappears.\n+        bool IsSelectable() const\n+        {\n+            return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+        }\n+\n+        //! Construct a new entry from scratch, initially in CANDIDATE_DELAYED state.\n+        Entry(const GenTxid& gtxid, uint64_t peer, bool preferred, std::chrono::microseconds reqtime,\n+            uint64_t sequence, bool first) :\n+            m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+            m_is_wtxid(gtxid.IsWtxid()), m_first(first), m_state(uint8_t(State::CANDIDATE_DELAYED)),\n+            m_per_txhash(0) {}\n+\n+        //! Compute this Entry's priority.\n+        uint64_t ComputePriority(const PriorityComputer& computer) const\n+        {\n+            return computer(m_txhash, m_peer, m_preferred, m_first);\n+        }\n+\n+        //! Extract the EntryPeer from this Entry.\n+        EntryPeer ExtractPeer() const { return EntryPeer{m_peer, GetState() == State::CANDIDATE_BEST, m_txhash}; }\n+\n+        //! Extract the EntryTxHash from this Entry.\n+        EntryTxHash ExtractTxid(const PriorityComputer& computer) const\n+        {\n+            return EntryTxHash{\n+                m_txhash,\n+                GetState(),\n+                GetState() == State::CANDIDATE_READY ? ComputePriority(computer) : 0\n+            };\n+        }\n+\n+        //! Extract the EntryTime from this Entry.\n+        EntryTime ExtractTime() const { return EntryTime{IsWaiting() ? 0 : IsSelectable() ? 2 : 1, m_time}; }\n+    };\n+\n+    //! This tracker's priority computer.\n+    const PriorityComputer m_computer;\n+\n+    /** An extractor for EntryTxHash (with encapsulated PriorityComputer reference).\n+     *\n+     * See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+     * for more information about the key extraction concept.\n+     */\n+    class EntryTxHashExtractor {\n+        const PriorityComputer& m_computer;\n+    public:\n+        EntryTxHashExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+        using result_type = EntryTxHash; // Needed to comply with key extractor interface\n+        result_type operator()(const Entry& entry) const { return entry.ExtractTxid(m_computer); }\n+    };\n+\n+    //! Data type for the main data structure (Entry objects with ByPeer/ByTxHash/ByTime indexes).\n+    using Index = boost::multi_index_container<\n+        Entry,\n+        boost::multi_index::indexed_by<\n+            boost::multi_index::ordered_unique<\n+                boost::multi_index::tag<ByPeer>,\n+                boost::multi_index::const_mem_fun<Entry, EntryPeer, &Entry::ExtractPeer>\n+            >,\n+            boost::multi_index::ordered_non_unique<\n+                boost::multi_index::tag<ByTxHash>,\n+                EntryTxHashExtractor\n+            >,\n+            boost::multi_index::ordered_non_unique<\n+                boost::multi_index::tag<ByTime>,\n+                boost::multi_index::const_mem_fun<Entry, EntryTime, &Entry::ExtractTime>\n+            >\n+        >\n+    >;\n+\n+    //! This tracker's main data structure.\n+    Index m_index;\n+\n+    //! Per-peer statistics object.\n+    struct PeerInfo {\n+        size_t m_total = 0; //!< Total number of entries for this peer.\n+        size_t m_requested = 0; //!< Total number of REQUESTED entries for this peer.\n+\n+        friend bool operator==(const PeerInfo& a, const PeerInfo& b)\n+        {\n+            return std::tie(a.m_total, a.m_requested) == std::tie(b.m_total, b.m_requested);\n+        }\n+    };\n+\n+    //! Map with this tracker's per-peer statistics.\n+    std::unordered_map<uint64_t, PeerInfo> m_peerinfo;\n+\n+    //! Wrapper around Index::...::erase that keeps m_peerinfo and m_per_txhash up to date.\n+    template<typename Tag>\n+    typename Index::index<Tag>::type::iterator Erase(typename Index::index<Tag>::type::iterator it)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        if (--peerit->second.m_total == 0) m_peerinfo.erase(peerit);\n+        // As it may possibly be the last-sorted Entry for a given txhash, propagate its per-txhash flags to its\n+        // predecessor (if it belongs to the same txhash).\n+        auto bytxhashit = m_index.project<ByTxHash>(it);\n+        if (bytxhashit != m_index.get<ByTxHash>().begin() &&\n+            bytxhashit->m_txhash == std::prev(bytxhashit)->m_txhash) {\n+            std::prev(bytxhashit)->m_per_txhash |= bytxhashit->m_per_txhash;\n+        }\n+        return m_index.get<Tag>().erase(it);\n+    }\n+\n+\n+    //! Wrapper around Index::...::modify that keeps m_peerinfo and m_per_txhash up to date.\n+    template<typename Tag, typename Modifier>\n+    void Modify(typename Index::index<Tag>::type::iterator it, Modifier modifier)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        // It's possible that it used to be the last-sorted Entry for its txhash, so propagate its\n+        // flags to its predecessor (which would then become the new last-sorted Entry).\n+        auto bytxhashit = m_index.project<ByTxHash>(it);\n+        if (bytxhashit != m_index.get<ByTxHash>().begin() &&\n+            bytxhashit->m_txhash == std::prev(bytxhashit)->m_txhash) {\n+            std::prev(bytxhashit)->m_per_txhash |= bytxhashit->m_per_txhash;\n+        }\n+        m_index.get<Tag>().modify(it, std::move(modifier));\n+        // It's possible that it is now the new last-sorted Entry for its txhash, so propagate flags\n+        // from its predecessor to it.\n+        bytxhashit = m_index.project<ByTxHash>(it);\n+        if (bytxhashit != m_index.get<ByTxHash>().begin() &&\n+            bytxhashit->m_txhash == std::prev(bytxhashit)->m_txhash) {\n+            bytxhashit->m_per_txhash |= std::prev(bytxhashit)->m_per_txhash;\n+        }\n+        peerit->second.m_requested += it->GetState() == State::REQUESTED;\n+    }\n+\n+\n+    //! Convert a CANDIDATE_DELAYED entry into a CANDIDATE_READY. If this makes it the new best CANDIDATE_READY\n+    //! (and no REQUESTED exists) and better than the CANDIDATE_BEST (if any), it becomes the new CANDIDATE_BEST.\n+    void PromoteCandidateReady(typename Index::index<ByTxHash>::type::iterator it)\n+    {\n+        assert(it->GetState() == State::CANDIDATE_DELAYED);\n+        // Convert CANDIDATE_DELAYED to CANDIDATE_READY first.\n+        Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+        // The following code relies on the fact that the ByTxHash is sorted by txid, and then by state (first\n+        // _DELAYED, then _BEST/REQUESTED, then _READY). Within the _READY entries, the best one (lowest priority)\n+        // comes first. Thus, if an existing _BEST exists for the same txid that this entry may be preferred over,\n+        // it must immediately precede the newly created _READY.\n+        if (it == m_index.get<ByTxHash>().begin() || std::prev(it)->m_txhash != it->m_txhash ||\n+            std::prev(it)->GetState() == State::CANDIDATE_DELAYED) {\n+            // This is the new best CANDIDATE_READY, and there is no IsSelected() entry for this txid already.\n+            Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+        } else if (std::prev(it)->GetState() == State::CANDIDATE_BEST) {\n+            uint64_t priority_old = std::prev(it)->ComputePriority(m_computer);\n+            uint64_t priority_new = it->ComputePriority(m_computer);\n+            if (priority_new < priority_old) {\n+                // There is a CANDIDATE_BEST entry already, but this one is better.\n+                auto new_ready_it = std::prev(it);\n+                Modify<ByTxHash>(new_ready_it, [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+                Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+    }\n+\n+    //! Change the state of an entry to something non-IsSelected(). If it was IsSelected(), the next best entry will\n+    //! be marked CANDIDATE_BEST.\n+    void ChangeAndReselect(typename Index::index<ByTxHash>::type::iterator it, State new_state)\n+    {\n+        if (it->IsSelected()) {\n+            auto it_next = std::next(it);\n+            // The next best CANDIDATE_READY, if any, immediately follows the REQUESTED or CANDIDATE_BEST entry in\n+            // the ByTxHash index.\n+            if (it_next != m_index.get<ByTxHash>().end() && it_next->m_txhash == it->m_txhash &&\n+                it_next->GetState() == State::CANDIDATE_READY) {\n+                // If one such CANDIDATE_READY exists (for this txhash), convert it to CANDIDATE_BEST.\n+                Modify<ByTxHash>(it_next, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+        Modify<ByTxHash>(it, [new_state](Entry& entry){ entry.SetState(new_state); });\n+        assert(!it->IsSelected());\n+    }\n+\n+    //! Check if 'it' is the only Entry for a given txhash that isn't COMPLETED.\n+    bool IsOnlyNonCompleted(typename Index::index<ByTxHash>::type::iterator it)\n+    {\n+        assert(it->GetState() != State::COMPLETED); // Not allowed to call this on COMPLETED entries.\n+\n+        // If this Entry's predecessor exists, and belongs to the same txhash, it can't be COMPLETED either.\n+        if (it != m_index.get<ByTxHash>().begin() && std::prev(it)->m_txhash == it->m_txhash) return false;\n+\n+        // If this Entry's successor exists, belongs to the same txhash, and isn't COMPLETED, fail.\n+        if (std::next(it) != m_index.get<ByTxHash>().end() && std::next(it)->m_txhash == it->m_txhash &&\n+            std::next(it)->GetState() != State::COMPLETED) return false;\n+\n+        return true;\n+    }\n+\n+    //! Convert any entry to a COMPLETED one. If there are no non-COMPLETED entries left for this txid, they are all\n+    //! deleted. If this was a REQUESTED entry, and there are other CANDIDATEs left, the best one is made\n+    //! CANDIDATE_BEST. Returns whether the Entry still exists.\n+    bool MakeCompleted(typename Index::index<ByTxHash>::type::iterator it)\n+    {\n+        // Nothing to be done if it's already COMPLETED.\n+        if (it->GetState() == State::COMPLETED) return true;\n+\n+        if (IsOnlyNonCompleted(it)) {\n+            // This is the last non-COMPLETED entry for this txhash. Delete all.\n+            uint256 txhash = it->m_txhash;\n+            do {\n+                it = Erase<ByTxHash>(it);\n+            } while (it != m_index.get<ByTxHash>().end() && it->m_txhash == txhash);\n+            return false;\n+        }\n+\n+        // Mark the entry COMPLETED, and select the next best entry (the first CANDIDATE_READY) if needed.\n+        ChangeAndReselect(it, State::COMPLETED);\n+\n+        return true;\n+    }\n+\n+    //! Make the data structure consistent with a given point in time:\n+    //! - REQUESTED entries with expiry <= now are turned into COMPLETED.\n+    //! - CANDIDATE_DELAYED entries with reqtime <= now are turned into CANDIDATE_{READY,BEST}.\n+    //! - CANDIDATE_{READY,BEST} entries with reqtime > now are turned into CANDIDATE_DELAYED.\n+    void SetTimePoint(std::chrono::microseconds now)\n+    {\n+        // Iterate over all CANDIDATE_DELAYED and REQUESTED from old to new, as long as they're in the past,\n+        // and convert them to CANDIDATE_READY and COMPLETED respectively.\n+        while (!m_index.empty()) {\n+            auto it = m_index.get<ByTime>().begin();\n+            if (it->GetState() == State::CANDIDATE_DELAYED && it->m_time <= now) {\n+                PromoteCandidateReady(m_index.project<ByTxHash>(it));\n+            } else if (it->GetState() == State::REQUESTED && it->m_time <= now) {\n+                MakeCompleted(m_index.project<ByTxHash>(it));\n+            } else {\n+                break;\n+            }\n+        }\n+\n+        while (!m_index.empty()) {\n+            // If time went backwards, we may need to demote CANDIDATE_BEST and CANDIDATE_READY entries back\n+            // to CANDIDATE_DELAYED. This is an unusual edge case, and unlikely to matter in production. However,\n+            // it makes it much easier to specify and test TxRequestTracker::Impl's behaviour.\n+            auto it = std::prev(m_index.get<ByTime>().end());\n+            if (it->IsSelectable() && it->m_time > now) {\n+                ChangeAndReselect(m_index.project<ByTxHash>(it), State::CANDIDATE_DELAYED);\n+            } else {\n+                break;\n+            }\n+        }\n+    }\n+\n+public:\n+    Impl(bool deterministic) :\n+        m_computer(deterministic),\n+        // Explicitly initialize m_index as we need to pass a reference to m_computer to EntryTxHashExtractor.\n+        m_index(boost::make_tuple(\n+            boost::make_tuple(\n+                boost::multi_index::const_mem_fun<Entry, EntryPeer, &Entry::ExtractPeer>(),\n+                std::less<EntryPeer>()\n+            ),\n+            boost::make_tuple(\n+                EntryTxHashExtractor(m_computer),\n+                std::less<EntryTxHash>()\n+            ),\n+            boost::make_tuple(\n+                boost::multi_index::const_mem_fun<Entry, EntryTime, &Entry::ExtractTime>(),\n+                std::less<EntryTime>()\n+            )\n+        )) {}\n+\n+\n+    // Disable copying and assigning (a default copy won't work due the stateful EntryTxHashExtractor).\n+    Impl(const Impl&) = delete;\n+    Impl& operator=(const Impl&) = delete;\n+\n+    void DeletedPeer(uint64_t peer)\n+    {\n+        auto& index = m_index.get<ByPeer>();\n+        auto it = index.lower_bound(EntryPeer{peer, false, UINT256_ZERO});\n+        while (it != index.end() && it->m_peer == peer) {\n+            // Check what to continue with after this iteration. Note that 'it' may change position, and\n+            // std::next(it) may be deleted in the process, so this needs to be decided beforehand.\n+            auto it_next = (std::next(it) == index.end() || std::next(it)->m_peer != peer) ?\n+                index.end() : std::next(it);\n+            // If the entry isn't already COMPLETED, first make it COMPLETED (which will mark other CANDIDATEs as\n+            // CANDIDATE_BEST, or delete all of a txid's entries if no non-COMPLETED ones are left).\n+            if (MakeCompleted(m_index.project<ByTxHash>(it))) {\n+                // Then actually delete the entry (unless it was already deleted by MakeCompleted).\n+                Erase<ByPeer>(it);\n+            }\n+            it = it_next;\n+        }\n+    }\n+\n+    void ForgetTx(const GenTxid& gtxid)\n+    {\n+        auto it = m_index.get<ByTxHash>().lower_bound(EntryTxHash{gtxid.GetHash(), State::CANDIDATE_DELAYED, 0});\n+        while (it != m_index.get<ByTxHash>().end() && it->m_txhash == gtxid.GetHash()) {\n+            it = Erase<ByTxHash>(it);\n+        }\n+    }\n+\n+    void ReceivedInv(uint64_t peer, const GenTxid& gtxid, bool preferred, bool overloaded,\n+        std::chrono::microseconds reqtime)\n+    {\n+        // Bail out if we already have a CANDIDATE_BEST entry for this (txid, peer) combination. The case where there is\n+        // a non-CANDIDATE_BEST entry already will be caught by the uniqueness property of the ByPeer index\n+        // automatically.\n+        if (m_index.get<ByPeer>().count(EntryPeer{peer, true, gtxid.GetHash()})) return;\n+\n+        // Find last entry for this txhash, and extract per_txhash information from it.\n+        uint8_t per_txhash = 0;\n+        typename Index::index<ByTxHash>::type::iterator it_last = m_index.get<ByTxHash>().end();\n+        // First find the first entry past this txhash.\n+        it_last = m_index.get<ByTxHash>().lower_bound(EntryTxHash{gtxid.GetHash(), State::TOO_LARGE, 0});\n+        if (it_last != m_index.get<ByTxHash>().begin() && std::prev(it_last)->m_txhash == gtxid.GetHash()) {\n+            // Its predecessor exists, and has the right txhash. Remember it, and OR in its flags.\n+            it_last--;\n+            per_txhash |= it_last->m_per_txhash;\n+        } else {\n+            // No entry for this txhash exists yet.\n+            it_last = m_index.get<ByTxHash>().end();\n+        }\n+\n+        // Determine whether the new announcement's Entry will get the first marker, and update\n+        // the per_txhash information to be stored (but note that per_txhash isn't actually stored\n+        // until after the emplace below succeeds).\n+        bool first = false;\n+        if (!overloaded) {\n+            if (preferred && !(per_txhash & TXHASHINFO_NO_MORE_PREFERRED_FIRST)) {\n+                first = true;\n+                per_txhash |= TXHASHINFO_NO_MORE_PREFERRED_FIRST;\n+            } else if (!preferred && !(per_txhash & TXHASHINFO_NO_MORE_NONPREFERRED_FIRST)) {\n+                first = true;\n+                per_txhash |= TXHASHINFO_NO_MORE_NONPREFERRED_FIRST;\n+            }\n+        }\n+\n+        // Try creating the entry with CANDIDATE_DELAYED state (which will fail due to the uniqueness\n+        // of the ByPeer index if a non-CANDIDATE_BEST entry already exists with the same txhash and peer).\n+        // Bail out in that case.\n+        auto ret = m_index.get<ByPeer>().emplace(gtxid, peer, preferred, reqtime, m_sequence, first);\n+        if (!ret.second) return;\n+\n+        // Update accounting metadata.\n+        ++m_peerinfo[peer].m_total;\n+        ++m_sequence;\n+\n+        // Update m_per_txhash of the new last Entry (either the newly created one, or it_last).\n+        auto it = m_index.project<ByTxHash>(ret.first);\n+        if (it_last == m_index.get<ByTxHash>().end() || std::next(it_last) == it) it_last = it;\n+        it_last->m_per_txhash |= per_txhash;\n+    }\n+\n+    //! Find the txids to request now from peer.\n+    std::vector<GenTxid> GetRequestable(uint64_t peer, std::chrono::microseconds now)\n+    {\n+        // Move time.\n+        SetTimePoint(now);\n+\n+        // Find all CANDIDATE_BEST entries for this peer.\n+        std::vector<std::pair<uint64_t, const Entry*>> selected;\n+        auto it_peer = m_index.get<ByPeer>().lower_bound(EntryPeer{peer, true, UINT256_ZERO});\n+        while (it_peer != m_index.get<ByPeer>().end() && it_peer->m_peer == peer &&\n+            it_peer->GetState() == State::CANDIDATE_BEST) {\n+            selected.emplace_back(it_peer->m_sequence, &*it_peer);\n+            ++it_peer;\n+        }\n+\n+        // Return them, sorted by sequence number.\n+        std::sort(selected.begin(), selected.end());\n+        std::vector<GenTxid> ret;\n+        for (const auto& item : selected) {\n+            ret.emplace_back(item.second->m_is_wtxid, item.second->m_txhash);\n+        }\n+        return ret;\n+    }\n+\n+    void RequestedTx(uint64_t peer, const GenTxid& gtxid, std::chrono::microseconds expiry)\n+    {\n+        auto it = m_index.get<ByPeer>().find(EntryPeer{peer, true, gtxid.GetHash()});\n+        // RequestedTx can only be called on CANDIDATE_BEST entries (this is implied by its condition that it can only be\n+        // called on txids returned by GetRequestable (and only AlreadyHave and RequestedTx can be called in between,\n+        // which preserve the state of other txids).\n+        assert(it != m_index.get<ByPeer>().end());\n+        assert(it->GetState() == State::CANDIDATE_BEST);\n+        Modify<ByPeer>(it, [expiry](Entry& entry) {\n+            entry.SetState(State::REQUESTED);\n+            entry.m_time = expiry;\n+        });\n+\n+        // Update the m_per_txhash (of the last Entry for this txhash) to reflect that new ones are no longer\n+        // eligible for the \"first\" marker.\n+        auto it_last = std::prev(m_index.get<ByTxHash>().lower_bound(EntryTxHash{gtxid.GetHash(), State::TOO_LARGE, 0}));\n+        assert(it_last->m_txhash == gtxid.GetHash());\n+        it_last->m_per_txhash |= TXHASHINFO_NO_MORE_PREFERRED_FIRST | TXHASHINFO_NO_MORE_NONPREFERRED_FIRST;\n+    }\n+\n+    void ReceivedResponse(uint64_t peer, const GenTxid& gtxid)\n+    {\n+        // We need to search the ByPeer index for both (peer, false, txid) and (peer, true, txid).\n+        auto it = m_index.get<ByPeer>().find(EntryPeer{peer, false, gtxid.GetHash()});\n+        if (it == m_index.get<ByPeer>().end()) {\n+            it = m_index.get<ByPeer>().find(EntryPeer{peer, true, gtxid.GetHash()});\n+        }\n+        if (it != m_index.get<ByPeer>().end()) MakeCompleted(m_index.project<ByTxHash>(it));\n+    }\n+\n+    size_t CountInFlight(uint64_t peer) const\n+    {\n+        auto it = m_peerinfo.find(peer);\n+        if (it != m_peerinfo.end()) return it->second.m_requested;\n+        return 0;\n+    }\n+\n+    size_t CountTracked(uint64_t peer) const\n+    {\n+        auto it = m_peerinfo.find(peer);\n+        if (it != m_peerinfo.end()) return it->second.m_total;\n+        return 0;\n+    }\n+\n+    //! Count how many announcements are being tracked in total across all peers and transactions.\n+    size_t Size() const { return m_index.size(); }\n+\n+    //! Access to the internal PriorityComputer (for testing)\n+    const PriorityComputer& GetPriorityComputer() const { return m_computer; }\n+\n+    void SanityCheck() const\n+    {\n+        // Recompute m_peerdata.\n+        // This verifies the data in it, including the invariant\n+        // that no entries with m_total_announcements==0 exist.\n+        std::unordered_map<uint64_t, PeerInfo> peerinfo;\n+        for (const auto& a : m_index) {\n+            auto& entry = peerinfo[a.m_peer];\n+            ++entry.m_total;\n+            entry.m_requested += (a.GetState() == State::REQUESTED);\n+        }\n+        assert(m_peerinfo == peerinfo);\n+\n+        struct Counts {\n+            //! Number of CANDIDATE_DELAYED entries for this txhash.\n+            size_t m_candidate_delayed = 0;\n+            //! Number of CANDIDATE_READY entries for this txhash.\n+            size_t m_candidate_ready = 0;\n+            //! Number of CANDIDATE_BEST entries for this txhash (at most one).\n+            size_t m_candidate_best = 0;\n+            //! Number of REQUESTED entries for this txhash.\n+            size_t m_requested = 0;\n+            //! The priority of the CANDIDATE_BEST entry if one exists, or 0 otherwise.\n+            uint64_t m_priority_candidate_best = 0;\n+            //! The lowest priority of all CANDIDATE_READY entries (or max() if none exist).\n+            uint64_t m_priority_best_candidate_ready = std::numeric_limits<uint64_t>::max();\n+            //! All peers we have an entry for this txhash for.\n+            std::vector<uint64_t> m_peers;\n+            //! Whether any preferred first entry exists.\n+            bool m_any_preferred_first = false;\n+            //! Whether any non-preferred first entry exists.\n+            bool m_any_nonpreferred_first = false;\n+            //! OR of all m_per_txhash flags.\n+            uint8_t m_or_all_per_txhash = 0;\n+        };\n+\n+        std::map<uint256, Counts> table;\n+        for (const auto& a : m_index) {\n+            auto& entry = table[a.m_txhash];\n+            // Classify how many types peers we have for this txid.\n+            entry.m_candidate_delayed += (a.GetState() == State::CANDIDATE_DELAYED);\n+            entry.m_candidate_ready += (a.GetState() == State::CANDIDATE_READY);\n+            entry.m_candidate_best += (a.GetState() == State::CANDIDATE_BEST);\n+            entry.m_requested += (a.GetState() == State::REQUESTED);\n+            // And track the priority of the best CANDIDATE_READY/CANDIDATE_BEST entries.\n+            if (a.GetState() == State::CANDIDATE_BEST) {\n+                entry.m_priority_candidate_best = a.ComputePriority(m_computer);\n+            }\n+            if (a.GetState() == State::CANDIDATE_READY) {\n+                entry.m_priority_best_candidate_ready = std::min(entry.m_priority_best_candidate_ready,\n+                    a.ComputePriority(m_computer));\n+            }\n+            // Also keep track of which peers this txid has an entry for (so we can detect duplicates).\n+            entry.m_peers.push_back(a.m_peer);\n+            // Track preferred/first.\n+            entry.m_any_preferred_first |= (a.m_first && a.m_preferred);\n+            entry.m_any_nonpreferred_first |= (a.m_first && !a.m_preferred);\n+            entry.m_or_all_per_txhash |= a.m_per_txhash;\n+        }\n+        for (auto& entry : table) {\n+            auto& c = entry.second;\n+            // Cannot have only COMPLETED peers (txid should have been deleted)\n+            assert(c.m_candidate_delayed + c.m_candidate_ready + c.m_candidate_best + c.m_requested > 0);\n+            // Can have at most 1 CANDIDATE_BEST/REQUESTED peer\n+            assert(c.m_candidate_best + c.m_requested <= 1);\n+            // If there are any CANDIDATE_READY entries, there must be exactly one CANDIDATE_BEST or REQUESTED\n+            // entry.\n+            if (c.m_candidate_ready > 0) {\n+                assert(c.m_candidate_best + c.m_requested == 1);\n+            }\n+            // If there is both a CANDIDATE_READY and a CANDIDATE_BEST entry, the CANDIDATE_BEST one must be at\n+            // least as good as the best CANDIDATE_READY.\n+            if (c.m_candidate_ready && c.m_candidate_best) {\n+                assert(c.m_priority_candidate_best <= c.m_priority_best_candidate_ready);\n+            }\n+            // Detect duplicate (peer, txid) entries\n+            std::sort(c.m_peers.begin(), c.m_peers.end());\n+            assert(std::adjacent_find(c.m_peers.begin(), c.m_peers.end()) == c.m_peers.end());\n+            // Verify all per_txhash flags.\n+            uint8_t expected_per_txhash = 0;\n+            if (c.m_any_preferred_first || c.m_requested) {\n+                expected_per_txhash |= TXHASHINFO_NO_MORE_PREFERRED_FIRST;\n+            }\n+            if (c.m_any_nonpreferred_first || c.m_requested) {\n+                expected_per_txhash |= TXHASHINFO_NO_MORE_NONPREFERRED_FIRST;\n+            }\n+            // All expected flags must be present, but there can be more. If a node went from REQUESTED to\n+            // COMPLETED, or was deleted, our expected_per_txhash may miss the relevant bits.\n+            assert((expected_per_txhash & ~c.m_or_all_per_txhash) == 0);\n+            // No entry can have flags that are a superset of the actual ones (they're always ORed into the actual\n+            // one).\n+            auto it_last = std::prev(m_index.get<ByTxHash>().lower_bound(\n+                EntryTxHash{entry.first, State::TOO_LARGE, 0}));\n+            assert(it_last->m_txhash == entry.first);\n+            assert(c.m_or_all_per_txhash == it_last->m_per_txhash);\n+        }\n+    }\n+\n+    void PostGetRequestableSanityCheck(std::chrono::microseconds now) const\n+    {\n+        for (const auto& entry : m_index) {\n+            if (entry.IsWaiting()) {\n+                // REQUESTED and CANDIDATE_DELAYED must have a time in the future (they should have been converted\n+                // to COMPLETED/CANDIDATE_READY respectively).\n+                assert(entry.m_time > now);\n+            } else if (entry.IsSelectable()) {\n+                // CANDIDATE_READY and CANDIDATE_BEST cannot have a time in the future (they should have remained\n+                // CANDIDATE_DELAYED, or should have been converted back to it if time went backwards).\n+                assert(entry.m_time <= now);\n+            }\n+        }\n+    }\n+};\n+\n+TxRequestTracker::TxRequestTracker(bool deterministic)\n+{\n+    m_impl = MakeUnique<TxRequestTracker::Impl>(deterministic);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494348645",
      "id" : 494348645,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDM0ODY0NQ==",
      "original_commit_id" : "7949d08406774f27fd0291c2aa046ecdf985c191",
      "original_line" : 673,
      "original_position" : 673,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : null,
      "pull_request_review_id" : 495579753,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-24T17:33:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494348645",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494469813"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494469813"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`Deleted`(past tense) is a bit weird since it's actually deleting the peer.\r\n\r\nAt a risk of making it too verbose via self-documenting:\r\n`DeletePeerEntries`?\r\n\r\nAlternatively we can name it like some of the other functions e.g. `ReceivedInv` et. al:\r\n`DisconnectedPeer` describing when it's to be called and leaving the first sentence in the comment.",
      "commit_id" : "4508a6e58d28eb5436031861aca1a43b76156097",
      "created_at" : "2020-09-24T16:55:02Z",
      "diff_hunk" : "@@ -0,0 +1,213 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not (which peers are preferred is determined by the caller, but this is\n+ *   designed for outbound peers, or other peers that we have a higher level of trust in).\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see '\"First\" marker rules').\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the transaction was forgotten in\n+ *   between (see next point), and re-announced.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening invblock attacks. The flip side is that as long as an attacker manages to prevent\n+ *              us from receiving a transaction, failed announcements (including those from honest peers) will\n+ *              linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on\n+ *              the number of tracked announcements per peer.\n+ *              See https://allquantor.at/blockchainbib/pdf/miller2015topology.pdf for information on invblocking.\n+ *\n+ * - Announcements are only forgotten about when the peer that announced them went offline, when the transaction\n+ *   was received successfully, or when no candidates for a transaction remain that haven't been tried already.\n+ *\n+ *   Rationale: we need to eventually forget announcements to keep memory bounded, but as long as viable\n+ *              candidate peers remain, we prefer to avoid fetching from failed ones. As every request has a finite\n+ *              timeout and we schedule new request as soon a previous one expired, there is always progress being\n+ *              made towards forgetting a transaction - either successfully or unsuccessfully.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable net_processing code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers (outbound, whitelisted) are chosen by us, so are less likely to be under attacker\n+ *                control.\n+ *\n+ *   - Among the remaining candidates, choose the one with the \"first\" marker if one exists (there can be at most\n+ *     one such peer, see further).\n+ *\n+ *     Rationale: in non-attack scenarios we want to give one chance to request from the fastest peer to reduce\n+ *                latency, and reduce risk of breaking chains of dependent transactions. An attacker who races the\n+ *                network can exploit this to delay us learning about a transaction, but it is available only once\n+ *                per txhash.\n+ *\n+ *   - If no remaining candidates have the \"first\" marker, pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: if the \"first\" mechanism failed, random assignments are hard to influence for attackers.\n+ *\n+ * \"First\" marker rules: the \"first\" marker is given to announcements for which at the time of announcement:\n+ * - No requests for its txhash have been attempted (ever, or since it was forgotten about).\n+ * - The peer that announced them was not overloaded.\n+ * - No announcement for the same txhash from another peer within the same preferred/nonpreferred class already has\n+ *   the first marker already.\n+ *\n+ *   Rationale: these restrictions avoid giving the speed benefit to honest but overloaded peers, and also\n+ *              reduce the extent to which attackers that race the network in announcing all transactions\n+ *              can break chains of dependent transactions.\n+ *\n+ * Together these rules strike a balance between being fast in non-adverserial conditions and avoiding influenceable\n+ * by attackers. An invblocking attacker that races the network:\n+ * - Will be unsuccessful if all preferred connections are honest (and there is at least one).\n+ * - If there are P preferred connections of which Ph>=1 are honest, the attacker can delay us from learning\n+ *   about a transaction by k expiration periods, where k ~ 1 + NHG(N=P-1,K=P-Ph-1,r=1), which has mean\n+ *   P/(Ph+1) (where NHG stands for Negative Hypergeometric distribution).\n+ * - If all P preferred connections are to the attacker, and there are NP non-preferred connections of which NPh are\n+ *   honest, k ~ P + 1 + NHG(N=NP-1,K=NP-NPh-1,r=1), with mean P + NP/(NPh+1).\n+ *\n+ * Complexity:\n+ * - Memory usage is proportional to the total number of tracked announcements (Size()) plus the number of\n+ *   peers with a nonzero number of tracked announcements.\n+ * - CPU usage is generally logarithmic in the total number of tracked announcements, plus the number of\n+ *   announcements affected by an operation (amortized O(1) per announcement).\n+ */\n+class TxRequestTracker {\n+public:\n+    /** A functor with embedded salt that computes priority of a txhash/peer combination. Lower priorities are\n+     *  selected first. */\n+    class PriorityComputer {\n+        const uint64_t m_k0, m_k1;\n+    public:\n+        explicit PriorityComputer(bool deterministic);\n+        uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred, bool first) const;\n+    };\n+\n+private:\n+    // Avoid littering this header file with implementation details.\n+    class Impl;\n+    std::unique_ptr<Impl> m_impl;\n+\n+public:\n+    //! Construct a TxRequestTracker.\n+    TxRequestTracker(bool deterministic = false);\n+    ~TxRequestTracker();\n+\n+    // Conceptually, the data structure consists of a collection of entries, one for each peer/txhash combination\n+    // (an \"announcement\"):\n+    //\n+    // - CANDIDATE entries represent transactions that were announced by a peer, and that become available for\n+    //   download after their reqtime has passed.\n+    //\n+    // - REQUESTED entries represent transactions that have been requested, and which we're awaiting a response for\n+    //   from that peer. Their expiry value determines when the request times out.\n+    //\n+    // - COMPLETED entries represent transactions that have been requested from a peer, but they timed out, a\n+    //   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to\n+    //   prevent requesting them again. If only COMPLETED entries for a given txhash remain (so no CANDIDATE or\n+    //   REQUESTED ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+    //\n+    // The operations below manipulate the data structure.\n+\n+    /** Deletes all entries for a given peer.\n+     *\n+     * It should be called when a peer goes offline.\n+     */\n+    void DeletedPeer(uint64_t peer);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494469813",
      "id" : 494469813,
      "line" : 138,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQ2OTgxMw==",
      "original_commit_id" : "164f50402475175d6fc839ae2798817e8da7c68f",
      "original_line" : 138,
      "original_position" : 149,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 138,
      "pull_request_review_id" : 495769842,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-24T17:40:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494469813",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494471997"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494471997"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```suggestion\r\n     * whatever reason we no longer care about it. Only the hash field of gtxid is used.\r\n```",
      "commit_id" : "4508a6e58d28eb5436031861aca1a43b76156097",
      "created_at" : "2020-09-24T16:58:35Z",
      "diff_hunk" : "@@ -0,0 +1,213 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not (which peers are preferred is determined by the caller, but this is\n+ *   designed for outbound peers, or other peers that we have a higher level of trust in).\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see '\"First\" marker rules').\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the transaction was forgotten in\n+ *   between (see next point), and re-announced.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening invblock attacks. The flip side is that as long as an attacker manages to prevent\n+ *              us from receiving a transaction, failed announcements (including those from honest peers) will\n+ *              linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on\n+ *              the number of tracked announcements per peer.\n+ *              See https://allquantor.at/blockchainbib/pdf/miller2015topology.pdf for information on invblocking.\n+ *\n+ * - Announcements are only forgotten about when the peer that announced them went offline, when the transaction\n+ *   was received successfully, or when no candidates for a transaction remain that haven't been tried already.\n+ *\n+ *   Rationale: we need to eventually forget announcements to keep memory bounded, but as long as viable\n+ *              candidate peers remain, we prefer to avoid fetching from failed ones. As every request has a finite\n+ *              timeout and we schedule new request as soon a previous one expired, there is always progress being\n+ *              made towards forgetting a transaction - either successfully or unsuccessfully.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable net_processing code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers (outbound, whitelisted) are chosen by us, so are less likely to be under attacker\n+ *                control.\n+ *\n+ *   - Among the remaining candidates, choose the one with the \"first\" marker if one exists (there can be at most\n+ *     one such peer, see further).\n+ *\n+ *     Rationale: in non-attack scenarios we want to give one chance to request from the fastest peer to reduce\n+ *                latency, and reduce risk of breaking chains of dependent transactions. An attacker who races the\n+ *                network can exploit this to delay us learning about a transaction, but it is available only once\n+ *                per txhash.\n+ *\n+ *   - If no remaining candidates have the \"first\" marker, pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: if the \"first\" mechanism failed, random assignments are hard to influence for attackers.\n+ *\n+ * \"First\" marker rules: the \"first\" marker is given to announcements for which at the time of announcement:\n+ * - No requests for its txhash have been attempted (ever, or since it was forgotten about).\n+ * - The peer that announced them was not overloaded.\n+ * - No announcement for the same txhash from another peer within the same preferred/nonpreferred class already has\n+ *   the first marker already.\n+ *\n+ *   Rationale: these restrictions avoid giving the speed benefit to honest but overloaded peers, and also\n+ *              reduce the extent to which attackers that race the network in announcing all transactions\n+ *              can break chains of dependent transactions.\n+ *\n+ * Together these rules strike a balance between being fast in non-adverserial conditions and avoiding influenceable\n+ * by attackers. An invblocking attacker that races the network:\n+ * - Will be unsuccessful if all preferred connections are honest (and there is at least one).\n+ * - If there are P preferred connections of which Ph>=1 are honest, the attacker can delay us from learning\n+ *   about a transaction by k expiration periods, where k ~ 1 + NHG(N=P-1,K=P-Ph-1,r=1), which has mean\n+ *   P/(Ph+1) (where NHG stands for Negative Hypergeometric distribution).\n+ * - If all P preferred connections are to the attacker, and there are NP non-preferred connections of which NPh are\n+ *   honest, k ~ P + 1 + NHG(N=NP-1,K=NP-NPh-1,r=1), with mean P + NP/(NPh+1).\n+ *\n+ * Complexity:\n+ * - Memory usage is proportional to the total number of tracked announcements (Size()) plus the number of\n+ *   peers with a nonzero number of tracked announcements.\n+ * - CPU usage is generally logarithmic in the total number of tracked announcements, plus the number of\n+ *   announcements affected by an operation (amortized O(1) per announcement).\n+ */\n+class TxRequestTracker {\n+public:\n+    /** A functor with embedded salt that computes priority of a txhash/peer combination. Lower priorities are\n+     *  selected first. */\n+    class PriorityComputer {\n+        const uint64_t m_k0, m_k1;\n+    public:\n+        explicit PriorityComputer(bool deterministic);\n+        uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred, bool first) const;\n+    };\n+\n+private:\n+    // Avoid littering this header file with implementation details.\n+    class Impl;\n+    std::unique_ptr<Impl> m_impl;\n+\n+public:\n+    //! Construct a TxRequestTracker.\n+    TxRequestTracker(bool deterministic = false);\n+    ~TxRequestTracker();\n+\n+    // Conceptually, the data structure consists of a collection of entries, one for each peer/txhash combination\n+    // (an \"announcement\"):\n+    //\n+    // - CANDIDATE entries represent transactions that were announced by a peer, and that become available for\n+    //   download after their reqtime has passed.\n+    //\n+    // - REQUESTED entries represent transactions that have been requested, and which we're awaiting a response for\n+    //   from that peer. Their expiry value determines when the request times out.\n+    //\n+    // - COMPLETED entries represent transactions that have been requested from a peer, but they timed out, a\n+    //   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to\n+    //   prevent requesting them again. If only COMPLETED entries for a given txhash remain (so no CANDIDATE or\n+    //   REQUESTED ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+    //\n+    // The operations below manipulate the data structure.\n+\n+    /** Deletes all entries for a given peer.\n+     *\n+     * It should be called when a peer goes offline.\n+     */\n+    void DeletedPeer(uint64_t peer);\n+\n+    /** Deletes all entries for a given txhash.\n+     *\n+     * This should be called when a transaction is successfully added to the mempool, seen in a block, or for\n+     * whatever reason we no longer care about it. The is_wtxid flag of gtxid is ignored.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494471997",
      "id" : 494471997,
      "line" : 143,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQ3MTk5Nw==",
      "original_commit_id" : "164f50402475175d6fc839ae2798817e8da7c68f",
      "original_line" : 143,
      "original_position" : 154,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 143,
      "pull_request_review_id" : 495769842,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-24T17:40:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494471997",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494473828"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494473828"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Maybe talk about what it's used for instead of what it's not, or just change the interface to make it clear.",
      "commit_id" : "4508a6e58d28eb5436031861aca1a43b76156097",
      "created_at" : "2020-09-24T17:01:38Z",
      "diff_hunk" : "@@ -0,0 +1,213 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not (which peers are preferred is determined by the caller, but this is\n+ *   designed for outbound peers, or other peers that we have a higher level of trust in).\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see '\"First\" marker rules').\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the transaction was forgotten in\n+ *   between (see next point), and re-announced.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening invblock attacks. The flip side is that as long as an attacker manages to prevent\n+ *              us from receiving a transaction, failed announcements (including those from honest peers) will\n+ *              linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on\n+ *              the number of tracked announcements per peer.\n+ *              See https://allquantor.at/blockchainbib/pdf/miller2015topology.pdf for information on invblocking.\n+ *\n+ * - Announcements are only forgotten about when the peer that announced them went offline, when the transaction\n+ *   was received successfully, or when no candidates for a transaction remain that haven't been tried already.\n+ *\n+ *   Rationale: we need to eventually forget announcements to keep memory bounded, but as long as viable\n+ *              candidate peers remain, we prefer to avoid fetching from failed ones. As every request has a finite\n+ *              timeout and we schedule new request as soon a previous one expired, there is always progress being\n+ *              made towards forgetting a transaction - either successfully or unsuccessfully.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable net_processing code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers (outbound, whitelisted) are chosen by us, so are less likely to be under attacker\n+ *                control.\n+ *\n+ *   - Among the remaining candidates, choose the one with the \"first\" marker if one exists (there can be at most\n+ *     one such peer, see further).\n+ *\n+ *     Rationale: in non-attack scenarios we want to give one chance to request from the fastest peer to reduce\n+ *                latency, and reduce risk of breaking chains of dependent transactions. An attacker who races the\n+ *                network can exploit this to delay us learning about a transaction, but it is available only once\n+ *                per txhash.\n+ *\n+ *   - If no remaining candidates have the \"first\" marker, pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: if the \"first\" mechanism failed, random assignments are hard to influence for attackers.\n+ *\n+ * \"First\" marker rules: the \"first\" marker is given to announcements for which at the time of announcement:\n+ * - No requests for its txhash have been attempted (ever, or since it was forgotten about).\n+ * - The peer that announced them was not overloaded.\n+ * - No announcement for the same txhash from another peer within the same preferred/nonpreferred class already has\n+ *   the first marker already.\n+ *\n+ *   Rationale: these restrictions avoid giving the speed benefit to honest but overloaded peers, and also\n+ *              reduce the extent to which attackers that race the network in announcing all transactions\n+ *              can break chains of dependent transactions.\n+ *\n+ * Together these rules strike a balance between being fast in non-adverserial conditions and avoiding influenceable\n+ * by attackers. An invblocking attacker that races the network:\n+ * - Will be unsuccessful if all preferred connections are honest (and there is at least one).\n+ * - If there are P preferred connections of which Ph>=1 are honest, the attacker can delay us from learning\n+ *   about a transaction by k expiration periods, where k ~ 1 + NHG(N=P-1,K=P-Ph-1,r=1), which has mean\n+ *   P/(Ph+1) (where NHG stands for Negative Hypergeometric distribution).\n+ * - If all P preferred connections are to the attacker, and there are NP non-preferred connections of which NPh are\n+ *   honest, k ~ P + 1 + NHG(N=NP-1,K=NP-NPh-1,r=1), with mean P + NP/(NPh+1).\n+ *\n+ * Complexity:\n+ * - Memory usage is proportional to the total number of tracked announcements (Size()) plus the number of\n+ *   peers with a nonzero number of tracked announcements.\n+ * - CPU usage is generally logarithmic in the total number of tracked announcements, plus the number of\n+ *   announcements affected by an operation (amortized O(1) per announcement).\n+ */\n+class TxRequestTracker {\n+public:\n+    /** A functor with embedded salt that computes priority of a txhash/peer combination. Lower priorities are\n+     *  selected first. */\n+    class PriorityComputer {\n+        const uint64_t m_k0, m_k1;\n+    public:\n+        explicit PriorityComputer(bool deterministic);\n+        uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred, bool first) const;\n+    };\n+\n+private:\n+    // Avoid littering this header file with implementation details.\n+    class Impl;\n+    std::unique_ptr<Impl> m_impl;\n+\n+public:\n+    //! Construct a TxRequestTracker.\n+    TxRequestTracker(bool deterministic = false);\n+    ~TxRequestTracker();\n+\n+    // Conceptually, the data structure consists of a collection of entries, one for each peer/txhash combination\n+    // (an \"announcement\"):\n+    //\n+    // - CANDIDATE entries represent transactions that were announced by a peer, and that become available for\n+    //   download after their reqtime has passed.\n+    //\n+    // - REQUESTED entries represent transactions that have been requested, and which we're awaiting a response for\n+    //   from that peer. Their expiry value determines when the request times out.\n+    //\n+    // - COMPLETED entries represent transactions that have been requested from a peer, but they timed out, a\n+    //   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to\n+    //   prevent requesting them again. If only COMPLETED entries for a given txhash remain (so no CANDIDATE or\n+    //   REQUESTED ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+    //\n+    // The operations below manipulate the data structure.\n+\n+    /** Deletes all entries for a given peer.\n+     *\n+     * It should be called when a peer goes offline.\n+     */\n+    void DeletedPeer(uint64_t peer);\n+\n+    /** Deletes all entries for a given txhash.\n+     *\n+     * This should be called when a transaction is successfully added to the mempool, seen in a block, or for\n+     * whatever reason we no longer care about it. The is_wtxid flag of gtxid is ignored.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494473828",
      "id" : 494473828,
      "in_reply_to_id" : 494471997,
      "line" : 143,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQ3MzgyOA==",
      "original_commit_id" : "164f50402475175d6fc839ae2798817e8da7c68f",
      "original_line" : 143,
      "original_position" : 154,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 143,
      "pull_request_review_id" : 495769842,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-24T17:40:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494473828",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494477588"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494477588"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`COMPLETED` sounds more like `FAILED`.\r\n\r\n`COMPLETED` is also hit when the transaction is received properly, no?",
      "commit_id" : "4508a6e58d28eb5436031861aca1a43b76156097",
      "created_at" : "2020-09-24T17:08:07Z",
      "diff_hunk" : "@@ -0,0 +1,213 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not (which peers are preferred is determined by the caller, but this is\n+ *   designed for outbound peers, or other peers that we have a higher level of trust in).\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see '\"First\" marker rules').\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the transaction was forgotten in\n+ *   between (see next point), and re-announced.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening invblock attacks. The flip side is that as long as an attacker manages to prevent\n+ *              us from receiving a transaction, failed announcements (including those from honest peers) will\n+ *              linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on\n+ *              the number of tracked announcements per peer.\n+ *              See https://allquantor.at/blockchainbib/pdf/miller2015topology.pdf for information on invblocking.\n+ *\n+ * - Announcements are only forgotten about when the peer that announced them went offline, when the transaction\n+ *   was received successfully, or when no candidates for a transaction remain that haven't been tried already.\n+ *\n+ *   Rationale: we need to eventually forget announcements to keep memory bounded, but as long as viable\n+ *              candidate peers remain, we prefer to avoid fetching from failed ones. As every request has a finite\n+ *              timeout and we schedule new request as soon a previous one expired, there is always progress being\n+ *              made towards forgetting a transaction - either successfully or unsuccessfully.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable net_processing code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers (outbound, whitelisted) are chosen by us, so are less likely to be under attacker\n+ *                control.\n+ *\n+ *   - Among the remaining candidates, choose the one with the \"first\" marker if one exists (there can be at most\n+ *     one such peer, see further).\n+ *\n+ *     Rationale: in non-attack scenarios we want to give one chance to request from the fastest peer to reduce\n+ *                latency, and reduce risk of breaking chains of dependent transactions. An attacker who races the\n+ *                network can exploit this to delay us learning about a transaction, but it is available only once\n+ *                per txhash.\n+ *\n+ *   - If no remaining candidates have the \"first\" marker, pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: if the \"first\" mechanism failed, random assignments are hard to influence for attackers.\n+ *\n+ * \"First\" marker rules: the \"first\" marker is given to announcements for which at the time of announcement:\n+ * - No requests for its txhash have been attempted (ever, or since it was forgotten about).\n+ * - The peer that announced them was not overloaded.\n+ * - No announcement for the same txhash from another peer within the same preferred/nonpreferred class already has\n+ *   the first marker already.\n+ *\n+ *   Rationale: these restrictions avoid giving the speed benefit to honest but overloaded peers, and also\n+ *              reduce the extent to which attackers that race the network in announcing all transactions\n+ *              can break chains of dependent transactions.\n+ *\n+ * Together these rules strike a balance between being fast in non-adverserial conditions and avoiding influenceable\n+ * by attackers. An invblocking attacker that races the network:\n+ * - Will be unsuccessful if all preferred connections are honest (and there is at least one).\n+ * - If there are P preferred connections of which Ph>=1 are honest, the attacker can delay us from learning\n+ *   about a transaction by k expiration periods, where k ~ 1 + NHG(N=P-1,K=P-Ph-1,r=1), which has mean\n+ *   P/(Ph+1) (where NHG stands for Negative Hypergeometric distribution).\n+ * - If all P preferred connections are to the attacker, and there are NP non-preferred connections of which NPh are\n+ *   honest, k ~ P + 1 + NHG(N=NP-1,K=NP-NPh-1,r=1), with mean P + NP/(NPh+1).\n+ *\n+ * Complexity:\n+ * - Memory usage is proportional to the total number of tracked announcements (Size()) plus the number of\n+ *   peers with a nonzero number of tracked announcements.\n+ * - CPU usage is generally logarithmic in the total number of tracked announcements, plus the number of\n+ *   announcements affected by an operation (amortized O(1) per announcement).\n+ */\n+class TxRequestTracker {\n+public:\n+    /** A functor with embedded salt that computes priority of a txhash/peer combination. Lower priorities are\n+     *  selected first. */\n+    class PriorityComputer {\n+        const uint64_t m_k0, m_k1;\n+    public:\n+        explicit PriorityComputer(bool deterministic);\n+        uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred, bool first) const;\n+    };\n+\n+private:\n+    // Avoid littering this header file with implementation details.\n+    class Impl;\n+    std::unique_ptr<Impl> m_impl;\n+\n+public:\n+    //! Construct a TxRequestTracker.\n+    TxRequestTracker(bool deterministic = false);\n+    ~TxRequestTracker();\n+\n+    // Conceptually, the data structure consists of a collection of entries, one for each peer/txhash combination\n+    // (an \"announcement\"):\n+    //\n+    // - CANDIDATE entries represent transactions that were announced by a peer, and that become available for\n+    //   download after their reqtime has passed.\n+    //\n+    // - REQUESTED entries represent transactions that have been requested, and which we're awaiting a response for\n+    //   from that peer. Their expiry value determines when the request times out.\n+    //\n+    // - COMPLETED entries represent transactions that have been requested from a peer, but they timed out, a",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494477588",
      "id" : 494477588,
      "line" : 127,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQ3NzU4OA==",
      "original_commit_id" : "164f50402475175d6fc839ae2798817e8da7c68f",
      "original_line" : 127,
      "original_position" : 138,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 127,
      "pull_request_review_id" : 495769842,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-24T17:40:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494477588",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494485317"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494485317"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```suggestion\r\n    std::vector<GenTxid> ExpireReqestedAndGetRequestable(uint64_t peer, std::chrono::microseconds now);\r\n```\r\n\r\nto make it less reliant on comments for intent",
      "commit_id" : "4508a6e58d28eb5436031861aca1a43b76156097",
      "created_at" : "2020-09-24T17:20:59Z",
      "diff_hunk" : "@@ -0,0 +1,213 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not (which peers are preferred is determined by the caller, but this is\n+ *   designed for outbound peers, or other peers that we have a higher level of trust in).\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see '\"First\" marker rules').\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the transaction was forgotten in\n+ *   between (see next point), and re-announced.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening invblock attacks. The flip side is that as long as an attacker manages to prevent\n+ *              us from receiving a transaction, failed announcements (including those from honest peers) will\n+ *              linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on\n+ *              the number of tracked announcements per peer.\n+ *              See https://allquantor.at/blockchainbib/pdf/miller2015topology.pdf for information on invblocking.\n+ *\n+ * - Announcements are only forgotten about when the peer that announced them went offline, when the transaction\n+ *   was received successfully, or when no candidates for a transaction remain that haven't been tried already.\n+ *\n+ *   Rationale: we need to eventually forget announcements to keep memory bounded, but as long as viable\n+ *              candidate peers remain, we prefer to avoid fetching from failed ones. As every request has a finite\n+ *              timeout and we schedule new request as soon a previous one expired, there is always progress being\n+ *              made towards forgetting a transaction - either successfully or unsuccessfully.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable net_processing code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers (outbound, whitelisted) are chosen by us, so are less likely to be under attacker\n+ *                control.\n+ *\n+ *   - Among the remaining candidates, choose the one with the \"first\" marker if one exists (there can be at most\n+ *     one such peer, see further).\n+ *\n+ *     Rationale: in non-attack scenarios we want to give one chance to request from the fastest peer to reduce\n+ *                latency, and reduce risk of breaking chains of dependent transactions. An attacker who races the\n+ *                network can exploit this to delay us learning about a transaction, but it is available only once\n+ *                per txhash.\n+ *\n+ *   - If no remaining candidates have the \"first\" marker, pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: if the \"first\" mechanism failed, random assignments are hard to influence for attackers.\n+ *\n+ * \"First\" marker rules: the \"first\" marker is given to announcements for which at the time of announcement:\n+ * - No requests for its txhash have been attempted (ever, or since it was forgotten about).\n+ * - The peer that announced them was not overloaded.\n+ * - No announcement for the same txhash from another peer within the same preferred/nonpreferred class already has\n+ *   the first marker already.\n+ *\n+ *   Rationale: these restrictions avoid giving the speed benefit to honest but overloaded peers, and also\n+ *              reduce the extent to which attackers that race the network in announcing all transactions\n+ *              can break chains of dependent transactions.\n+ *\n+ * Together these rules strike a balance between being fast in non-adverserial conditions and avoiding influenceable\n+ * by attackers. An invblocking attacker that races the network:\n+ * - Will be unsuccessful if all preferred connections are honest (and there is at least one).\n+ * - If there are P preferred connections of which Ph>=1 are honest, the attacker can delay us from learning\n+ *   about a transaction by k expiration periods, where k ~ 1 + NHG(N=P-1,K=P-Ph-1,r=1), which has mean\n+ *   P/(Ph+1) (where NHG stands for Negative Hypergeometric distribution).\n+ * - If all P preferred connections are to the attacker, and there are NP non-preferred connections of which NPh are\n+ *   honest, k ~ P + 1 + NHG(N=NP-1,K=NP-NPh-1,r=1), with mean P + NP/(NPh+1).\n+ *\n+ * Complexity:\n+ * - Memory usage is proportional to the total number of tracked announcements (Size()) plus the number of\n+ *   peers with a nonzero number of tracked announcements.\n+ * - CPU usage is generally logarithmic in the total number of tracked announcements, plus the number of\n+ *   announcements affected by an operation (amortized O(1) per announcement).\n+ */\n+class TxRequestTracker {\n+public:\n+    /** A functor with embedded salt that computes priority of a txhash/peer combination. Lower priorities are\n+     *  selected first. */\n+    class PriorityComputer {\n+        const uint64_t m_k0, m_k1;\n+    public:\n+        explicit PriorityComputer(bool deterministic);\n+        uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred, bool first) const;\n+    };\n+\n+private:\n+    // Avoid littering this header file with implementation details.\n+    class Impl;\n+    std::unique_ptr<Impl> m_impl;\n+\n+public:\n+    //! Construct a TxRequestTracker.\n+    TxRequestTracker(bool deterministic = false);\n+    ~TxRequestTracker();\n+\n+    // Conceptually, the data structure consists of a collection of entries, one for each peer/txhash combination\n+    // (an \"announcement\"):\n+    //\n+    // - CANDIDATE entries represent transactions that were announced by a peer, and that become available for\n+    //   download after their reqtime has passed.\n+    //\n+    // - REQUESTED entries represent transactions that have been requested, and which we're awaiting a response for\n+    //   from that peer. Their expiry value determines when the request times out.\n+    //\n+    // - COMPLETED entries represent transactions that have been requested from a peer, but they timed out, a\n+    //   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to\n+    //   prevent requesting them again. If only COMPLETED entries for a given txhash remain (so no CANDIDATE or\n+    //   REQUESTED ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+    //\n+    // The operations below manipulate the data structure.\n+\n+    /** Deletes all entries for a given peer.\n+     *\n+     * It should be called when a peer goes offline.\n+     */\n+    void DeletedPeer(uint64_t peer);\n+\n+    /** Deletes all entries for a given txhash.\n+     *\n+     * This should be called when a transaction is successfully added to the mempool, seen in a block, or for\n+     * whatever reason we no longer care about it. The is_wtxid flag of gtxid is ignored.\n+     */\n+    void ForgetTx(const GenTxid& gtxid);\n+\n+    /** Adds a new CANDIDATE entry.\n+     *\n+     * Does nothing if one already exists for that (txhash, peer) combination (whether it's CANDIDATE, REQUESTED, or\n+     * COMPLETED). Note that this means a second INV with the same txhash from the same peer will be ignored, even\n+     * if one is a txid and the other is wtxid (but that shouldn't happen, as BIP339 requires that all announced\n+     * inventory is exclusively using MSG_WTX). The new entry is given the specified preferred and reqtime values,\n+     * and takes it is_wtxid from the specified gtxid. It is eligible to get a first marker if overloaded is false\n+     * (but also subject to the other rules regarding the first marker).\n+     */\n+    void ReceivedInv(uint64_t peer, const GenTxid& gtxid, bool preferred, bool overloaded,\n+        std::chrono::microseconds reqtime);\n+\n+    /** Converts the CANDIDATE entry for the provided peer and gtxid into a REQUESTED one.\n+     *\n+     * Expiry is set to the specified value. This can ONLY be called immediately after GetRequestable was called\n+     * (for the same peer), with only ForgetTx and other RequestedTx calls (both for other txhashes) in\n+     * between. Any other non-const operation removes the ability to call RequestedTx.\n+     */\n+    void RequestedTx(uint64_t peer, const GenTxid& gtxid, std::chrono::microseconds expiry);\n+\n+    /** Converts any CANDIDATE or REQUESTED entry to a COMPLETED one, if one exists.\n+     *\n+     * It should be called whenever a transaction or NOTFOUND was received from a peer. When a good transaction is\n+     * received, ForgetTx should be called instead of (or in addition to) this operation.\n+     */\n+    void ReceivedResponse(uint64_t peer, const GenTxid& gtxid);\n+\n+    // The operations below inspect the data structure.\n+\n+    /** Find the txids to request now from peer.\n+     *\n+     * It does the following:\n+     *  - Convert all REQUESTED entries (for all txhashes/peers) with (expiry <= now) to COMPLETED entries.\n+     *  - Requestable entries are selected: CANDIDATE entries from the specified peer with (reqtime <= now) for\n+     *    which the specified peer is the best choice among all such CANDIDATE entries with the same txhash (subject\n+     *    to preference/first rules, and tiebreaking using a deterministic salted hash of peer and txhash).\n+     *  - The selected entries are sorted in order of announcement (even if multiple were added at the same time, or\n+     *    even when the clock went backwards while they were being added), converted to GenTxids using their\n+     *    is_wtxid flag, and returned.\n+     */\n+    std::vector<GenTxid> GetRequestable(uint64_t peer, std::chrono::microseconds now);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494485317",
      "id" : 494485317,
      "line" : 187,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQ4NTMxNw==",
      "original_commit_id" : "164f50402475175d6fc839ae2798817e8da7c68f",
      "original_line" : 187,
      "original_position" : 198,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 187,
      "pull_request_review_id" : 495769842,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-24T17:40:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494485317",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494488392"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494488392"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Wouldn't hurt to make this block not publicly callable somehow.\r\n\r\nJust an idea in case it's not crazy: https://stackoverflow.com/a/23267346",
      "commit_id" : "4508a6e58d28eb5436031861aca1a43b76156097",
      "created_at" : "2020-09-24T17:26:07Z",
      "diff_hunk" : "@@ -208,6 +208,15 @@ class TxRequestTracker {\n \n     /** Access to the internal PriorityComputer (for testing) */\n     const PriorityComputer& GetPriorityComputer() const;\n+\n+    /** Run internal consistency check (testing only). */",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494488392",
      "id" : 494488392,
      "line" : 201,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQ4ODM5Mg==",
      "original_commit_id" : "71f551d840deaae3c30bb08a2c7a2248b043dbac",
      "original_line" : 201,
      "original_position" : 5,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 201,
      "pull_request_review_id" : 495769842,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-24T17:40:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494488392",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494491883"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494491883"
         }
      },
      "author_association" : "MEMBER",
      "body" : "tangentially-related nit: Comments above function are getting pretty stale.",
      "commit_id" : "4508a6e58d28eb5436031861aca1a43b76156097",
      "created_at" : "2020-09-24T17:32:00Z",
      "diff_hunk" : "@@ -1201,6 +1201,13 @@ void PeerManager::BlockConnected(const std::shared_ptr<const CBlock>& pblock, co\n             }\n         }\n     }\n+    {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494491883",
      "id" : 494491883,
      "line" : 1201,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQ5MTg4Mw==",
      "original_commit_id" : "3454757a66a82665b55aacbc1e53d75aafa82766",
      "original_line" : 1201,
      "original_position" : 4,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 211,
      "pull_request_review_id" : 495769842,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-24T17:40:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494491883",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494492919"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494492919"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "7949d08406774f27fd0291c2aa046ecdf985c191",
      "created_at" : "2020-09-24T17:33:49Z",
      "diff_hunk" : "@@ -793,69 +726,24 @@ static void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vec\n     }\n }\n \n-void EraseTxRequest(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    g_already_asked_for.erase(gtxid.GetHash());\n-}\n-\n-std::chrono::microseconds GetTxRequestTime(const GenTxid& gtxid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it != g_already_asked_for.end()) {\n-        return it->second;\n-    }\n-    return {};\n-}\n-\n-void UpdateTxRequestTime(const GenTxid& gtxid, std::chrono::microseconds request_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n-{\n-    auto it = g_already_asked_for.find(gtxid.GetHash());\n-    if (it == g_already_asked_for.end()) {\n-        g_already_asked_for.insert(std::make_pair(gtxid.GetHash(), request_time));\n-    } else {\n-        g_already_asked_for.update(it, request_time);\n-    }\n-}\n-\n-std::chrono::microseconds CalculateTxGetDataTime(const GenTxid& gtxid, std::chrono::microseconds current_time, bool use_inbound_delay, bool use_txid_delay) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+void RequestTx(NodeId nodeid, const GenTxid& gtxid, std::chrono::microseconds current_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n-    std::chrono::microseconds process_time;\n-    const auto last_request_time = GetTxRequestTime(gtxid);\n-    // First time requesting this tx\n-    if (last_request_time.count() == 0) {\n-        process_time = current_time;\n-    } else {\n-        // Randomize the delay to avoid biasing some peers over others (such as due to\n-        // fixed ordering of peer processing in ThreadMessageHandler)\n-        process_time = last_request_time + GETDATA_TX_INTERVAL + GetRandMicros(MAX_GETDATA_RANDOM_DELAY);\n-    }\n-\n-    // We delay processing announcements from inbound peers\n-    if (use_inbound_delay) process_time += INBOUND_PEER_TX_DELAY;\n-\n-    // We delay processing announcements from peers that use txid-relay (instead of wtxid)\n-    if (use_txid_delay) process_time += TXID_RELAY_DELAY;\n-\n-    return process_time;\n-}\n-\n-void RequestTx(CNodeState* state, const GenTxid& gtxid, std::chrono::microseconds current_time) EXCLUSIVE_LOCKS_REQUIRED(cs_main)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494492919",
      "id" : 494492919,
      "in_reply_to_id" : 493190576,
      "line" : 842,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQ5MjkxOQ==",
      "original_commit_id" : "c7601cdb31f9c86a4308cf36bbbc9c74c1078f53",
      "original_line" : 842,
      "original_position" : 156,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 162,
      "pull_request_review_id" : 495799717,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "LEFT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-24T17:33:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494492919",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494493059"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494493059"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Of course! Done.",
      "commit_id" : "4508a6e58d28eb5436031861aca1a43b76156097",
      "created_at" : "2020-09-24T17:34:03Z",
      "diff_hunk" : "@@ -0,0 +1,715 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+TxRequestTracker::PriorityComputer::PriorityComputer(bool deterministic) :\n+    m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+    m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+uint64_t TxRequestTracker::PriorityComputer::operator()(const uint256& txhash, uint64_t peer, bool preferred, bool first) const\n+{\n+    uint64_t low_bits = 0;\n+    if (!first) {\n+        low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+    }\n+    return low_bits | uint64_t{!preferred} << 63;\n+}\n+\n+static const uint256 UINT256_ZERO;\n+\n+/** Actual implementation for TxRequestTracker's data structure. */\n+class TxRequestTracker::Impl {\n+    //! The various states a (txid,node) pair can be in.\n+    //! Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient\n+    //! implementation. Also note that the sorting order of EntryTxHash relies on the specific order of values in\n+    //! this enum.\n+    enum class State : uint8_t {\n+        //! A CANDIDATE entry whose reqtime is in the future.\n+        CANDIDATE_DELAYED,\n+        //! The best CANDIDATE for a given txid; only if there is no REQUESTED entry already for that txid.\n+        //! The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txid.\n+        CANDIDATE_BEST,\n+        //! A REQUESTED entry.\n+        REQUESTED,\n+        //! A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST.\n+        CANDIDATE_READY,\n+        //! A COMPLETED entry.\n+        COMPLETED,\n+\n+        //! An invalid State value that's larger than all valid ones.\n+        TOO_LARGE,\n+    };\n+\n+    /** A flag (in Entry::m_per_txhash) to indicate that for that txhash,\n+     *  new preferred announcements are not eligible to get the 'first' marker. */\n+    static constexpr uint8_t TXHASHINFO_NO_MORE_PREFERRED_FIRST = 1;\n+    /** A flag (in Entry::m_per_txhash) to indicate that for that txhash,\n+     *  new non-preferred announcements are not eligible to get the 'first' marker. */\n+    static constexpr uint8_t TXHASHINFO_NO_MORE_NONPREFERRED_FIRST = 2;\n+\n+    //! Tag for the EntryPeer-based index.\n+    struct ByPeer {};\n+    //! Tag for the EntryTxHash-based index.\n+    struct ByTxHash {};\n+    //! Tag for the EntryTime-based index.\n+    struct ByTime {};\n+\n+    //! The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txid)\n+    using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+\n+    //! The ByTxHash index is sorted by (txhash, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+    using EntryTxHash = std::tuple<const uint256&, State, uint64_t>;\n+\n+    //! The ByTime index is sorted by (0 [CANDIDATE_DELAYED,REQUESTED]; 1 [COMPLETED];\n+    // 2 [CANDIDATE_READY,CANDIDATE_BEST], time)\n+    using EntryTime = std::pair<int, std::chrono::microseconds>;\n+\n+    //! The current sequence number. Increases for every announcement. This is used to sort txids returned by\n+    //! GetRequestable in announcement order.\n+    uint64_t m_sequence{0};\n+\n+    //! An announcement entry.\n+    struct Entry {\n+        //! Txid that was announced.\n+        const uint256 m_txhash;\n+        //! For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry\n+        std::chrono::microseconds m_time;\n+        //! What peer the request was from.\n+        const uint64_t m_peer;\n+        //! What sequence number this announcement has.\n+        const uint64_t m_sequence : 56;\n+        //! Whether the request is preferred (giving it priority higher than non-preferred ones).\n+        const bool m_preferred : 1;\n+        //! Whether this is a wtxid request.\n+        const bool m_is_wtxid : 1;\n+        //! Whether this was: the very first announcement for this txhash, within the\n+        //! preferred or non-preferred ones, and no request had been made for this\n+        //! txhash from any peer at the time the announcement came in.\n+        const bool m_first : 1;\n+\n+        //! What state this announcement is in\n+        //! This is a uint8_t instead of a State to silence a GCC warning.\n+        uint8_t m_state : 3;\n+\n+        /** Per-txhash flags. These are stored in the last Entry for a given txhash (ByTxHash order).\n+         *  The values for other Entry objects can be arbitrary subsets of the actual flags. */\n+        mutable uint8_t m_per_txhash : 2;\n+\n+        //! Convert the m_state variable to a State enum.\n+        State GetState() const { return State(m_state); }\n+        //! Convert a State to a uint8_t and store it in m_state.\n+        void SetState(State state) { m_state = uint8_t(state); }\n+\n+        //! Whether this entry is selected. There can be at most 1 selected peer per txhash.\n+        bool IsSelected() const\n+        {\n+            return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+        }\n+\n+        //! Whether this entry is waiting for a certain time to pass.\n+        bool IsWaiting() const\n+        {\n+            return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+        }\n+\n+        //! Whether this entry can feasibly be selected if the current IsSelected() one disappears.\n+        bool IsSelectable() const\n+        {\n+            return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+        }\n+\n+        //! Construct a new entry from scratch, initially in CANDIDATE_DELAYED state.\n+        Entry(const GenTxid& gtxid, uint64_t peer, bool preferred, std::chrono::microseconds reqtime,\n+            uint64_t sequence, bool first) :\n+            m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+            m_is_wtxid(gtxid.IsWtxid()), m_first(first), m_state(uint8_t(State::CANDIDATE_DELAYED)),\n+            m_per_txhash(0) {}\n+\n+        //! Compute this Entry's priority.\n+        uint64_t ComputePriority(const PriorityComputer& computer) const\n+        {\n+            return computer(m_txhash, m_peer, m_preferred, m_first);\n+        }\n+\n+        //! Extract the EntryPeer from this Entry.\n+        EntryPeer ExtractPeer() const { return EntryPeer{m_peer, GetState() == State::CANDIDATE_BEST, m_txhash}; }\n+\n+        //! Extract the EntryTxHash from this Entry.\n+        EntryTxHash ExtractTxid(const PriorityComputer& computer) const\n+        {\n+            return EntryTxHash{\n+                m_txhash,\n+                GetState(),\n+                GetState() == State::CANDIDATE_READY ? ComputePriority(computer) : 0\n+            };\n+        }\n+\n+        //! Extract the EntryTime from this Entry.\n+        EntryTime ExtractTime() const { return EntryTime{IsWaiting() ? 0 : IsSelectable() ? 2 : 1, m_time}; }\n+    };\n+\n+    //! This tracker's priority computer.\n+    const PriorityComputer m_computer;\n+\n+    /** An extractor for EntryTxHash (with encapsulated PriorityComputer reference).\n+     *\n+     * See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+     * for more information about the key extraction concept.\n+     */\n+    class EntryTxHashExtractor {\n+        const PriorityComputer& m_computer;\n+    public:\n+        EntryTxHashExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+        using result_type = EntryTxHash; // Needed to comply with key extractor interface\n+        result_type operator()(const Entry& entry) const { return entry.ExtractTxid(m_computer); }\n+    };\n+\n+    //! Data type for the main data structure (Entry objects with ByPeer/ByTxHash/ByTime indexes).\n+    using Index = boost::multi_index_container<\n+        Entry,\n+        boost::multi_index::indexed_by<\n+            boost::multi_index::ordered_unique<\n+                boost::multi_index::tag<ByPeer>,\n+                boost::multi_index::const_mem_fun<Entry, EntryPeer, &Entry::ExtractPeer>\n+            >,\n+            boost::multi_index::ordered_non_unique<\n+                boost::multi_index::tag<ByTxHash>,\n+                EntryTxHashExtractor\n+            >,\n+            boost::multi_index::ordered_non_unique<\n+                boost::multi_index::tag<ByTime>,\n+                boost::multi_index::const_mem_fun<Entry, EntryTime, &Entry::ExtractTime>\n+            >\n+        >\n+    >;\n+\n+    //! This tracker's main data structure.\n+    Index m_index;\n+\n+    //! Per-peer statistics object.\n+    struct PeerInfo {\n+        size_t m_total = 0; //!< Total number of entries for this peer.\n+        size_t m_requested = 0; //!< Total number of REQUESTED entries for this peer.\n+\n+        friend bool operator==(const PeerInfo& a, const PeerInfo& b)\n+        {\n+            return std::tie(a.m_total, a.m_requested) == std::tie(b.m_total, b.m_requested);\n+        }\n+    };\n+\n+    //! Map with this tracker's per-peer statistics.\n+    std::unordered_map<uint64_t, PeerInfo> m_peerinfo;\n+\n+    //! Wrapper around Index::...::erase that keeps m_peerinfo and m_per_txhash up to date.\n+    template<typename Tag>\n+    typename Index::index<Tag>::type::iterator Erase(typename Index::index<Tag>::type::iterator it)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        if (--peerit->second.m_total == 0) m_peerinfo.erase(peerit);\n+        // As it may possibly be the last-sorted Entry for a given txhash, propagate its per-txhash flags to its\n+        // predecessor (if it belongs to the same txhash).\n+        auto bytxhashit = m_index.project<ByTxHash>(it);\n+        if (bytxhashit != m_index.get<ByTxHash>().begin() &&\n+            bytxhashit->m_txhash == std::prev(bytxhashit)->m_txhash) {\n+            std::prev(bytxhashit)->m_per_txhash |= bytxhashit->m_per_txhash;\n+        }\n+        return m_index.get<Tag>().erase(it);\n+    }\n+\n+\n+    //! Wrapper around Index::...::modify that keeps m_peerinfo and m_per_txhash up to date.\n+    template<typename Tag, typename Modifier>\n+    void Modify(typename Index::index<Tag>::type::iterator it, Modifier modifier)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        // It's possible that it used to be the last-sorted Entry for its txhash, so propagate its\n+        // flags to its predecessor (which would then become the new last-sorted Entry).\n+        auto bytxhashit = m_index.project<ByTxHash>(it);\n+        if (bytxhashit != m_index.get<ByTxHash>().begin() &&\n+            bytxhashit->m_txhash == std::prev(bytxhashit)->m_txhash) {\n+            std::prev(bytxhashit)->m_per_txhash |= bytxhashit->m_per_txhash;\n+        }\n+        m_index.get<Tag>().modify(it, std::move(modifier));\n+        // It's possible that it is now the new last-sorted Entry for its txhash, so propagate flags\n+        // from its predecessor to it.\n+        bytxhashit = m_index.project<ByTxHash>(it);\n+        if (bytxhashit != m_index.get<ByTxHash>().begin() &&\n+            bytxhashit->m_txhash == std::prev(bytxhashit)->m_txhash) {\n+            bytxhashit->m_per_txhash |= std::prev(bytxhashit)->m_per_txhash;\n+        }\n+        peerit->second.m_requested += it->GetState() == State::REQUESTED;\n+    }\n+\n+\n+    //! Convert a CANDIDATE_DELAYED entry into a CANDIDATE_READY. If this makes it the new best CANDIDATE_READY\n+    //! (and no REQUESTED exists) and better than the CANDIDATE_BEST (if any), it becomes the new CANDIDATE_BEST.\n+    void PromoteCandidateReady(typename Index::index<ByTxHash>::type::iterator it)\n+    {\n+        assert(it->GetState() == State::CANDIDATE_DELAYED);\n+        // Convert CANDIDATE_DELAYED to CANDIDATE_READY first.\n+        Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+        // The following code relies on the fact that the ByTxHash is sorted by txid, and then by state (first\n+        // _DELAYED, then _BEST/REQUESTED, then _READY). Within the _READY entries, the best one (lowest priority)\n+        // comes first. Thus, if an existing _BEST exists for the same txid that this entry may be preferred over,\n+        // it must immediately precede the newly created _READY.\n+        if (it == m_index.get<ByTxHash>().begin() || std::prev(it)->m_txhash != it->m_txhash ||\n+            std::prev(it)->GetState() == State::CANDIDATE_DELAYED) {\n+            // This is the new best CANDIDATE_READY, and there is no IsSelected() entry for this txid already.\n+            Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+        } else if (std::prev(it)->GetState() == State::CANDIDATE_BEST) {\n+            uint64_t priority_old = std::prev(it)->ComputePriority(m_computer);\n+            uint64_t priority_new = it->ComputePriority(m_computer);\n+            if (priority_new < priority_old) {\n+                // There is a CANDIDATE_BEST entry already, but this one is better.\n+                auto new_ready_it = std::prev(it);\n+                Modify<ByTxHash>(new_ready_it, [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+                Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+    }\n+\n+    //! Change the state of an entry to something non-IsSelected(). If it was IsSelected(), the next best entry will\n+    //! be marked CANDIDATE_BEST.\n+    void ChangeAndReselect(typename Index::index<ByTxHash>::type::iterator it, State new_state)\n+    {\n+        if (it->IsSelected()) {\n+            auto it_next = std::next(it);\n+            // The next best CANDIDATE_READY, if any, immediately follows the REQUESTED or CANDIDATE_BEST entry in\n+            // the ByTxHash index.\n+            if (it_next != m_index.get<ByTxHash>().end() && it_next->m_txhash == it->m_txhash &&\n+                it_next->GetState() == State::CANDIDATE_READY) {\n+                // If one such CANDIDATE_READY exists (for this txhash), convert it to CANDIDATE_BEST.\n+                Modify<ByTxHash>(it_next, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+        Modify<ByTxHash>(it, [new_state](Entry& entry){ entry.SetState(new_state); });\n+        assert(!it->IsSelected());\n+    }\n+\n+    //! Check if 'it' is the only Entry for a given txhash that isn't COMPLETED.\n+    bool IsOnlyNonCompleted(typename Index::index<ByTxHash>::type::iterator it)\n+    {\n+        assert(it->GetState() != State::COMPLETED); // Not allowed to call this on COMPLETED entries.\n+\n+        // If this Entry's predecessor exists, and belongs to the same txhash, it can't be COMPLETED either.\n+        if (it != m_index.get<ByTxHash>().begin() && std::prev(it)->m_txhash == it->m_txhash) return false;\n+\n+        // If this Entry's successor exists, belongs to the same txhash, and isn't COMPLETED, fail.\n+        if (std::next(it) != m_index.get<ByTxHash>().end() && std::next(it)->m_txhash == it->m_txhash &&\n+            std::next(it)->GetState() != State::COMPLETED) return false;\n+\n+        return true;\n+    }\n+\n+    //! Convert any entry to a COMPLETED one. If there are no non-COMPLETED entries left for this txid, they are all\n+    //! deleted. If this was a REQUESTED entry, and there are other CANDIDATEs left, the best one is made\n+    //! CANDIDATE_BEST. Returns whether the Entry still exists.\n+    bool MakeCompleted(typename Index::index<ByTxHash>::type::iterator it)\n+    {\n+        // Nothing to be done if it's already COMPLETED.\n+        if (it->GetState() == State::COMPLETED) return true;\n+\n+        if (IsOnlyNonCompleted(it)) {\n+            // This is the last non-COMPLETED entry for this txhash. Delete all.\n+            uint256 txhash = it->m_txhash;\n+            do {\n+                it = Erase<ByTxHash>(it);\n+            } while (it != m_index.get<ByTxHash>().end() && it->m_txhash == txhash);\n+            return false;\n+        }\n+\n+        // Mark the entry COMPLETED, and select the next best entry (the first CANDIDATE_READY) if needed.\n+        ChangeAndReselect(it, State::COMPLETED);\n+\n+        return true;\n+    }\n+\n+    //! Make the data structure consistent with a given point in time:\n+    //! - REQUESTED entries with expiry <= now are turned into COMPLETED.\n+    //! - CANDIDATE_DELAYED entries with reqtime <= now are turned into CANDIDATE_{READY,BEST}.\n+    //! - CANDIDATE_{READY,BEST} entries with reqtime > now are turned into CANDIDATE_DELAYED.\n+    void SetTimePoint(std::chrono::microseconds now)\n+    {\n+        // Iterate over all CANDIDATE_DELAYED and REQUESTED from old to new, as long as they're in the past,\n+        // and convert them to CANDIDATE_READY and COMPLETED respectively.\n+        while (!m_index.empty()) {\n+            auto it = m_index.get<ByTime>().begin();\n+            if (it->GetState() == State::CANDIDATE_DELAYED && it->m_time <= now) {\n+                PromoteCandidateReady(m_index.project<ByTxHash>(it));\n+            } else if (it->GetState() == State::REQUESTED && it->m_time <= now) {\n+                MakeCompleted(m_index.project<ByTxHash>(it));\n+            } else {\n+                break;\n+            }\n+        }\n+\n+        while (!m_index.empty()) {\n+            // If time went backwards, we may need to demote CANDIDATE_BEST and CANDIDATE_READY entries back\n+            // to CANDIDATE_DELAYED. This is an unusual edge case, and unlikely to matter in production. However,\n+            // it makes it much easier to specify and test TxRequestTracker::Impl's behaviour.\n+            auto it = std::prev(m_index.get<ByTime>().end());\n+            if (it->IsSelectable() && it->m_time > now) {\n+                ChangeAndReselect(m_index.project<ByTxHash>(it), State::CANDIDATE_DELAYED);\n+            } else {\n+                break;\n+            }\n+        }\n+    }\n+\n+public:\n+    Impl(bool deterministic) :\n+        m_computer(deterministic),\n+        // Explicitly initialize m_index as we need to pass a reference to m_computer to EntryTxHashExtractor.\n+        m_index(boost::make_tuple(\n+            boost::make_tuple(\n+                boost::multi_index::const_mem_fun<Entry, EntryPeer, &Entry::ExtractPeer>(),\n+                std::less<EntryPeer>()\n+            ),\n+            boost::make_tuple(\n+                EntryTxHashExtractor(m_computer),\n+                std::less<EntryTxHash>()\n+            ),\n+            boost::make_tuple(\n+                boost::multi_index::const_mem_fun<Entry, EntryTime, &Entry::ExtractTime>(),\n+                std::less<EntryTime>()\n+            )\n+        )) {}\n+\n+\n+    // Disable copying and assigning (a default copy won't work due the stateful EntryTxHashExtractor).\n+    Impl(const Impl&) = delete;\n+    Impl& operator=(const Impl&) = delete;\n+\n+    void DeletedPeer(uint64_t peer)\n+    {\n+        auto& index = m_index.get<ByPeer>();\n+        auto it = index.lower_bound(EntryPeer{peer, false, UINT256_ZERO});\n+        while (it != index.end() && it->m_peer == peer) {\n+            // Check what to continue with after this iteration. Note that 'it' may change position, and\n+            // std::next(it) may be deleted in the process, so this needs to be decided beforehand.\n+            auto it_next = (std::next(it) == index.end() || std::next(it)->m_peer != peer) ?\n+                index.end() : std::next(it);\n+            // If the entry isn't already COMPLETED, first make it COMPLETED (which will mark other CANDIDATEs as\n+            // CANDIDATE_BEST, or delete all of a txid's entries if no non-COMPLETED ones are left).\n+            if (MakeCompleted(m_index.project<ByTxHash>(it))) {\n+                // Then actually delete the entry (unless it was already deleted by MakeCompleted).\n+                Erase<ByPeer>(it);\n+            }\n+            it = it_next;\n+        }\n+    }\n+\n+    void ForgetTx(const GenTxid& gtxid)\n+    {\n+        auto it = m_index.get<ByTxHash>().lower_bound(EntryTxHash{gtxid.GetHash(), State::CANDIDATE_DELAYED, 0});\n+        while (it != m_index.get<ByTxHash>().end() && it->m_txhash == gtxid.GetHash()) {\n+            it = Erase<ByTxHash>(it);\n+        }\n+    }\n+\n+    void ReceivedInv(uint64_t peer, const GenTxid& gtxid, bool preferred, bool overloaded,\n+        std::chrono::microseconds reqtime)\n+    {\n+        // Bail out if we already have a CANDIDATE_BEST entry for this (txid, peer) combination. The case where there is\n+        // a non-CANDIDATE_BEST entry already will be caught by the uniqueness property of the ByPeer index\n+        // automatically.\n+        if (m_index.get<ByPeer>().count(EntryPeer{peer, true, gtxid.GetHash()})) return;\n+\n+        // Find last entry for this txhash, and extract per_txhash information from it.\n+        uint8_t per_txhash = 0;\n+        typename Index::index<ByTxHash>::type::iterator it_last = m_index.get<ByTxHash>().end();\n+        // First find the first entry past this txhash.\n+        it_last = m_index.get<ByTxHash>().lower_bound(EntryTxHash{gtxid.GetHash(), State::TOO_LARGE, 0});\n+        if (it_last != m_index.get<ByTxHash>().begin() && std::prev(it_last)->m_txhash == gtxid.GetHash()) {\n+            // Its predecessor exists, and has the right txhash. Remember it, and OR in its flags.\n+            it_last--;\n+            per_txhash |= it_last->m_per_txhash;\n+        } else {\n+            // No entry for this txhash exists yet.\n+            it_last = m_index.get<ByTxHash>().end();\n+        }\n+\n+        // Determine whether the new announcement's Entry will get the first marker, and update\n+        // the per_txhash information to be stored (but note that per_txhash isn't actually stored\n+        // until after the emplace below succeeds).\n+        bool first = false;\n+        if (!overloaded) {\n+            if (preferred && !(per_txhash & TXHASHINFO_NO_MORE_PREFERRED_FIRST)) {\n+                first = true;\n+                per_txhash |= TXHASHINFO_NO_MORE_PREFERRED_FIRST;\n+            } else if (!preferred && !(per_txhash & TXHASHINFO_NO_MORE_NONPREFERRED_FIRST)) {\n+                first = true;\n+                per_txhash |= TXHASHINFO_NO_MORE_NONPREFERRED_FIRST;\n+            }\n+        }\n+\n+        // Try creating the entry with CANDIDATE_DELAYED state (which will fail due to the uniqueness\n+        // of the ByPeer index if a non-CANDIDATE_BEST entry already exists with the same txhash and peer).\n+        // Bail out in that case.\n+        auto ret = m_index.get<ByPeer>().emplace(gtxid, peer, preferred, reqtime, m_sequence, first);\n+        if (!ret.second) return;\n+\n+        // Update accounting metadata.\n+        ++m_peerinfo[peer].m_total;\n+        ++m_sequence;\n+\n+        // Update m_per_txhash of the new last Entry (either the newly created one, or it_last).\n+        auto it = m_index.project<ByTxHash>(ret.first);\n+        if (it_last == m_index.get<ByTxHash>().end() || std::next(it_last) == it) it_last = it;\n+        it_last->m_per_txhash |= per_txhash;\n+    }\n+\n+    //! Find the txids to request now from peer.\n+    std::vector<GenTxid> GetRequestable(uint64_t peer, std::chrono::microseconds now)\n+    {\n+        // Move time.\n+        SetTimePoint(now);\n+\n+        // Find all CANDIDATE_BEST entries for this peer.\n+        std::vector<std::pair<uint64_t, const Entry*>> selected;\n+        auto it_peer = m_index.get<ByPeer>().lower_bound(EntryPeer{peer, true, UINT256_ZERO});\n+        while (it_peer != m_index.get<ByPeer>().end() && it_peer->m_peer == peer &&\n+            it_peer->GetState() == State::CANDIDATE_BEST) {\n+            selected.emplace_back(it_peer->m_sequence, &*it_peer);\n+            ++it_peer;\n+        }\n+\n+        // Return them, sorted by sequence number.\n+        std::sort(selected.begin(), selected.end());\n+        std::vector<GenTxid> ret;\n+        for (const auto& item : selected) {\n+            ret.emplace_back(item.second->m_is_wtxid, item.second->m_txhash);\n+        }\n+        return ret;\n+    }\n+\n+    void RequestedTx(uint64_t peer, const GenTxid& gtxid, std::chrono::microseconds expiry)\n+    {\n+        auto it = m_index.get<ByPeer>().find(EntryPeer{peer, true, gtxid.GetHash()});\n+        // RequestedTx can only be called on CANDIDATE_BEST entries (this is implied by its condition that it can only be\n+        // called on txids returned by GetRequestable (and only AlreadyHave and RequestedTx can be called in between,\n+        // which preserve the state of other txids).\n+        assert(it != m_index.get<ByPeer>().end());\n+        assert(it->GetState() == State::CANDIDATE_BEST);\n+        Modify<ByPeer>(it, [expiry](Entry& entry) {\n+            entry.SetState(State::REQUESTED);\n+            entry.m_time = expiry;\n+        });\n+\n+        // Update the m_per_txhash (of the last Entry for this txhash) to reflect that new ones are no longer\n+        // eligible for the \"first\" marker.\n+        auto it_last = std::prev(m_index.get<ByTxHash>().lower_bound(EntryTxHash{gtxid.GetHash(), State::TOO_LARGE, 0}));\n+        assert(it_last->m_txhash == gtxid.GetHash());\n+        it_last->m_per_txhash |= TXHASHINFO_NO_MORE_PREFERRED_FIRST | TXHASHINFO_NO_MORE_NONPREFERRED_FIRST;\n+    }\n+\n+    void ReceivedResponse(uint64_t peer, const GenTxid& gtxid)\n+    {\n+        // We need to search the ByPeer index for both (peer, false, txid) and (peer, true, txid).\n+        auto it = m_index.get<ByPeer>().find(EntryPeer{peer, false, gtxid.GetHash()});\n+        if (it == m_index.get<ByPeer>().end()) {\n+            it = m_index.get<ByPeer>().find(EntryPeer{peer, true, gtxid.GetHash()});\n+        }\n+        if (it != m_index.get<ByPeer>().end()) MakeCompleted(m_index.project<ByTxHash>(it));\n+    }\n+\n+    size_t CountInFlight(uint64_t peer) const\n+    {\n+        auto it = m_peerinfo.find(peer);\n+        if (it != m_peerinfo.end()) return it->second.m_requested;\n+        return 0;\n+    }\n+\n+    size_t CountTracked(uint64_t peer) const\n+    {\n+        auto it = m_peerinfo.find(peer);\n+        if (it != m_peerinfo.end()) return it->second.m_total;\n+        return 0;\n+    }\n+\n+    //! Count how many announcements are being tracked in total across all peers and transactions.\n+    size_t Size() const { return m_index.size(); }\n+\n+    //! Access to the internal PriorityComputer (for testing)\n+    const PriorityComputer& GetPriorityComputer() const { return m_computer; }\n+\n+    void SanityCheck() const\n+    {\n+        // Recompute m_peerdata.\n+        // This verifies the data in it, including the invariant\n+        // that no entries with m_total_announcements==0 exist.\n+        std::unordered_map<uint64_t, PeerInfo> peerinfo;\n+        for (const auto& a : m_index) {\n+            auto& entry = peerinfo[a.m_peer];\n+            ++entry.m_total;\n+            entry.m_requested += (a.GetState() == State::REQUESTED);\n+        }\n+        assert(m_peerinfo == peerinfo);\n+\n+        struct Counts {\n+            //! Number of CANDIDATE_DELAYED entries for this txhash.\n+            size_t m_candidate_delayed = 0;\n+            //! Number of CANDIDATE_READY entries for this txhash.\n+            size_t m_candidate_ready = 0;\n+            //! Number of CANDIDATE_BEST entries for this txhash (at most one).\n+            size_t m_candidate_best = 0;\n+            //! Number of REQUESTED entries for this txhash.\n+            size_t m_requested = 0;\n+            //! The priority of the CANDIDATE_BEST entry if one exists, or 0 otherwise.\n+            uint64_t m_priority_candidate_best = 0;\n+            //! The lowest priority of all CANDIDATE_READY entries (or max() if none exist).\n+            uint64_t m_priority_best_candidate_ready = std::numeric_limits<uint64_t>::max();\n+            //! All peers we have an entry for this txhash for.\n+            std::vector<uint64_t> m_peers;\n+            //! Whether any preferred first entry exists.\n+            bool m_any_preferred_first = false;\n+            //! Whether any non-preferred first entry exists.\n+            bool m_any_nonpreferred_first = false;\n+            //! OR of all m_per_txhash flags.\n+            uint8_t m_or_all_per_txhash = 0;\n+        };\n+\n+        std::map<uint256, Counts> table;\n+        for (const auto& a : m_index) {\n+            auto& entry = table[a.m_txhash];\n+            // Classify how many types peers we have for this txid.\n+            entry.m_candidate_delayed += (a.GetState() == State::CANDIDATE_DELAYED);\n+            entry.m_candidate_ready += (a.GetState() == State::CANDIDATE_READY);\n+            entry.m_candidate_best += (a.GetState() == State::CANDIDATE_BEST);\n+            entry.m_requested += (a.GetState() == State::REQUESTED);\n+            // And track the priority of the best CANDIDATE_READY/CANDIDATE_BEST entries.\n+            if (a.GetState() == State::CANDIDATE_BEST) {\n+                entry.m_priority_candidate_best = a.ComputePriority(m_computer);\n+            }\n+            if (a.GetState() == State::CANDIDATE_READY) {\n+                entry.m_priority_best_candidate_ready = std::min(entry.m_priority_best_candidate_ready,\n+                    a.ComputePriority(m_computer));\n+            }\n+            // Also keep track of which peers this txid has an entry for (so we can detect duplicates).\n+            entry.m_peers.push_back(a.m_peer);\n+            // Track preferred/first.\n+            entry.m_any_preferred_first |= (a.m_first && a.m_preferred);\n+            entry.m_any_nonpreferred_first |= (a.m_first && !a.m_preferred);\n+            entry.m_or_all_per_txhash |= a.m_per_txhash;\n+        }\n+        for (auto& entry : table) {\n+            auto& c = entry.second;\n+            // Cannot have only COMPLETED peers (txid should have been deleted)\n+            assert(c.m_candidate_delayed + c.m_candidate_ready + c.m_candidate_best + c.m_requested > 0);\n+            // Can have at most 1 CANDIDATE_BEST/REQUESTED peer\n+            assert(c.m_candidate_best + c.m_requested <= 1);\n+            // If there are any CANDIDATE_READY entries, there must be exactly one CANDIDATE_BEST or REQUESTED\n+            // entry.\n+            if (c.m_candidate_ready > 0) {\n+                assert(c.m_candidate_best + c.m_requested == 1);\n+            }\n+            // If there is both a CANDIDATE_READY and a CANDIDATE_BEST entry, the CANDIDATE_BEST one must be at\n+            // least as good as the best CANDIDATE_READY.\n+            if (c.m_candidate_ready && c.m_candidate_best) {\n+                assert(c.m_priority_candidate_best <= c.m_priority_best_candidate_ready);\n+            }\n+            // Detect duplicate (peer, txid) entries\n+            std::sort(c.m_peers.begin(), c.m_peers.end());\n+            assert(std::adjacent_find(c.m_peers.begin(), c.m_peers.end()) == c.m_peers.end());\n+            // Verify all per_txhash flags.\n+            uint8_t expected_per_txhash = 0;\n+            if (c.m_any_preferred_first || c.m_requested) {\n+                expected_per_txhash |= TXHASHINFO_NO_MORE_PREFERRED_FIRST;\n+            }\n+            if (c.m_any_nonpreferred_first || c.m_requested) {\n+                expected_per_txhash |= TXHASHINFO_NO_MORE_NONPREFERRED_FIRST;\n+            }\n+            // All expected flags must be present, but there can be more. If a node went from REQUESTED to\n+            // COMPLETED, or was deleted, our expected_per_txhash may miss the relevant bits.\n+            assert((expected_per_txhash & ~c.m_or_all_per_txhash) == 0);\n+            // No entry can have flags that are a superset of the actual ones (they're always ORed into the actual\n+            // one).\n+            auto it_last = std::prev(m_index.get<ByTxHash>().lower_bound(\n+                EntryTxHash{entry.first, State::TOO_LARGE, 0}));\n+            assert(it_last->m_txhash == entry.first);\n+            assert(c.m_or_all_per_txhash == it_last->m_per_txhash);\n+        }\n+    }\n+\n+    void PostGetRequestableSanityCheck(std::chrono::microseconds now) const\n+    {\n+        for (const auto& entry : m_index) {\n+            if (entry.IsWaiting()) {\n+                // REQUESTED and CANDIDATE_DELAYED must have a time in the future (they should have been converted\n+                // to COMPLETED/CANDIDATE_READY respectively).\n+                assert(entry.m_time > now);\n+            } else if (entry.IsSelectable()) {\n+                // CANDIDATE_READY and CANDIDATE_BEST cannot have a time in the future (they should have remained\n+                // CANDIDATE_DELAYED, or should have been converted back to it if time went backwards).\n+                assert(entry.m_time <= now);\n+            }\n+        }\n+    }\n+};\n+\n+TxRequestTracker::TxRequestTracker(bool deterministic)\n+{\n+    m_impl = MakeUnique<TxRequestTracker::Impl>(deterministic);\n+}\n+\n+TxRequestTracker::~TxRequestTracker() {}",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494493059",
      "id" : 494493059,
      "in_reply_to_id" : 494257310,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQ5MzA1OQ==",
      "original_commit_id" : "7949d08406774f27fd0291c2aa046ecdf985c191",
      "original_line" : 676,
      "original_position" : 676,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : null,
      "pull_request_review_id" : 495799893,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-24T17:34:03Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494493059",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494493201"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494493201"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Nice, done.",
      "commit_id" : "4508a6e58d28eb5436031861aca1a43b76156097",
      "created_at" : "2020-09-24T17:34:13Z",
      "diff_hunk" : "@@ -0,0 +1,222 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not (which peers are preferred is determined by the caller, but this is\n+ *   designed for outbound peers, or other peers that we have a higher level of trust in).\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see '\"First\" marker rules').\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the transaction was forgotten in\n+ *   between (see next point), and re-announced.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening invblock attacks. The flip side is that as long as an attacker manages to prevent\n+ *              us from receiving a transaction, failed announcements (including those from honest peers) will\n+ *              linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on\n+ *              the number of tracked announcements per peer.\n+ *              See https://allquantor.at/blockchainbib/pdf/miller2015topology.pdf for information on invblocking.\n+ *\n+ * - Announcements are only forgotten about when the peer that announced them went offline, when the transaction\n+ *   was received successfully, or when no candidates for a transaction remain that haven't been tried already.\n+ *\n+ *   Rationale: we need to eventually forget announcements to keep memory bounded, but as long as viable\n+ *              candidate peers remain, we prefer to avoid fetching from failed ones. As every request has a finite\n+ *              timeout and we schedule new request as soon a previous one expired, there is always progress being\n+ *              made towards forgetting a transaction - either successfully or unsuccessfully.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable net_processing code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers (outbound, whitelisted) are chosen by us, so are less likely to be under attacker\n+ *                control.\n+ *\n+ *   - Among the remaining candidates, choose the one with the \"first\" marker if one exists (there can be at most\n+ *     one such peer, see further).\n+ *\n+ *     Rationale: in non-attack scenarios we want to give one chance to request from the fastest peer to reduce\n+ *                latency, and reduce risk of breaking chains of dependent transactions. An attacker who races the\n+ *                network can exploit this to delay us learning about a transaction, but it is available only once\n+ *                per txhash.\n+ *\n+ *   - If no remaining candidates have the \"first\" marker, pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: if the \"first\" mechanism failed, random assignments are hard to influence for attackers.\n+ *\n+ * \"First\" marker rules: the \"first\" marker is given to announcements for which at the time of announcement:\n+ * - No requests for its txhash have been attempted (ever, or since it was forgotten about).\n+ * - The peer that announced them was not overloaded.\n+ * - No announcement for the same txhash from another peer within the same preferred/nonpreferred class already has\n+ *   the first marker already.\n+ *\n+ *   Rationale: these restrictions avoid giving the speed benefit to honest but overloaded peers, and also\n+ *              reduce the extent to which attackers that race the network in announcing all transactions\n+ *              can break chains of dependent transactions.\n+ *\n+ * Together these rules strike a balance between being fast in non-adverserial conditions and avoiding influenceable\n+ * by attackers. An invblocking attacker that races the network:\n+ * - Will be unsuccessful if all preferred connections are honest (and there is at least one).\n+ * - If there are P preferred connections of which Ph>=1 are honest, the attacker can delay us from learning\n+ *   about a transaction by k expiration periods, where k ~ 1 + NHG(N=P-1,K=P-Ph-1,r=1), which has mean\n+ *   P/(Ph+1) (where NHG stands for Negative Hypergeometric distribution).\n+ * - If all P preferred connections are to the attacker, and there are NP non-preferred connections of which NPh are\n+ *   honest, k ~ P + 1 + NHG(N=NP-1,K=NP-NPh-1,r=1), with mean P + NP/(NPh+1).\n+ *\n+ * Complexity:\n+ * - Memory usage is proportional to the total number of tracked announcements (Size()) plus the number of\n+ *   peers with a nonzero number of tracked announcements.\n+ * - CPU usage is generally logarithmic in the total number of tracked announcements, plus the number of\n+ *   announcements affected by an operation (amortized O(1) per announcement).\n+ */\n+class TxRequestTracker {\n+public:\n+    /** A functor with embedded salt that computes priority of a txhash/peer combination. Lower priorities are\n+     *  selected first. */\n+    class PriorityComputer {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494493201",
      "id" : 494493201,
      "in_reply_to_id" : 494323998,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQ5MzIwMQ==",
      "original_commit_id" : "7949d08406774f27fd0291c2aa046ecdf985c191",
      "original_line" : 112,
      "original_position" : 112,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 495800023,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-24T17:34:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494493201",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494493318"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494493318"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "4508a6e58d28eb5436031861aca1a43b76156097",
      "created_at" : "2020-09-24T17:34:23Z",
      "diff_hunk" : "@@ -0,0 +1,715 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <uint256.h>\n+#include <util/memory.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+TxRequestTracker::PriorityComputer::PriorityComputer(bool deterministic) :\n+    m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+    m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+uint64_t TxRequestTracker::PriorityComputer::operator()(const uint256& txhash, uint64_t peer, bool preferred, bool first) const\n+{\n+    uint64_t low_bits = 0;\n+    if (!first) {\n+        low_bits = CSipHasher(m_k0, m_k1).Write(txhash.begin(), txhash.size()).Write(peer).Finalize() >> 1;\n+    }\n+    return low_bits | uint64_t{!preferred} << 63;\n+}\n+\n+static const uint256 UINT256_ZERO;\n+\n+/** Actual implementation for TxRequestTracker's data structure. */\n+class TxRequestTracker::Impl {\n+    //! The various states a (txid,node) pair can be in.\n+    //! Note that CANDIDATE is split up into 3 substates (DELAYED, BEST, READY), allowing more efficient\n+    //! implementation. Also note that the sorting order of EntryTxHash relies on the specific order of values in\n+    //! this enum.\n+    enum class State : uint8_t {\n+        //! A CANDIDATE entry whose reqtime is in the future.\n+        CANDIDATE_DELAYED,\n+        //! The best CANDIDATE for a given txid; only if there is no REQUESTED entry already for that txid.\n+        //! The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_READY (and _BEST) ones for that txid.\n+        CANDIDATE_BEST,\n+        //! A REQUESTED entry.\n+        REQUESTED,\n+        //! A CANDIDATE entry that's not CANDIDATE_DELAYED or CANDIDATE_BEST.\n+        CANDIDATE_READY,\n+        //! A COMPLETED entry.\n+        COMPLETED,\n+\n+        //! An invalid State value that's larger than all valid ones.\n+        TOO_LARGE,\n+    };\n+\n+    /** A flag (in Entry::m_per_txhash) to indicate that for that txhash,\n+     *  new preferred announcements are not eligible to get the 'first' marker. */\n+    static constexpr uint8_t TXHASHINFO_NO_MORE_PREFERRED_FIRST = 1;\n+    /** A flag (in Entry::m_per_txhash) to indicate that for that txhash,\n+     *  new non-preferred announcements are not eligible to get the 'first' marker. */\n+    static constexpr uint8_t TXHASHINFO_NO_MORE_NONPREFERRED_FIRST = 2;\n+\n+    //! Tag for the EntryPeer-based index.\n+    struct ByPeer {};\n+    //! Tag for the EntryTxHash-based index.\n+    struct ByTxHash {};\n+    //! Tag for the EntryTime-based index.\n+    struct ByTime {};\n+\n+    //! The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txid)\n+    using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+\n+    //! The ByTxHash index is sorted by (txhash, state, priority [CANDIDATE_READY]; 0 [otherwise])\n+    using EntryTxHash = std::tuple<const uint256&, State, uint64_t>;\n+\n+    //! The ByTime index is sorted by (0 [CANDIDATE_DELAYED,REQUESTED]; 1 [COMPLETED];\n+    // 2 [CANDIDATE_READY,CANDIDATE_BEST], time)\n+    using EntryTime = std::pair<int, std::chrono::microseconds>;\n+\n+    //! The current sequence number. Increases for every announcement. This is used to sort txids returned by\n+    //! GetRequestable in announcement order.\n+    uint64_t m_sequence{0};\n+\n+    //! An announcement entry.\n+    struct Entry {\n+        //! Txid that was announced.\n+        const uint256 m_txhash;\n+        //! For CANDIDATE_{DELAYED,BEST,READY} the reqtime; for REQUESTED the expiry\n+        std::chrono::microseconds m_time;\n+        //! What peer the request was from.\n+        const uint64_t m_peer;\n+        //! What sequence number this announcement has.\n+        const uint64_t m_sequence : 56;\n+        //! Whether the request is preferred (giving it priority higher than non-preferred ones).\n+        const bool m_preferred : 1;\n+        //! Whether this is a wtxid request.\n+        const bool m_is_wtxid : 1;\n+        //! Whether this was: the very first announcement for this txhash, within the\n+        //! preferred or non-preferred ones, and no request had been made for this\n+        //! txhash from any peer at the time the announcement came in.\n+        const bool m_first : 1;\n+\n+        //! What state this announcement is in\n+        //! This is a uint8_t instead of a State to silence a GCC warning.\n+        uint8_t m_state : 3;\n+\n+        /** Per-txhash flags. These are stored in the last Entry for a given txhash (ByTxHash order).\n+         *  The values for other Entry objects can be arbitrary subsets of the actual flags. */\n+        mutable uint8_t m_per_txhash : 2;\n+\n+        //! Convert the m_state variable to a State enum.\n+        State GetState() const { return State(m_state); }\n+        //! Convert a State to a uint8_t and store it in m_state.\n+        void SetState(State state) { m_state = uint8_t(state); }\n+\n+        //! Whether this entry is selected. There can be at most 1 selected peer per txhash.\n+        bool IsSelected() const\n+        {\n+            return GetState() == State::CANDIDATE_BEST || GetState() == State::REQUESTED;\n+        }\n+\n+        //! Whether this entry is waiting for a certain time to pass.\n+        bool IsWaiting() const\n+        {\n+            return GetState() == State::REQUESTED || GetState() == State::CANDIDATE_DELAYED;\n+        }\n+\n+        //! Whether this entry can feasibly be selected if the current IsSelected() one disappears.\n+        bool IsSelectable() const\n+        {\n+            return GetState() == State::CANDIDATE_READY || GetState() == State::CANDIDATE_BEST;\n+        }\n+\n+        //! Construct a new entry from scratch, initially in CANDIDATE_DELAYED state.\n+        Entry(const GenTxid& gtxid, uint64_t peer, bool preferred, std::chrono::microseconds reqtime,\n+            uint64_t sequence, bool first) :\n+            m_txhash(gtxid.GetHash()), m_time(reqtime), m_peer(peer), m_sequence(sequence), m_preferred(preferred),\n+            m_is_wtxid(gtxid.IsWtxid()), m_first(first), m_state(uint8_t(State::CANDIDATE_DELAYED)),\n+            m_per_txhash(0) {}\n+\n+        //! Compute this Entry's priority.\n+        uint64_t ComputePriority(const PriorityComputer& computer) const\n+        {\n+            return computer(m_txhash, m_peer, m_preferred, m_first);\n+        }\n+\n+        //! Extract the EntryPeer from this Entry.\n+        EntryPeer ExtractPeer() const { return EntryPeer{m_peer, GetState() == State::CANDIDATE_BEST, m_txhash}; }\n+\n+        //! Extract the EntryTxHash from this Entry.\n+        EntryTxHash ExtractTxid(const PriorityComputer& computer) const\n+        {\n+            return EntryTxHash{\n+                m_txhash,\n+                GetState(),\n+                GetState() == State::CANDIDATE_READY ? ComputePriority(computer) : 0\n+            };\n+        }\n+\n+        //! Extract the EntryTime from this Entry.\n+        EntryTime ExtractTime() const { return EntryTime{IsWaiting() ? 0 : IsSelectable() ? 2 : 1, m_time}; }\n+    };\n+\n+    //! This tracker's priority computer.\n+    const PriorityComputer m_computer;\n+\n+    /** An extractor for EntryTxHash (with encapsulated PriorityComputer reference).\n+     *\n+     * See https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors\n+     * for more information about the key extraction concept.\n+     */\n+    class EntryTxHashExtractor {\n+        const PriorityComputer& m_computer;\n+    public:\n+        EntryTxHashExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+        using result_type = EntryTxHash; // Needed to comply with key extractor interface\n+        result_type operator()(const Entry& entry) const { return entry.ExtractTxid(m_computer); }\n+    };\n+\n+    //! Data type for the main data structure (Entry objects with ByPeer/ByTxHash/ByTime indexes).\n+    using Index = boost::multi_index_container<\n+        Entry,\n+        boost::multi_index::indexed_by<\n+            boost::multi_index::ordered_unique<\n+                boost::multi_index::tag<ByPeer>,\n+                boost::multi_index::const_mem_fun<Entry, EntryPeer, &Entry::ExtractPeer>\n+            >,\n+            boost::multi_index::ordered_non_unique<\n+                boost::multi_index::tag<ByTxHash>,\n+                EntryTxHashExtractor\n+            >,\n+            boost::multi_index::ordered_non_unique<\n+                boost::multi_index::tag<ByTime>,\n+                boost::multi_index::const_mem_fun<Entry, EntryTime, &Entry::ExtractTime>\n+            >\n+        >\n+    >;\n+\n+    //! This tracker's main data structure.\n+    Index m_index;\n+\n+    //! Per-peer statistics object.\n+    struct PeerInfo {\n+        size_t m_total = 0; //!< Total number of entries for this peer.\n+        size_t m_requested = 0; //!< Total number of REQUESTED entries for this peer.\n+\n+        friend bool operator==(const PeerInfo& a, const PeerInfo& b)\n+        {\n+            return std::tie(a.m_total, a.m_requested) == std::tie(b.m_total, b.m_requested);\n+        }\n+    };\n+\n+    //! Map with this tracker's per-peer statistics.\n+    std::unordered_map<uint64_t, PeerInfo> m_peerinfo;\n+\n+    //! Wrapper around Index::...::erase that keeps m_peerinfo and m_per_txhash up to date.\n+    template<typename Tag>\n+    typename Index::index<Tag>::type::iterator Erase(typename Index::index<Tag>::type::iterator it)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        if (--peerit->second.m_total == 0) m_peerinfo.erase(peerit);\n+        // As it may possibly be the last-sorted Entry for a given txhash, propagate its per-txhash flags to its\n+        // predecessor (if it belongs to the same txhash).\n+        auto bytxhashit = m_index.project<ByTxHash>(it);\n+        if (bytxhashit != m_index.get<ByTxHash>().begin() &&\n+            bytxhashit->m_txhash == std::prev(bytxhashit)->m_txhash) {\n+            std::prev(bytxhashit)->m_per_txhash |= bytxhashit->m_per_txhash;\n+        }\n+        return m_index.get<Tag>().erase(it);\n+    }\n+\n+\n+    //! Wrapper around Index::...::modify that keeps m_peerinfo and m_per_txhash up to date.\n+    template<typename Tag, typename Modifier>\n+    void Modify(typename Index::index<Tag>::type::iterator it, Modifier modifier)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_requested -= it->GetState() == State::REQUESTED;\n+        // It's possible that it used to be the last-sorted Entry for its txhash, so propagate its\n+        // flags to its predecessor (which would then become the new last-sorted Entry).\n+        auto bytxhashit = m_index.project<ByTxHash>(it);\n+        if (bytxhashit != m_index.get<ByTxHash>().begin() &&\n+            bytxhashit->m_txhash == std::prev(bytxhashit)->m_txhash) {\n+            std::prev(bytxhashit)->m_per_txhash |= bytxhashit->m_per_txhash;\n+        }\n+        m_index.get<Tag>().modify(it, std::move(modifier));\n+        // It's possible that it is now the new last-sorted Entry for its txhash, so propagate flags\n+        // from its predecessor to it.\n+        bytxhashit = m_index.project<ByTxHash>(it);\n+        if (bytxhashit != m_index.get<ByTxHash>().begin() &&\n+            bytxhashit->m_txhash == std::prev(bytxhashit)->m_txhash) {\n+            bytxhashit->m_per_txhash |= std::prev(bytxhashit)->m_per_txhash;\n+        }\n+        peerit->second.m_requested += it->GetState() == State::REQUESTED;\n+    }\n+\n+\n+    //! Convert a CANDIDATE_DELAYED entry into a CANDIDATE_READY. If this makes it the new best CANDIDATE_READY\n+    //! (and no REQUESTED exists) and better than the CANDIDATE_BEST (if any), it becomes the new CANDIDATE_BEST.\n+    void PromoteCandidateReady(typename Index::index<ByTxHash>::type::iterator it)\n+    {\n+        assert(it->GetState() == State::CANDIDATE_DELAYED);\n+        // Convert CANDIDATE_DELAYED to CANDIDATE_READY first.\n+        Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+        // The following code relies on the fact that the ByTxHash is sorted by txid, and then by state (first\n+        // _DELAYED, then _BEST/REQUESTED, then _READY). Within the _READY entries, the best one (lowest priority)\n+        // comes first. Thus, if an existing _BEST exists for the same txid that this entry may be preferred over,\n+        // it must immediately precede the newly created _READY.\n+        if (it == m_index.get<ByTxHash>().begin() || std::prev(it)->m_txhash != it->m_txhash ||\n+            std::prev(it)->GetState() == State::CANDIDATE_DELAYED) {\n+            // This is the new best CANDIDATE_READY, and there is no IsSelected() entry for this txid already.\n+            Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+        } else if (std::prev(it)->GetState() == State::CANDIDATE_BEST) {\n+            uint64_t priority_old = std::prev(it)->ComputePriority(m_computer);\n+            uint64_t priority_new = it->ComputePriority(m_computer);\n+            if (priority_new < priority_old) {\n+                // There is a CANDIDATE_BEST entry already, but this one is better.\n+                auto new_ready_it = std::prev(it);\n+                Modify<ByTxHash>(new_ready_it, [](Entry& entry){ entry.SetState(State::CANDIDATE_READY); });\n+                Modify<ByTxHash>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+    }\n+\n+    //! Change the state of an entry to something non-IsSelected(). If it was IsSelected(), the next best entry will\n+    //! be marked CANDIDATE_BEST.\n+    void ChangeAndReselect(typename Index::index<ByTxHash>::type::iterator it, State new_state)\n+    {\n+        if (it->IsSelected()) {\n+            auto it_next = std::next(it);\n+            // The next best CANDIDATE_READY, if any, immediately follows the REQUESTED or CANDIDATE_BEST entry in\n+            // the ByTxHash index.\n+            if (it_next != m_index.get<ByTxHash>().end() && it_next->m_txhash == it->m_txhash &&\n+                it_next->GetState() == State::CANDIDATE_READY) {\n+                // If one such CANDIDATE_READY exists (for this txhash), convert it to CANDIDATE_BEST.\n+                Modify<ByTxHash>(it_next, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+            }\n+        }\n+        Modify<ByTxHash>(it, [new_state](Entry& entry){ entry.SetState(new_state); });\n+        assert(!it->IsSelected());\n+    }\n+\n+    //! Check if 'it' is the only Entry for a given txhash that isn't COMPLETED.\n+    bool IsOnlyNonCompleted(typename Index::index<ByTxHash>::type::iterator it)\n+    {\n+        assert(it->GetState() != State::COMPLETED); // Not allowed to call this on COMPLETED entries.\n+\n+        // If this Entry's predecessor exists, and belongs to the same txhash, it can't be COMPLETED either.\n+        if (it != m_index.get<ByTxHash>().begin() && std::prev(it)->m_txhash == it->m_txhash) return false;\n+\n+        // If this Entry's successor exists, belongs to the same txhash, and isn't COMPLETED, fail.\n+        if (std::next(it) != m_index.get<ByTxHash>().end() && std::next(it)->m_txhash == it->m_txhash &&\n+            std::next(it)->GetState() != State::COMPLETED) return false;\n+\n+        return true;\n+    }\n+\n+    //! Convert any entry to a COMPLETED one. If there are no non-COMPLETED entries left for this txid, they are all\n+    //! deleted. If this was a REQUESTED entry, and there are other CANDIDATEs left, the best one is made\n+    //! CANDIDATE_BEST. Returns whether the Entry still exists.\n+    bool MakeCompleted(typename Index::index<ByTxHash>::type::iterator it)\n+    {\n+        // Nothing to be done if it's already COMPLETED.\n+        if (it->GetState() == State::COMPLETED) return true;\n+\n+        if (IsOnlyNonCompleted(it)) {\n+            // This is the last non-COMPLETED entry for this txhash. Delete all.\n+            uint256 txhash = it->m_txhash;\n+            do {\n+                it = Erase<ByTxHash>(it);\n+            } while (it != m_index.get<ByTxHash>().end() && it->m_txhash == txhash);\n+            return false;\n+        }\n+\n+        // Mark the entry COMPLETED, and select the next best entry (the first CANDIDATE_READY) if needed.\n+        ChangeAndReselect(it, State::COMPLETED);\n+\n+        return true;\n+    }\n+\n+    //! Make the data structure consistent with a given point in time:\n+    //! - REQUESTED entries with expiry <= now are turned into COMPLETED.\n+    //! - CANDIDATE_DELAYED entries with reqtime <= now are turned into CANDIDATE_{READY,BEST}.\n+    //! - CANDIDATE_{READY,BEST} entries with reqtime > now are turned into CANDIDATE_DELAYED.\n+    void SetTimePoint(std::chrono::microseconds now)\n+    {\n+        // Iterate over all CANDIDATE_DELAYED and REQUESTED from old to new, as long as they're in the past,\n+        // and convert them to CANDIDATE_READY and COMPLETED respectively.\n+        while (!m_index.empty()) {\n+            auto it = m_index.get<ByTime>().begin();\n+            if (it->GetState() == State::CANDIDATE_DELAYED && it->m_time <= now) {\n+                PromoteCandidateReady(m_index.project<ByTxHash>(it));\n+            } else if (it->GetState() == State::REQUESTED && it->m_time <= now) {\n+                MakeCompleted(m_index.project<ByTxHash>(it));\n+            } else {\n+                break;\n+            }\n+        }\n+\n+        while (!m_index.empty()) {\n+            // If time went backwards, we may need to demote CANDIDATE_BEST and CANDIDATE_READY entries back\n+            // to CANDIDATE_DELAYED. This is an unusual edge case, and unlikely to matter in production. However,\n+            // it makes it much easier to specify and test TxRequestTracker::Impl's behaviour.\n+            auto it = std::prev(m_index.get<ByTime>().end());\n+            if (it->IsSelectable() && it->m_time > now) {\n+                ChangeAndReselect(m_index.project<ByTxHash>(it), State::CANDIDATE_DELAYED);\n+            } else {\n+                break;\n+            }\n+        }\n+    }\n+\n+public:\n+    Impl(bool deterministic) :\n+        m_computer(deterministic),\n+        // Explicitly initialize m_index as we need to pass a reference to m_computer to EntryTxHashExtractor.\n+        m_index(boost::make_tuple(\n+            boost::make_tuple(\n+                boost::multi_index::const_mem_fun<Entry, EntryPeer, &Entry::ExtractPeer>(),\n+                std::less<EntryPeer>()\n+            ),\n+            boost::make_tuple(\n+                EntryTxHashExtractor(m_computer),\n+                std::less<EntryTxHash>()\n+            ),\n+            boost::make_tuple(\n+                boost::multi_index::const_mem_fun<Entry, EntryTime, &Entry::ExtractTime>(),\n+                std::less<EntryTime>()\n+            )\n+        )) {}\n+\n+\n+    // Disable copying and assigning (a default copy won't work due the stateful EntryTxHashExtractor).\n+    Impl(const Impl&) = delete;\n+    Impl& operator=(const Impl&) = delete;\n+\n+    void DeletedPeer(uint64_t peer)\n+    {\n+        auto& index = m_index.get<ByPeer>();\n+        auto it = index.lower_bound(EntryPeer{peer, false, UINT256_ZERO});\n+        while (it != index.end() && it->m_peer == peer) {\n+            // Check what to continue with after this iteration. Note that 'it' may change position, and\n+            // std::next(it) may be deleted in the process, so this needs to be decided beforehand.\n+            auto it_next = (std::next(it) == index.end() || std::next(it)->m_peer != peer) ?\n+                index.end() : std::next(it);\n+            // If the entry isn't already COMPLETED, first make it COMPLETED (which will mark other CANDIDATEs as\n+            // CANDIDATE_BEST, or delete all of a txid's entries if no non-COMPLETED ones are left).\n+            if (MakeCompleted(m_index.project<ByTxHash>(it))) {\n+                // Then actually delete the entry (unless it was already deleted by MakeCompleted).\n+                Erase<ByPeer>(it);\n+            }\n+            it = it_next;\n+        }\n+    }\n+\n+    void ForgetTx(const GenTxid& gtxid)\n+    {\n+        auto it = m_index.get<ByTxHash>().lower_bound(EntryTxHash{gtxid.GetHash(), State::CANDIDATE_DELAYED, 0});\n+        while (it != m_index.get<ByTxHash>().end() && it->m_txhash == gtxid.GetHash()) {\n+            it = Erase<ByTxHash>(it);\n+        }\n+    }\n+\n+    void ReceivedInv(uint64_t peer, const GenTxid& gtxid, bool preferred, bool overloaded,\n+        std::chrono::microseconds reqtime)\n+    {\n+        // Bail out if we already have a CANDIDATE_BEST entry for this (txid, peer) combination. The case where there is\n+        // a non-CANDIDATE_BEST entry already will be caught by the uniqueness property of the ByPeer index\n+        // automatically.\n+        if (m_index.get<ByPeer>().count(EntryPeer{peer, true, gtxid.GetHash()})) return;\n+\n+        // Find last entry for this txhash, and extract per_txhash information from it.\n+        uint8_t per_txhash = 0;\n+        typename Index::index<ByTxHash>::type::iterator it_last = m_index.get<ByTxHash>().end();\n+        // First find the first entry past this txhash.\n+        it_last = m_index.get<ByTxHash>().lower_bound(EntryTxHash{gtxid.GetHash(), State::TOO_LARGE, 0});\n+        if (it_last != m_index.get<ByTxHash>().begin() && std::prev(it_last)->m_txhash == gtxid.GetHash()) {\n+            // Its predecessor exists, and has the right txhash. Remember it, and OR in its flags.\n+            it_last--;\n+            per_txhash |= it_last->m_per_txhash;\n+        } else {\n+            // No entry for this txhash exists yet.\n+            it_last = m_index.get<ByTxHash>().end();\n+        }\n+\n+        // Determine whether the new announcement's Entry will get the first marker, and update\n+        // the per_txhash information to be stored (but note that per_txhash isn't actually stored\n+        // until after the emplace below succeeds).\n+        bool first = false;\n+        if (!overloaded) {\n+            if (preferred && !(per_txhash & TXHASHINFO_NO_MORE_PREFERRED_FIRST)) {\n+                first = true;\n+                per_txhash |= TXHASHINFO_NO_MORE_PREFERRED_FIRST;\n+            } else if (!preferred && !(per_txhash & TXHASHINFO_NO_MORE_NONPREFERRED_FIRST)) {\n+                first = true;\n+                per_txhash |= TXHASHINFO_NO_MORE_NONPREFERRED_FIRST;\n+            }\n+        }\n+\n+        // Try creating the entry with CANDIDATE_DELAYED state (which will fail due to the uniqueness\n+        // of the ByPeer index if a non-CANDIDATE_BEST entry already exists with the same txhash and peer).\n+        // Bail out in that case.\n+        auto ret = m_index.get<ByPeer>().emplace(gtxid, peer, preferred, reqtime, m_sequence, first);\n+        if (!ret.second) return;\n+\n+        // Update accounting metadata.\n+        ++m_peerinfo[peer].m_total;\n+        ++m_sequence;\n+\n+        // Update m_per_txhash of the new last Entry (either the newly created one, or it_last).\n+        auto it = m_index.project<ByTxHash>(ret.first);\n+        if (it_last == m_index.get<ByTxHash>().end() || std::next(it_last) == it) it_last = it;\n+        it_last->m_per_txhash |= per_txhash;\n+    }\n+\n+    //! Find the txids to request now from peer.\n+    std::vector<GenTxid> GetRequestable(uint64_t peer, std::chrono::microseconds now)\n+    {\n+        // Move time.\n+        SetTimePoint(now);\n+\n+        // Find all CANDIDATE_BEST entries for this peer.\n+        std::vector<std::pair<uint64_t, const Entry*>> selected;\n+        auto it_peer = m_index.get<ByPeer>().lower_bound(EntryPeer{peer, true, UINT256_ZERO});\n+        while (it_peer != m_index.get<ByPeer>().end() && it_peer->m_peer == peer &&\n+            it_peer->GetState() == State::CANDIDATE_BEST) {\n+            selected.emplace_back(it_peer->m_sequence, &*it_peer);\n+            ++it_peer;\n+        }\n+\n+        // Return them, sorted by sequence number.\n+        std::sort(selected.begin(), selected.end());\n+        std::vector<GenTxid> ret;\n+        for (const auto& item : selected) {\n+            ret.emplace_back(item.second->m_is_wtxid, item.second->m_txhash);\n+        }\n+        return ret;\n+    }\n+\n+    void RequestedTx(uint64_t peer, const GenTxid& gtxid, std::chrono::microseconds expiry)\n+    {\n+        auto it = m_index.get<ByPeer>().find(EntryPeer{peer, true, gtxid.GetHash()});\n+        // RequestedTx can only be called on CANDIDATE_BEST entries (this is implied by its condition that it can only be\n+        // called on txids returned by GetRequestable (and only AlreadyHave and RequestedTx can be called in between,\n+        // which preserve the state of other txids).\n+        assert(it != m_index.get<ByPeer>().end());\n+        assert(it->GetState() == State::CANDIDATE_BEST);\n+        Modify<ByPeer>(it, [expiry](Entry& entry) {\n+            entry.SetState(State::REQUESTED);\n+            entry.m_time = expiry;\n+        });\n+\n+        // Update the m_per_txhash (of the last Entry for this txhash) to reflect that new ones are no longer\n+        // eligible for the \"first\" marker.\n+        auto it_last = std::prev(m_index.get<ByTxHash>().lower_bound(EntryTxHash{gtxid.GetHash(), State::TOO_LARGE, 0}));\n+        assert(it_last->m_txhash == gtxid.GetHash());\n+        it_last->m_per_txhash |= TXHASHINFO_NO_MORE_PREFERRED_FIRST | TXHASHINFO_NO_MORE_NONPREFERRED_FIRST;\n+    }\n+\n+    void ReceivedResponse(uint64_t peer, const GenTxid& gtxid)\n+    {\n+        // We need to search the ByPeer index for both (peer, false, txid) and (peer, true, txid).\n+        auto it = m_index.get<ByPeer>().find(EntryPeer{peer, false, gtxid.GetHash()});\n+        if (it == m_index.get<ByPeer>().end()) {\n+            it = m_index.get<ByPeer>().find(EntryPeer{peer, true, gtxid.GetHash()});\n+        }\n+        if (it != m_index.get<ByPeer>().end()) MakeCompleted(m_index.project<ByTxHash>(it));\n+    }\n+\n+    size_t CountInFlight(uint64_t peer) const\n+    {\n+        auto it = m_peerinfo.find(peer);\n+        if (it != m_peerinfo.end()) return it->second.m_requested;\n+        return 0;\n+    }\n+\n+    size_t CountTracked(uint64_t peer) const\n+    {\n+        auto it = m_peerinfo.find(peer);\n+        if (it != m_peerinfo.end()) return it->second.m_total;\n+        return 0;\n+    }\n+\n+    //! Count how many announcements are being tracked in total across all peers and transactions.\n+    size_t Size() const { return m_index.size(); }\n+\n+    //! Access to the internal PriorityComputer (for testing)\n+    const PriorityComputer& GetPriorityComputer() const { return m_computer; }\n+\n+    void SanityCheck() const\n+    {\n+        // Recompute m_peerdata.\n+        // This verifies the data in it, including the invariant\n+        // that no entries with m_total_announcements==0 exist.\n+        std::unordered_map<uint64_t, PeerInfo> peerinfo;\n+        for (const auto& a : m_index) {\n+            auto& entry = peerinfo[a.m_peer];\n+            ++entry.m_total;\n+            entry.m_requested += (a.GetState() == State::REQUESTED);\n+        }\n+        assert(m_peerinfo == peerinfo);\n+\n+        struct Counts {\n+            //! Number of CANDIDATE_DELAYED entries for this txhash.\n+            size_t m_candidate_delayed = 0;\n+            //! Number of CANDIDATE_READY entries for this txhash.\n+            size_t m_candidate_ready = 0;\n+            //! Number of CANDIDATE_BEST entries for this txhash (at most one).\n+            size_t m_candidate_best = 0;\n+            //! Number of REQUESTED entries for this txhash.\n+            size_t m_requested = 0;\n+            //! The priority of the CANDIDATE_BEST entry if one exists, or 0 otherwise.\n+            uint64_t m_priority_candidate_best = 0;\n+            //! The lowest priority of all CANDIDATE_READY entries (or max() if none exist).\n+            uint64_t m_priority_best_candidate_ready = std::numeric_limits<uint64_t>::max();\n+            //! All peers we have an entry for this txhash for.\n+            std::vector<uint64_t> m_peers;\n+            //! Whether any preferred first entry exists.\n+            bool m_any_preferred_first = false;\n+            //! Whether any non-preferred first entry exists.\n+            bool m_any_nonpreferred_first = false;\n+            //! OR of all m_per_txhash flags.\n+            uint8_t m_or_all_per_txhash = 0;\n+        };\n+\n+        std::map<uint256, Counts> table;\n+        for (const auto& a : m_index) {\n+            auto& entry = table[a.m_txhash];\n+            // Classify how many types peers we have for this txid.\n+            entry.m_candidate_delayed += (a.GetState() == State::CANDIDATE_DELAYED);\n+            entry.m_candidate_ready += (a.GetState() == State::CANDIDATE_READY);\n+            entry.m_candidate_best += (a.GetState() == State::CANDIDATE_BEST);\n+            entry.m_requested += (a.GetState() == State::REQUESTED);\n+            // And track the priority of the best CANDIDATE_READY/CANDIDATE_BEST entries.\n+            if (a.GetState() == State::CANDIDATE_BEST) {\n+                entry.m_priority_candidate_best = a.ComputePriority(m_computer);\n+            }\n+            if (a.GetState() == State::CANDIDATE_READY) {\n+                entry.m_priority_best_candidate_ready = std::min(entry.m_priority_best_candidate_ready,\n+                    a.ComputePriority(m_computer));\n+            }\n+            // Also keep track of which peers this txid has an entry for (so we can detect duplicates).\n+            entry.m_peers.push_back(a.m_peer);\n+            // Track preferred/first.\n+            entry.m_any_preferred_first |= (a.m_first && a.m_preferred);\n+            entry.m_any_nonpreferred_first |= (a.m_first && !a.m_preferred);\n+            entry.m_or_all_per_txhash |= a.m_per_txhash;\n+        }\n+        for (auto& entry : table) {\n+            auto& c = entry.second;\n+            // Cannot have only COMPLETED peers (txid should have been deleted)\n+            assert(c.m_candidate_delayed + c.m_candidate_ready + c.m_candidate_best + c.m_requested > 0);\n+            // Can have at most 1 CANDIDATE_BEST/REQUESTED peer\n+            assert(c.m_candidate_best + c.m_requested <= 1);\n+            // If there are any CANDIDATE_READY entries, there must be exactly one CANDIDATE_BEST or REQUESTED\n+            // entry.\n+            if (c.m_candidate_ready > 0) {\n+                assert(c.m_candidate_best + c.m_requested == 1);\n+            }\n+            // If there is both a CANDIDATE_READY and a CANDIDATE_BEST entry, the CANDIDATE_BEST one must be at\n+            // least as good as the best CANDIDATE_READY.\n+            if (c.m_candidate_ready && c.m_candidate_best) {\n+                assert(c.m_priority_candidate_best <= c.m_priority_best_candidate_ready);\n+            }\n+            // Detect duplicate (peer, txid) entries\n+            std::sort(c.m_peers.begin(), c.m_peers.end());\n+            assert(std::adjacent_find(c.m_peers.begin(), c.m_peers.end()) == c.m_peers.end());\n+            // Verify all per_txhash flags.\n+            uint8_t expected_per_txhash = 0;\n+            if (c.m_any_preferred_first || c.m_requested) {\n+                expected_per_txhash |= TXHASHINFO_NO_MORE_PREFERRED_FIRST;\n+            }\n+            if (c.m_any_nonpreferred_first || c.m_requested) {\n+                expected_per_txhash |= TXHASHINFO_NO_MORE_NONPREFERRED_FIRST;\n+            }\n+            // All expected flags must be present, but there can be more. If a node went from REQUESTED to\n+            // COMPLETED, or was deleted, our expected_per_txhash may miss the relevant bits.\n+            assert((expected_per_txhash & ~c.m_or_all_per_txhash) == 0);\n+            // No entry can have flags that are a superset of the actual ones (they're always ORed into the actual\n+            // one).\n+            auto it_last = std::prev(m_index.get<ByTxHash>().lower_bound(\n+                EntryTxHash{entry.first, State::TOO_LARGE, 0}));\n+            assert(it_last->m_txhash == entry.first);\n+            assert(c.m_or_all_per_txhash == it_last->m_per_txhash);\n+        }\n+    }\n+\n+    void PostGetRequestableSanityCheck(std::chrono::microseconds now) const\n+    {\n+        for (const auto& entry : m_index) {\n+            if (entry.IsWaiting()) {\n+                // REQUESTED and CANDIDATE_DELAYED must have a time in the future (they should have been converted\n+                // to COMPLETED/CANDIDATE_READY respectively).\n+                assert(entry.m_time > now);\n+            } else if (entry.IsSelectable()) {\n+                // CANDIDATE_READY and CANDIDATE_BEST cannot have a time in the future (they should have remained\n+                // CANDIDATE_DELAYED, or should have been converted back to it if time went backwards).\n+                assert(entry.m_time <= now);\n+            }\n+        }\n+    }\n+};\n+\n+TxRequestTracker::TxRequestTracker(bool deterministic)\n+{\n+    m_impl = MakeUnique<TxRequestTracker::Impl>(deterministic);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494493318",
      "id" : 494493318,
      "in_reply_to_id" : 494348645,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQ5MzMxOA==",
      "original_commit_id" : "7949d08406774f27fd0291c2aa046ecdf985c191",
      "original_line" : 673,
      "original_position" : 673,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : null,
      "pull_request_review_id" : 495800143,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-24T17:34:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494493318",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494495109"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494495109"
         }
      },
      "author_association" : "MEMBER",
      "body" : "The witness-ness of GenTxid doesn't matter. I find the interface distracting since it needs to be passed in.",
      "commit_id" : "4508a6e58d28eb5436031861aca1a43b76156097",
      "created_at" : "2020-09-24T17:37:26Z",
      "diff_hunk" : "@@ -2869,8 +2876,15 @@ void PeerManager::ProcessMessage(CNode& pfrom, const std::string& msg_type, CDat\n \n         TxValidationState state;\n \n+        if (wtxid != txid) {\n+            // Regardless of whether the transaction we received is valid and acceptable or not,\n+            // we don't need the version with this exact witness anymore.\n+            m_txrequest.ForgetTx(GenTxid{true, wtxid});",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494495109",
      "id" : 494495109,
      "line" : 2882,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQ5NTEwOQ==",
      "original_commit_id" : "cb2aa36ac613953916ca5eba69b7260006873358",
      "original_line" : 2882,
      "original_position" : 21,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 241,
      "pull_request_review_id" : 495769842,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-24T17:40:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494495109",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494504239"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494504239"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I'd prefer to move these into a friend `TxRequestTrackerTester` class (I thought I'd left a review comment suggesting that, but I appear to have lost it).",
      "commit_id" : "4508a6e58d28eb5436031861aca1a43b76156097",
      "created_at" : "2020-09-24T17:53:13Z",
      "diff_hunk" : "@@ -208,6 +208,15 @@ class TxRequestTracker {\n \n     /** Access to the internal PriorityComputer (for testing) */\n     const PriorityComputer& GetPriorityComputer() const;\n+\n+    /** Run internal consistency check (testing only). */",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494504239",
      "id" : 494504239,
      "in_reply_to_id" : 494488392,
      "line" : 201,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDUwNDIzOQ==",
      "original_commit_id" : "71f551d840deaae3c30bb08a2c7a2248b043dbac",
      "original_line" : 201,
      "original_position" : 5,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 201,
      "pull_request_review_id" : 495814053,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-24T17:53:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494504239",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494514532"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494514532"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Ah, my thinking behind the name was the caller informing TxRequestTracker \"Hey I have deleted peer X, you may want to forget about them\".\r\n\r\nDisconnectedPeer sounds better.",
      "commit_id" : "4508a6e58d28eb5436031861aca1a43b76156097",
      "created_at" : "2020-09-24T18:11:16Z",
      "diff_hunk" : "@@ -0,0 +1,213 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not (which peers are preferred is determined by the caller, but this is\n+ *   designed for outbound peers, or other peers that we have a higher level of trust in).\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see '\"First\" marker rules').\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the transaction was forgotten in\n+ *   between (see next point), and re-announced.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening invblock attacks. The flip side is that as long as an attacker manages to prevent\n+ *              us from receiving a transaction, failed announcements (including those from honest peers) will\n+ *              linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on\n+ *              the number of tracked announcements per peer.\n+ *              See https://allquantor.at/blockchainbib/pdf/miller2015topology.pdf for information on invblocking.\n+ *\n+ * - Announcements are only forgotten about when the peer that announced them went offline, when the transaction\n+ *   was received successfully, or when no candidates for a transaction remain that haven't been tried already.\n+ *\n+ *   Rationale: we need to eventually forget announcements to keep memory bounded, but as long as viable\n+ *              candidate peers remain, we prefer to avoid fetching from failed ones. As every request has a finite\n+ *              timeout and we schedule new request as soon a previous one expired, there is always progress being\n+ *              made towards forgetting a transaction - either successfully or unsuccessfully.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable net_processing code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers (outbound, whitelisted) are chosen by us, so are less likely to be under attacker\n+ *                control.\n+ *\n+ *   - Among the remaining candidates, choose the one with the \"first\" marker if one exists (there can be at most\n+ *     one such peer, see further).\n+ *\n+ *     Rationale: in non-attack scenarios we want to give one chance to request from the fastest peer to reduce\n+ *                latency, and reduce risk of breaking chains of dependent transactions. An attacker who races the\n+ *                network can exploit this to delay us learning about a transaction, but it is available only once\n+ *                per txhash.\n+ *\n+ *   - If no remaining candidates have the \"first\" marker, pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: if the \"first\" mechanism failed, random assignments are hard to influence for attackers.\n+ *\n+ * \"First\" marker rules: the \"first\" marker is given to announcements for which at the time of announcement:\n+ * - No requests for its txhash have been attempted (ever, or since it was forgotten about).\n+ * - The peer that announced them was not overloaded.\n+ * - No announcement for the same txhash from another peer within the same preferred/nonpreferred class already has\n+ *   the first marker already.\n+ *\n+ *   Rationale: these restrictions avoid giving the speed benefit to honest but overloaded peers, and also\n+ *              reduce the extent to which attackers that race the network in announcing all transactions\n+ *              can break chains of dependent transactions.\n+ *\n+ * Together these rules strike a balance between being fast in non-adverserial conditions and avoiding influenceable\n+ * by attackers. An invblocking attacker that races the network:\n+ * - Will be unsuccessful if all preferred connections are honest (and there is at least one).\n+ * - If there are P preferred connections of which Ph>=1 are honest, the attacker can delay us from learning\n+ *   about a transaction by k expiration periods, where k ~ 1 + NHG(N=P-1,K=P-Ph-1,r=1), which has mean\n+ *   P/(Ph+1) (where NHG stands for Negative Hypergeometric distribution).\n+ * - If all P preferred connections are to the attacker, and there are NP non-preferred connections of which NPh are\n+ *   honest, k ~ P + 1 + NHG(N=NP-1,K=NP-NPh-1,r=1), with mean P + NP/(NPh+1).\n+ *\n+ * Complexity:\n+ * - Memory usage is proportional to the total number of tracked announcements (Size()) plus the number of\n+ *   peers with a nonzero number of tracked announcements.\n+ * - CPU usage is generally logarithmic in the total number of tracked announcements, plus the number of\n+ *   announcements affected by an operation (amortized O(1) per announcement).\n+ */\n+class TxRequestTracker {\n+public:\n+    /** A functor with embedded salt that computes priority of a txhash/peer combination. Lower priorities are\n+     *  selected first. */\n+    class PriorityComputer {\n+        const uint64_t m_k0, m_k1;\n+    public:\n+        explicit PriorityComputer(bool deterministic);\n+        uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred, bool first) const;\n+    };\n+\n+private:\n+    // Avoid littering this header file with implementation details.\n+    class Impl;\n+    std::unique_ptr<Impl> m_impl;\n+\n+public:\n+    //! Construct a TxRequestTracker.\n+    TxRequestTracker(bool deterministic = false);\n+    ~TxRequestTracker();\n+\n+    // Conceptually, the data structure consists of a collection of entries, one for each peer/txhash combination\n+    // (an \"announcement\"):\n+    //\n+    // - CANDIDATE entries represent transactions that were announced by a peer, and that become available for\n+    //   download after their reqtime has passed.\n+    //\n+    // - REQUESTED entries represent transactions that have been requested, and which we're awaiting a response for\n+    //   from that peer. Their expiry value determines when the request times out.\n+    //\n+    // - COMPLETED entries represent transactions that have been requested from a peer, but they timed out, a\n+    //   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to\n+    //   prevent requesting them again. If only COMPLETED entries for a given txhash remain (so no CANDIDATE or\n+    //   REQUESTED ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+    //\n+    // The operations below manipulate the data structure.\n+\n+    /** Deletes all entries for a given peer.\n+     *\n+     * It should be called when a peer goes offline.\n+     */\n+    void DeletedPeer(uint64_t peer);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494514532",
      "id" : 494514532,
      "in_reply_to_id" : 494469813,
      "line" : 138,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDUxNDUzMg==",
      "original_commit_id" : "164f50402475175d6fc839ae2798817e8da7c68f",
      "original_line" : 138,
      "original_position" : 149,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 138,
      "pull_request_review_id" : 495829638,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-24T18:11:16Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494514532",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494515427"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494515427"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I'm not sure what you're suggesting here. FAILED seems like a bad name as it indeed doesn't imply failure.",
      "commit_id" : "4508a6e58d28eb5436031861aca1a43b76156097",
      "created_at" : "2020-09-24T18:12:52Z",
      "diff_hunk" : "@@ -0,0 +1,213 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not (which peers are preferred is determined by the caller, but this is\n+ *   designed for outbound peers, or other peers that we have a higher level of trust in).\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see '\"First\" marker rules').\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the transaction was forgotten in\n+ *   between (see next point), and re-announced.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening invblock attacks. The flip side is that as long as an attacker manages to prevent\n+ *              us from receiving a transaction, failed announcements (including those from honest peers) will\n+ *              linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on\n+ *              the number of tracked announcements per peer.\n+ *              See https://allquantor.at/blockchainbib/pdf/miller2015topology.pdf for information on invblocking.\n+ *\n+ * - Announcements are only forgotten about when the peer that announced them went offline, when the transaction\n+ *   was received successfully, or when no candidates for a transaction remain that haven't been tried already.\n+ *\n+ *   Rationale: we need to eventually forget announcements to keep memory bounded, but as long as viable\n+ *              candidate peers remain, we prefer to avoid fetching from failed ones. As every request has a finite\n+ *              timeout and we schedule new request as soon a previous one expired, there is always progress being\n+ *              made towards forgetting a transaction - either successfully or unsuccessfully.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable net_processing code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers (outbound, whitelisted) are chosen by us, so are less likely to be under attacker\n+ *                control.\n+ *\n+ *   - Among the remaining candidates, choose the one with the \"first\" marker if one exists (there can be at most\n+ *     one such peer, see further).\n+ *\n+ *     Rationale: in non-attack scenarios we want to give one chance to request from the fastest peer to reduce\n+ *                latency, and reduce risk of breaking chains of dependent transactions. An attacker who races the\n+ *                network can exploit this to delay us learning about a transaction, but it is available only once\n+ *                per txhash.\n+ *\n+ *   - If no remaining candidates have the \"first\" marker, pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: if the \"first\" mechanism failed, random assignments are hard to influence for attackers.\n+ *\n+ * \"First\" marker rules: the \"first\" marker is given to announcements for which at the time of announcement:\n+ * - No requests for its txhash have been attempted (ever, or since it was forgotten about).\n+ * - The peer that announced them was not overloaded.\n+ * - No announcement for the same txhash from another peer within the same preferred/nonpreferred class already has\n+ *   the first marker already.\n+ *\n+ *   Rationale: these restrictions avoid giving the speed benefit to honest but overloaded peers, and also\n+ *              reduce the extent to which attackers that race the network in announcing all transactions\n+ *              can break chains of dependent transactions.\n+ *\n+ * Together these rules strike a balance between being fast in non-adverserial conditions and avoiding influenceable\n+ * by attackers. An invblocking attacker that races the network:\n+ * - Will be unsuccessful if all preferred connections are honest (and there is at least one).\n+ * - If there are P preferred connections of which Ph>=1 are honest, the attacker can delay us from learning\n+ *   about a transaction by k expiration periods, where k ~ 1 + NHG(N=P-1,K=P-Ph-1,r=1), which has mean\n+ *   P/(Ph+1) (where NHG stands for Negative Hypergeometric distribution).\n+ * - If all P preferred connections are to the attacker, and there are NP non-preferred connections of which NPh are\n+ *   honest, k ~ P + 1 + NHG(N=NP-1,K=NP-NPh-1,r=1), with mean P + NP/(NPh+1).\n+ *\n+ * Complexity:\n+ * - Memory usage is proportional to the total number of tracked announcements (Size()) plus the number of\n+ *   peers with a nonzero number of tracked announcements.\n+ * - CPU usage is generally logarithmic in the total number of tracked announcements, plus the number of\n+ *   announcements affected by an operation (amortized O(1) per announcement).\n+ */\n+class TxRequestTracker {\n+public:\n+    /** A functor with embedded salt that computes priority of a txhash/peer combination. Lower priorities are\n+     *  selected first. */\n+    class PriorityComputer {\n+        const uint64_t m_k0, m_k1;\n+    public:\n+        explicit PriorityComputer(bool deterministic);\n+        uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred, bool first) const;\n+    };\n+\n+private:\n+    // Avoid littering this header file with implementation details.\n+    class Impl;\n+    std::unique_ptr<Impl> m_impl;\n+\n+public:\n+    //! Construct a TxRequestTracker.\n+    TxRequestTracker(bool deterministic = false);\n+    ~TxRequestTracker();\n+\n+    // Conceptually, the data structure consists of a collection of entries, one for each peer/txhash combination\n+    // (an \"announcement\"):\n+    //\n+    // - CANDIDATE entries represent transactions that were announced by a peer, and that become available for\n+    //   download after their reqtime has passed.\n+    //\n+    // - REQUESTED entries represent transactions that have been requested, and which we're awaiting a response for\n+    //   from that peer. Their expiry value determines when the request times out.\n+    //\n+    // - COMPLETED entries represent transactions that have been requested from a peer, but they timed out, a",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494515427",
      "id" : 494515427,
      "in_reply_to_id" : 494477588,
      "line" : 127,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDUxNTQyNw==",
      "original_commit_id" : "164f50402475175d6fc839ae2798817e8da7c68f",
      "original_line" : 127,
      "original_position" : 138,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 127,
      "pull_request_review_id" : 495831556,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-24T18:12:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494515427",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494517514"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494517514"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I'm not entirely sure, as the caller really doesn't care about the fact that it also expires things. It just wants to know what should be requested.\r\n\r\nIt's not an implementation detail, as the effect of expiration is observable (CountInFlight, CountTracked() and Size() go  down), but I think that makes just specification details rather than the caller's intent.",
      "commit_id" : "4508a6e58d28eb5436031861aca1a43b76156097",
      "created_at" : "2020-09-24T18:16:36Z",
      "diff_hunk" : "@@ -0,0 +1,213 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not (which peers are preferred is determined by the caller, but this is\n+ *   designed for outbound peers, or other peers that we have a higher level of trust in).\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see '\"First\" marker rules').\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the transaction was forgotten in\n+ *   between (see next point), and re-announced.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening invblock attacks. The flip side is that as long as an attacker manages to prevent\n+ *              us from receiving a transaction, failed announcements (including those from honest peers) will\n+ *              linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on\n+ *              the number of tracked announcements per peer.\n+ *              See https://allquantor.at/blockchainbib/pdf/miller2015topology.pdf for information on invblocking.\n+ *\n+ * - Announcements are only forgotten about when the peer that announced them went offline, when the transaction\n+ *   was received successfully, or when no candidates for a transaction remain that haven't been tried already.\n+ *\n+ *   Rationale: we need to eventually forget announcements to keep memory bounded, but as long as viable\n+ *              candidate peers remain, we prefer to avoid fetching from failed ones. As every request has a finite\n+ *              timeout and we schedule new request as soon a previous one expired, there is always progress being\n+ *              made towards forgetting a transaction - either successfully or unsuccessfully.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable net_processing code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers (outbound, whitelisted) are chosen by us, so are less likely to be under attacker\n+ *                control.\n+ *\n+ *   - Among the remaining candidates, choose the one with the \"first\" marker if one exists (there can be at most\n+ *     one such peer, see further).\n+ *\n+ *     Rationale: in non-attack scenarios we want to give one chance to request from the fastest peer to reduce\n+ *                latency, and reduce risk of breaking chains of dependent transactions. An attacker who races the\n+ *                network can exploit this to delay us learning about a transaction, but it is available only once\n+ *                per txhash.\n+ *\n+ *   - If no remaining candidates have the \"first\" marker, pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: if the \"first\" mechanism failed, random assignments are hard to influence for attackers.\n+ *\n+ * \"First\" marker rules: the \"first\" marker is given to announcements for which at the time of announcement:\n+ * - No requests for its txhash have been attempted (ever, or since it was forgotten about).\n+ * - The peer that announced them was not overloaded.\n+ * - No announcement for the same txhash from another peer within the same preferred/nonpreferred class already has\n+ *   the first marker already.\n+ *\n+ *   Rationale: these restrictions avoid giving the speed benefit to honest but overloaded peers, and also\n+ *              reduce the extent to which attackers that race the network in announcing all transactions\n+ *              can break chains of dependent transactions.\n+ *\n+ * Together these rules strike a balance between being fast in non-adverserial conditions and avoiding influenceable\n+ * by attackers. An invblocking attacker that races the network:\n+ * - Will be unsuccessful if all preferred connections are honest (and there is at least one).\n+ * - If there are P preferred connections of which Ph>=1 are honest, the attacker can delay us from learning\n+ *   about a transaction by k expiration periods, where k ~ 1 + NHG(N=P-1,K=P-Ph-1,r=1), which has mean\n+ *   P/(Ph+1) (where NHG stands for Negative Hypergeometric distribution).\n+ * - If all P preferred connections are to the attacker, and there are NP non-preferred connections of which NPh are\n+ *   honest, k ~ P + 1 + NHG(N=NP-1,K=NP-NPh-1,r=1), with mean P + NP/(NPh+1).\n+ *\n+ * Complexity:\n+ * - Memory usage is proportional to the total number of tracked announcements (Size()) plus the number of\n+ *   peers with a nonzero number of tracked announcements.\n+ * - CPU usage is generally logarithmic in the total number of tracked announcements, plus the number of\n+ *   announcements affected by an operation (amortized O(1) per announcement).\n+ */\n+class TxRequestTracker {\n+public:\n+    /** A functor with embedded salt that computes priority of a txhash/peer combination. Lower priorities are\n+     *  selected first. */\n+    class PriorityComputer {\n+        const uint64_t m_k0, m_k1;\n+    public:\n+        explicit PriorityComputer(bool deterministic);\n+        uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred, bool first) const;\n+    };\n+\n+private:\n+    // Avoid littering this header file with implementation details.\n+    class Impl;\n+    std::unique_ptr<Impl> m_impl;\n+\n+public:\n+    //! Construct a TxRequestTracker.\n+    TxRequestTracker(bool deterministic = false);\n+    ~TxRequestTracker();\n+\n+    // Conceptually, the data structure consists of a collection of entries, one for each peer/txhash combination\n+    // (an \"announcement\"):\n+    //\n+    // - CANDIDATE entries represent transactions that were announced by a peer, and that become available for\n+    //   download after their reqtime has passed.\n+    //\n+    // - REQUESTED entries represent transactions that have been requested, and which we're awaiting a response for\n+    //   from that peer. Their expiry value determines when the request times out.\n+    //\n+    // - COMPLETED entries represent transactions that have been requested from a peer, but they timed out, a\n+    //   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to\n+    //   prevent requesting them again. If only COMPLETED entries for a given txhash remain (so no CANDIDATE or\n+    //   REQUESTED ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+    //\n+    // The operations below manipulate the data structure.\n+\n+    /** Deletes all entries for a given peer.\n+     *\n+     * It should be called when a peer goes offline.\n+     */\n+    void DeletedPeer(uint64_t peer);\n+\n+    /** Deletes all entries for a given txhash.\n+     *\n+     * This should be called when a transaction is successfully added to the mempool, seen in a block, or for\n+     * whatever reason we no longer care about it. The is_wtxid flag of gtxid is ignored.\n+     */\n+    void ForgetTx(const GenTxid& gtxid);\n+\n+    /** Adds a new CANDIDATE entry.\n+     *\n+     * Does nothing if one already exists for that (txhash, peer) combination (whether it's CANDIDATE, REQUESTED, or\n+     * COMPLETED). Note that this means a second INV with the same txhash from the same peer will be ignored, even\n+     * if one is a txid and the other is wtxid (but that shouldn't happen, as BIP339 requires that all announced\n+     * inventory is exclusively using MSG_WTX). The new entry is given the specified preferred and reqtime values,\n+     * and takes it is_wtxid from the specified gtxid. It is eligible to get a first marker if overloaded is false\n+     * (but also subject to the other rules regarding the first marker).\n+     */\n+    void ReceivedInv(uint64_t peer, const GenTxid& gtxid, bool preferred, bool overloaded,\n+        std::chrono::microseconds reqtime);\n+\n+    /** Converts the CANDIDATE entry for the provided peer and gtxid into a REQUESTED one.\n+     *\n+     * Expiry is set to the specified value. This can ONLY be called immediately after GetRequestable was called\n+     * (for the same peer), with only ForgetTx and other RequestedTx calls (both for other txhashes) in\n+     * between. Any other non-const operation removes the ability to call RequestedTx.\n+     */\n+    void RequestedTx(uint64_t peer, const GenTxid& gtxid, std::chrono::microseconds expiry);\n+\n+    /** Converts any CANDIDATE or REQUESTED entry to a COMPLETED one, if one exists.\n+     *\n+     * It should be called whenever a transaction or NOTFOUND was received from a peer. When a good transaction is\n+     * received, ForgetTx should be called instead of (or in addition to) this operation.\n+     */\n+    void ReceivedResponse(uint64_t peer, const GenTxid& gtxid);\n+\n+    // The operations below inspect the data structure.\n+\n+    /** Find the txids to request now from peer.\n+     *\n+     * It does the following:\n+     *  - Convert all REQUESTED entries (for all txhashes/peers) with (expiry <= now) to COMPLETED entries.\n+     *  - Requestable entries are selected: CANDIDATE entries from the specified peer with (reqtime <= now) for\n+     *    which the specified peer is the best choice among all such CANDIDATE entries with the same txhash (subject\n+     *    to preference/first rules, and tiebreaking using a deterministic salted hash of peer and txhash).\n+     *  - The selected entries are sorted in order of announcement (even if multiple were added at the same time, or\n+     *    even when the clock went backwards while they were being added), converted to GenTxids using their\n+     *    is_wtxid flag, and returned.\n+     */\n+    std::vector<GenTxid> GetRequestable(uint64_t peer, std::chrono::microseconds now);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494517514",
      "id" : 494517514,
      "in_reply_to_id" : 494485317,
      "line" : 187,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDUxNzUxNA==",
      "original_commit_id" : "164f50402475175d6fc839ae2798817e8da7c68f",
      "original_line" : 187,
      "original_position" : 198,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 187,
      "pull_request_review_id" : 495835805,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-24T18:21:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494517514",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494517808"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494517808"
         }
      },
      "author_association" : "MEMBER",
      "body" : "@jnewbery How do you suggest to do that in combination with the impl pattern?",
      "commit_id" : "4508a6e58d28eb5436031861aca1a43b76156097",
      "created_at" : "2020-09-24T18:17:09Z",
      "diff_hunk" : "@@ -208,6 +208,15 @@ class TxRequestTracker {\n \n     /** Access to the internal PriorityComputer (for testing) */\n     const PriorityComputer& GetPriorityComputer() const;\n+\n+    /** Run internal consistency check (testing only). */",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494517808",
      "id" : 494517808,
      "in_reply_to_id" : 494488392,
      "line" : 201,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDUxNzgwOA==",
      "original_commit_id" : "71f551d840deaae3c30bb08a2c7a2248b043dbac",
      "original_line" : 201,
      "original_position" : 5,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 201,
      "pull_request_review_id" : 495836489,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-24T18:17:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494517808",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494520862"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494520862"
         }
      },
      "author_association" : "MEMBER",
      "body" : "apologies I wrote my comment in two frame of minds. I mean to say the comment doesn't mention \"success\" as a possibility to transition to this state. Update the comment and I'm happy.",
      "commit_id" : "4508a6e58d28eb5436031861aca1a43b76156097",
      "created_at" : "2020-09-24T18:22:20Z",
      "diff_hunk" : "@@ -0,0 +1,213 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === Specification ===\n+ *\n+ * We keep track of which peers have announced which transactions, and use that to determine which requests\n+ * should go to which peer, when, and in what order.\n+ *\n+ * The following information is tracked per peer/tx combination (\"announcement\"):\n+ * - Which peer announced it (through their NodeId)\n+ * - The txid or wtxid of the transaction (collectively called \"txhash\" in what follows)\n+ * - Whether it was a tx or wtx announcement (see BIP339).\n+ * - What the earliest permitted time is that that transaction can be requested from that peer (called \"reqtime\").\n+ * - Whether it's from a \"preferred\" peer or not (which peers are preferred is determined by the caller, but this is\n+ *   designed for outbound peers, or other peers that we have a higher level of trust in).\n+ * - Whether the peer was the \"first\" to announce this txhash within its class (see '\"First\" marker rules').\n+ * - Whether or not the transaction was requested already, and if so, when it times out (called \"expiry\").\n+ * - Whether or not the transaction request failed already (timed out, or NOTFOUND was received).\n+ *\n+ * Transaction requests are then assigned to peers, following these rules:\n+ *\n+ * - No transaction is requested as long as another request for the same txhash is outstanding (it needs to fail\n+ *   first by passing expiry, or a NOTFOUND or invalid transaction has to be received for it).\n+ *\n+ *   Rationale: to avoid wasting bandwidth on multiple copies of the same transaction.\n+ *\n+ * - The same transaction is never requested twice from the same peer, unless the transaction was forgotten in\n+ *   between (see next point), and re-announced.\n+ *\n+ *   Rationale: giving a peer multiple chances to announce a transaction would allow them to bias requests in their\n+ *              favor, worsening invblock attacks. The flip side is that as long as an attacker manages to prevent\n+ *              us from receiving a transaction, failed announcements (including those from honest peers) will\n+ *              linger longer, increasing memory usage somewhat. The impact of this is limited by imposing a cap on\n+ *              the number of tracked announcements per peer.\n+ *              See https://allquantor.at/blockchainbib/pdf/miller2015topology.pdf for information on invblocking.\n+ *\n+ * - Announcements are only forgotten about when the peer that announced them went offline, when the transaction\n+ *   was received successfully, or when no candidates for a transaction remain that haven't been tried already.\n+ *\n+ *   Rationale: we need to eventually forget announcements to keep memory bounded, but as long as viable\n+ *              candidate peers remain, we prefer to avoid fetching from failed ones. As every request has a finite\n+ *              timeout and we schedule new request as soon a previous one expired, there is always progress being\n+ *              made towards forgetting a transaction - either successfully or unsuccessfully.\n+ *\n+ * - Transactions are not requested from a peer until its reqtime has passed.\n+ *\n+ *   Rationale: enable net_processing code to define a delay for less-than-ideal peers, so that (presumed) better\n+ *              peers have a chance to give their announcement first.\n+ *\n+ * - If multiple viable candidate peers exist according to the above rules, pick a peer as follows:\n+ *\n+ *   - If any preferred peers are available, non-preferred peers are not considered for what follows.\n+ *\n+ *     Rationale: preferred peers (outbound, whitelisted) are chosen by us, so are less likely to be under attacker\n+ *                control.\n+ *\n+ *   - Among the remaining candidates, choose the one with the \"first\" marker if one exists (there can be at most\n+ *     one such peer, see further).\n+ *\n+ *     Rationale: in non-attack scenarios we want to give one chance to request from the fastest peer to reduce\n+ *                latency, and reduce risk of breaking chains of dependent transactions. An attacker who races the\n+ *                network can exploit this to delay us learning about a transaction, but it is available only once\n+ *                per txhash.\n+ *\n+ *   - If no remaining candidates have the \"first\" marker, pick a uniformly random peer among the candidates.\n+ *\n+ *     Rationale: if the \"first\" mechanism failed, random assignments are hard to influence for attackers.\n+ *\n+ * \"First\" marker rules: the \"first\" marker is given to announcements for which at the time of announcement:\n+ * - No requests for its txhash have been attempted (ever, or since it was forgotten about).\n+ * - The peer that announced them was not overloaded.\n+ * - No announcement for the same txhash from another peer within the same preferred/nonpreferred class already has\n+ *   the first marker already.\n+ *\n+ *   Rationale: these restrictions avoid giving the speed benefit to honest but overloaded peers, and also\n+ *              reduce the extent to which attackers that race the network in announcing all transactions\n+ *              can break chains of dependent transactions.\n+ *\n+ * Together these rules strike a balance between being fast in non-adverserial conditions and avoiding influenceable\n+ * by attackers. An invblocking attacker that races the network:\n+ * - Will be unsuccessful if all preferred connections are honest (and there is at least one).\n+ * - If there are P preferred connections of which Ph>=1 are honest, the attacker can delay us from learning\n+ *   about a transaction by k expiration periods, where k ~ 1 + NHG(N=P-1,K=P-Ph-1,r=1), which has mean\n+ *   P/(Ph+1) (where NHG stands for Negative Hypergeometric distribution).\n+ * - If all P preferred connections are to the attacker, and there are NP non-preferred connections of which NPh are\n+ *   honest, k ~ P + 1 + NHG(N=NP-1,K=NP-NPh-1,r=1), with mean P + NP/(NPh+1).\n+ *\n+ * Complexity:\n+ * - Memory usage is proportional to the total number of tracked announcements (Size()) plus the number of\n+ *   peers with a nonzero number of tracked announcements.\n+ * - CPU usage is generally logarithmic in the total number of tracked announcements, plus the number of\n+ *   announcements affected by an operation (amortized O(1) per announcement).\n+ */\n+class TxRequestTracker {\n+public:\n+    /** A functor with embedded salt that computes priority of a txhash/peer combination. Lower priorities are\n+     *  selected first. */\n+    class PriorityComputer {\n+        const uint64_t m_k0, m_k1;\n+    public:\n+        explicit PriorityComputer(bool deterministic);\n+        uint64_t operator()(const uint256& txhash, uint64_t peer, bool preferred, bool first) const;\n+    };\n+\n+private:\n+    // Avoid littering this header file with implementation details.\n+    class Impl;\n+    std::unique_ptr<Impl> m_impl;\n+\n+public:\n+    //! Construct a TxRequestTracker.\n+    TxRequestTracker(bool deterministic = false);\n+    ~TxRequestTracker();\n+\n+    // Conceptually, the data structure consists of a collection of entries, one for each peer/txhash combination\n+    // (an \"announcement\"):\n+    //\n+    // - CANDIDATE entries represent transactions that were announced by a peer, and that become available for\n+    //   download after their reqtime has passed.\n+    //\n+    // - REQUESTED entries represent transactions that have been requested, and which we're awaiting a response for\n+    //   from that peer. Their expiry value determines when the request times out.\n+    //\n+    // - COMPLETED entries represent transactions that have been requested from a peer, but they timed out, a",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19988#discussion_r494520862",
      "id" : 494520862,
      "in_reply_to_id" : 494477588,
      "line" : 127,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDUyMDg2Mg==",
      "original_commit_id" : "164f50402475175d6fc839ae2798817e8da7c68f",
      "original_line" : 127,
      "original_position" : 138,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 127,
      "pull_request_review_id" : 495841657,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19988",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-24T18:22:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/494520862",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   }
]
